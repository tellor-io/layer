
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bridge: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/tellor-io/layer/x/bridge/genesis.go (100.0%)</option>
				
				<option value="file1">github.com/tellor-io/layer/x/bridge/keeper/keeper.go (1.2%)</option>
				
				<option value="file2">github.com/tellor-io/layer/x/bridge/keeper/msg_server.go (100.0%)</option>
				
				<option value="file3">github.com/tellor-io/layer/x/bridge/keeper/msg_server_request_attestations.go (0.0%)</option>
				
				<option value="file4">github.com/tellor-io/layer/x/bridge/keeper/params.go (100.0%)</option>
				
				<option value="file5">github.com/tellor-io/layer/x/bridge/keeper/query.go (100.0%)</option>
				
				<option value="file6">github.com/tellor-io/layer/x/bridge/keeper/query_get_attestation_data_by_snapshot.go (0.0%)</option>
				
				<option value="file7">github.com/tellor-io/layer/x/bridge/keeper/query_get_attestations_by_snapshot.go (0.0%)</option>
				
				<option value="file8">github.com/tellor-io/layer/x/bridge/keeper/query_get_current_aggregate_report.go (0.0%)</option>
				
				<option value="file9">github.com/tellor-io/layer/x/bridge/keeper/query_get_data_before.go (0.0%)</option>
				
				<option value="file10">github.com/tellor-io/layer/x/bridge/keeper/query_get_evm_address_by_validator_address.go (0.0%)</option>
				
				<option value="file11">github.com/tellor-io/layer/x/bridge/keeper/query_get_evm_validators.go (0.0%)</option>
				
				<option value="file12">github.com/tellor-io/layer/x/bridge/keeper/query_get_snapshots_by_report.go (0.0%)</option>
				
				<option value="file13">github.com/tellor-io/layer/x/bridge/keeper/query_get_validator_checkpoint.go (0.0%)</option>
				
				<option value="file14">github.com/tellor-io/layer/x/bridge/keeper/query_get_validator_checkpoint_params.go (0.0%)</option>
				
				<option value="file15">github.com/tellor-io/layer/x/bridge/keeper/query_get_validator_timestamp_by_index.go (0.0%)</option>
				
				<option value="file16">github.com/tellor-io/layer/x/bridge/keeper/query_get_valset_by_timestamp.go (0.0%)</option>
				
				<option value="file17">github.com/tellor-io/layer/x/bridge/keeper/query_get_valset_sigs.go (0.0%)</option>
				
				<option value="file18">github.com/tellor-io/layer/x/bridge/keeper/query_params.go (75.0%)</option>
				
				<option value="file19">github.com/tellor-io/layer/x/bridge/module.go (0.0%)</option>
				
				<option value="file20">github.com/tellor-io/layer/x/bridge/module_simulation.go (0.0%)</option>
				
				<option value="file21">github.com/tellor-io/layer/x/bridge/types/attestation_requests.go (0.0%)</option>
				
				<option value="file22">github.com/tellor-io/layer/x/bridge/types/attestation_snapshot_data.go (0.0%)</option>
				
				<option value="file23">github.com/tellor-io/layer/x/bridge/types/attestation_snapshots.go (0.0%)</option>
				
				<option value="file24">github.com/tellor-io/layer/x/bridge/types/bridge_valset_signatures.go (0.0%)</option>
				
				<option value="file25">github.com/tellor-io/layer/x/bridge/types/checkpoint_idx.go (0.0%)</option>
				
				<option value="file26">github.com/tellor-io/layer/x/bridge/types/checkpoint_timestamp.go (0.0%)</option>
				
				<option value="file27">github.com/tellor-io/layer/x/bridge/types/codec.go (0.0%)</option>
				
				<option value="file28">github.com/tellor-io/layer/x/bridge/types/evm_address.go (0.0%)</option>
				
				<option value="file29">github.com/tellor-io/layer/x/bridge/types/genesis.go (100.0%)</option>
				
				<option value="file30">github.com/tellor-io/layer/x/bridge/types/genesis.pb.go (1.2%)</option>
				
				<option value="file31">github.com/tellor-io/layer/x/bridge/types/message_request_attestations.go (0.0%)</option>
				
				<option value="file32">github.com/tellor-io/layer/x/bridge/types/operator_address.go (0.0%)</option>
				
				<option value="file33">github.com/tellor-io/layer/x/bridge/types/oracle_attestations.go (0.0%)</option>
				
				<option value="file34">github.com/tellor-io/layer/x/bridge/types/params.go (42.9%)</option>
				
				<option value="file35">github.com/tellor-io/layer/x/bridge/types/params.pb.go (1.6%)</option>
				
				<option value="file36">github.com/tellor-io/layer/x/bridge/types/query.pb.go (0.8%)</option>
				
				<option value="file37">github.com/tellor-io/layer/x/bridge/types/query.pb.gw.go (0.0%)</option>
				
				<option value="file38">github.com/tellor-io/layer/x/bridge/types/tx.pb.go (0.9%)</option>
				
				<option value="file39">github.com/tellor-io/layer/x/bridge/types/validator_checkpoint.go (0.0%)</option>
				
				<option value="file40">github.com/tellor-io/layer/x/bridge/types/validator_checkpoint_params.go (0.0%)</option>
				
				<option value="file41">github.com/tellor-io/layer/x/dispute/genesis.go (100.0%)</option>
				
				<option value="file42">github.com/tellor-io/layer/x/dispute/keeper/abci.go (0.0%)</option>
				
				<option value="file43">github.com/tellor-io/layer/x/dispute/keeper/dispute.go (50.0%)</option>
				
				<option value="file44">github.com/tellor-io/layer/x/dispute/keeper/dispute_fee.go (36.0%)</option>
				
				<option value="file45">github.com/tellor-io/layer/x/dispute/keeper/execute.go (0.0%)</option>
				
				<option value="file46">github.com/tellor-io/layer/x/dispute/keeper/keeper.go (85.7%)</option>
				
				<option value="file47">github.com/tellor-io/layer/x/dispute/keeper/msg_server.go (100.0%)</option>
				
				<option value="file48">github.com/tellor-io/layer/x/dispute/keeper/msg_server_add_fee_to_dispute.go (0.0%)</option>
				
				<option value="file49">github.com/tellor-io/layer/x/dispute/keeper/msg_server_propose_dispute.go (58.3%)</option>
				
				<option value="file50">github.com/tellor-io/layer/x/dispute/keeper/msg_server_vote.go (67.9%)</option>
				
				<option value="file51">github.com/tellor-io/layer/x/dispute/keeper/params.go (100.0%)</option>
				
				<option value="file52">github.com/tellor-io/layer/x/dispute/keeper/query_params.go (75.0%)</option>
				
				<option value="file53">github.com/tellor-io/layer/x/dispute/keeper/tally.go (29.9%)</option>
				
				<option value="file54">github.com/tellor-io/layer/x/dispute/keeper/vote.go (72.7%)</option>
				
				<option value="file55">github.com/tellor-io/layer/x/dispute/module.go (2.9%)</option>
				
				<option value="file56">github.com/tellor-io/layer/x/dispute/module_simulation.go (0.0%)</option>
				
				<option value="file57">github.com/tellor-io/layer/x/dispute/types/codec.go (0.0%)</option>
				
				<option value="file58">github.com/tellor-io/layer/x/dispute/types/dispute.pb.go (0.6%)</option>
				
				<option value="file59">github.com/tellor-io/layer/x/dispute/types/dispute_params.pb.go (1.0%)</option>
				
				<option value="file60">github.com/tellor-io/layer/x/dispute/types/genesis.go (100.0%)</option>
				
				<option value="file61">github.com/tellor-io/layer/x/dispute/types/genesis.pb.go (1.2%)</option>
				
				<option value="file62">github.com/tellor-io/layer/x/dispute/types/keys.go (0.0%)</option>
				
				<option value="file63">github.com/tellor-io/layer/x/dispute/types/message_add_fee_to_dispute.go (30.8%)</option>
				
				<option value="file64">github.com/tellor-io/layer/x/dispute/types/message_propose_dispute.go (30.8%)</option>
				
				<option value="file65">github.com/tellor-io/layer/x/dispute/types/message_vote.go (30.8%)</option>
				
				<option value="file66">github.com/tellor-io/layer/x/dispute/types/open_disputes.pb.go (1.0%)</option>
				
				<option value="file67">github.com/tellor-io/layer/x/dispute/types/params.go (42.9%)</option>
				
				<option value="file68">github.com/tellor-io/layer/x/dispute/types/params.pb.go (1.6%)</option>
				
				<option value="file69">github.com/tellor-io/layer/x/dispute/types/query.pb.go (1.2%)</option>
				
				<option value="file70">github.com/tellor-io/layer/x/dispute/types/query.pb.gw.go (0.0%)</option>
				
				<option value="file71">github.com/tellor-io/layer/x/dispute/types/tally.pb.go (0.8%)</option>
				
				<option value="file72">github.com/tellor-io/layer/x/dispute/types/tx.pb.go (0.9%)</option>
				
				<option value="file73">github.com/tellor-io/layer/x/dispute/types/vote.pb.go (1.0%)</option>
				
				<option value="file74">github.com/tellor-io/layer/x/dispute/types/voter_classes.pb.go (0.8%)</option>
				
				<option value="file75">github.com/tellor-io/layer/x/oracle/abci.go (0.0%)</option>
				
				<option value="file76">github.com/tellor-io/layer/x/oracle/genesis.go (75.0%)</option>
				
				<option value="file77">github.com/tellor-io/layer/x/oracle/keeper/aggregate.go (26.3%)</option>
				
				<option value="file78">github.com/tellor-io/layer/x/oracle/keeper/cycle_list.go (57.1%)</option>
				
				<option value="file79">github.com/tellor-io/layer/x/oracle/keeper/hooks.go (0.0%)</option>
				
				<option value="file80">github.com/tellor-io/layer/x/oracle/keeper/indexes.go (85.7%)</option>
				
				<option value="file81">github.com/tellor-io/layer/x/oracle/keeper/keeper.go (45.7%)</option>
				
				<option value="file82">github.com/tellor-io/layer/x/oracle/keeper/msg_server.go (100.0%)</option>
				
				<option value="file83">github.com/tellor-io/layer/x/oracle/keeper/msg_server_commit_report.go (72.0%)</option>
				
				<option value="file84">github.com/tellor-io/layer/x/oracle/keeper/msg_server_submit_value.go (45.0%)</option>
				
				<option value="file85">github.com/tellor-io/layer/x/oracle/keeper/msg_server_tip.go (34.0%)</option>
				
				<option value="file86">github.com/tellor-io/layer/x/oracle/keeper/msg_update_cyclelist.go (0.0%)</option>
				
				<option value="file87">github.com/tellor-io/layer/x/oracle/keeper/msg_update_params.go (83.3%)</option>
				
				<option value="file88">github.com/tellor-io/layer/x/oracle/keeper/params.go (75.0%)</option>
				
				<option value="file89">github.com/tellor-io/layer/x/oracle/keeper/query.go (100.0%)</option>
				
				<option value="file90">github.com/tellor-io/layer/x/oracle/keeper/query_current_cyclelist_query.go (0.0%)</option>
				
				<option value="file91">github.com/tellor-io/layer/x/oracle/keeper/query_get_aggregated_report.go (87.5%)</option>
				
				<option value="file92">github.com/tellor-io/layer/x/oracle/keeper/query_get_current_tip.go (28.6%)</option>
				
				<option value="file93">github.com/tellor-io/layer/x/oracle/keeper/query_get_data_before.go (0.0%)</option>
				
				<option value="file94">github.com/tellor-io/layer/x/oracle/keeper/query_get_reports.go (75.8%)</option>
				
				<option value="file95">github.com/tellor-io/layer/x/oracle/keeper/query_get_time_based_rewards.go (0.0%)</option>
				
				<option value="file96">github.com/tellor-io/layer/x/oracle/keeper/query_get_user_tip_total.go (0.0%)</option>
				
				<option value="file97">github.com/tellor-io/layer/x/oracle/keeper/query_params.go (71.4%)</option>
				
				<option value="file98">github.com/tellor-io/layer/x/oracle/keeper/rewards.go (8.1%)</option>
				
				<option value="file99">github.com/tellor-io/layer/x/oracle/keeper/submit_value.go (76.2%)</option>
				
				<option value="file100">github.com/tellor-io/layer/x/oracle/keeper/tip.go (13.9%)</option>
				
				<option value="file101">github.com/tellor-io/layer/x/oracle/keeper/weighted_median.go (92.9%)</option>
				
				<option value="file102">github.com/tellor-io/layer/x/oracle/keeper/weighted_mode.go (93.1%)</option>
				
				<option value="file103">github.com/tellor-io/layer/x/oracle/module.go (3.2%)</option>
				
				<option value="file104">github.com/tellor-io/layer/x/oracle/module_simulation.go (0.0%)</option>
				
				<option value="file105">github.com/tellor-io/layer/x/oracle/types/aggregate.pb.go (0.6%)</option>
				
				<option value="file106">github.com/tellor-io/layer/x/oracle/types/aggregate_reporter.pb.go (1.1%)</option>
				
				<option value="file107">github.com/tellor-io/layer/x/oracle/types/codec.go (0.0%)</option>
				
				<option value="file108">github.com/tellor-io/layer/x/oracle/types/commit_report.pb.go (0.8%)</option>
				
				<option value="file109">github.com/tellor-io/layer/x/oracle/types/cyclelist.go (87.5%)</option>
				
				<option value="file110">github.com/tellor-io/layer/x/oracle/types/genesis.go (100.0%)</option>
				
				<option value="file111">github.com/tellor-io/layer/x/oracle/types/genesis.pb.go (1.0%)</option>
				
				<option value="file112">github.com/tellor-io/layer/x/oracle/types/keys.go (0.0%)</option>
				
				<option value="file113">github.com/tellor-io/layer/x/oracle/types/median_values.pb.go (1.2%)</option>
				
				<option value="file114">github.com/tellor-io/layer/x/oracle/types/message_commit_report.go (16.7%)</option>
				
				<option value="file115">github.com/tellor-io/layer/x/oracle/types/message_submit_value.go (16.7%)</option>
				
				<option value="file116">github.com/tellor-io/layer/x/oracle/types/message_tip.go (25.0%)</option>
				
				<option value="file117">github.com/tellor-io/layer/x/oracle/types/micro_report.pb.go (0.5%)</option>
				
				<option value="file118">github.com/tellor-io/layer/x/oracle/types/msg_update_params.go (0.0%)</option>
				
				<option value="file119">github.com/tellor-io/layer/x/oracle/types/params.go (27.3%)</option>
				
				<option value="file120">github.com/tellor-io/layer/x/oracle/types/params.pb.go (1.2%)</option>
				
				<option value="file121">github.com/tellor-io/layer/x/oracle/types/query.pb.go (0.9%)</option>
				
				<option value="file122">github.com/tellor-io/layer/x/oracle/types/query.pb.gw.go (0.0%)</option>
				
				<option value="file123">github.com/tellor-io/layer/x/oracle/types/query_id_timestamp_pair.pb.go (1.0%)</option>
				
				<option value="file124">github.com/tellor-io/layer/x/oracle/types/query_meta.pb.go (0.6%)</option>
				
				<option value="file125">github.com/tellor-io/layer/x/oracle/types/reports.pb.go (1.2%)</option>
				
				<option value="file126">github.com/tellor-io/layer/x/oracle/types/tips.pb.go (0.9%)</option>
				
				<option value="file127">github.com/tellor-io/layer/x/oracle/types/tx.pb.go (0.8%)</option>
				
				<option value="file128">github.com/tellor-io/layer/x/oracle/types/user_tip.pb.go (1.0%)</option>
				
				<option value="file129">github.com/tellor-io/layer/x/registry/keeper/dataspec.go (100.0%)</option>
				
				<option value="file130">github.com/tellor-io/layer/x/registry/keeper/keeper.go (64.7%)</option>
				
				<option value="file131">github.com/tellor-io/layer/x/registry/keeper/msg_server.go (100.0%)</option>
				
				<option value="file132">github.com/tellor-io/layer/x/registry/keeper/msg_server_register_spec.go (85.7%)</option>
				
				<option value="file133">github.com/tellor-io/layer/x/registry/keeper/msg_update_spec.go (71.4%)</option>
				
				<option value="file134">github.com/tellor-io/layer/x/registry/keeper/params.go (80.0%)</option>
				
				<option value="file135">github.com/tellor-io/layer/x/registry/keeper/query.go (100.0%)</option>
				
				<option value="file136">github.com/tellor-io/layer/x/registry/keeper/query_decode_querydata.go (68.8%)</option>
				
				<option value="file137">github.com/tellor-io/layer/x/registry/keeper/query_decode_value.go (70.0%)</option>
				
				<option value="file138">github.com/tellor-io/layer/x/registry/keeper/query_generate_querydata.go (66.7%)</option>
				
				<option value="file139">github.com/tellor-io/layer/x/registry/keeper/query_get_data_spec.go (83.3%)</option>
				
				<option value="file140">github.com/tellor-io/layer/x/registry/keeper/query_params.go (71.4%)</option>
				
				<option value="file141">github.com/tellor-io/layer/x/registry/module/autocli.go (0.0%)</option>
				
				<option value="file142">github.com/tellor-io/layer/x/registry/module/genesis.go (83.3%)</option>
				
				<option value="file143">github.com/tellor-io/layer/x/registry/module/module.go (4.0%)</option>
				
				<option value="file144">github.com/tellor-io/layer/x/registry/module/module_simulation.go (0.0%)</option>
				
				<option value="file145">github.com/tellor-io/layer/x/registry/types/codec.go (0.0%)</option>
				
				<option value="file146">github.com/tellor-io/layer/x/registry/types/conversions.go (83.8%)</option>
				
				<option value="file147">github.com/tellor-io/layer/x/registry/types/data_spec.pb.go (0.6%)</option>
				
				<option value="file148">github.com/tellor-io/layer/x/registry/types/dataspec.go (77.9%)</option>
				
				<option value="file149">github.com/tellor-io/layer/x/registry/types/decoding.go (80.0%)</option>
				
				<option value="file150">github.com/tellor-io/layer/x/registry/types/encoding.go (75.0%)</option>
				
				<option value="file151">github.com/tellor-io/layer/x/registry/types/genesis.go (100.0%)</option>
				
				<option value="file152">github.com/tellor-io/layer/x/registry/types/genesis.pb.go (1.0%)</option>
				
				<option value="file153">github.com/tellor-io/layer/x/registry/types/helpers.go (91.7%)</option>
				
				<option value="file154">github.com/tellor-io/layer/x/registry/types/hooks.go (0.0%)</option>
				
				<option value="file155">github.com/tellor-io/layer/x/registry/types/message_register_spec.go (36.4%)</option>
				
				<option value="file156">github.com/tellor-io/layer/x/registry/types/params.go (42.9%)</option>
				
				<option value="file157">github.com/tellor-io/layer/x/registry/types/params.pb.go (1.6%)</option>
				
				<option value="file158">github.com/tellor-io/layer/x/registry/types/query.pb.go (0.9%)</option>
				
				<option value="file159">github.com/tellor-io/layer/x/registry/types/query.pb.gw.go (0.0%)</option>
				
				<option value="file160">github.com/tellor-io/layer/x/registry/types/supported_value_types.go (0.0%)</option>
				
				<option value="file161">github.com/tellor-io/layer/x/registry/types/tx.pb.go (0.9%)</option>
				
				<option value="file162">github.com/tellor-io/layer/x/reporter/keeper/distribution.go (43.8%)</option>
				
				<option value="file163">github.com/tellor-io/layer/x/reporter/keeper/hooks.go (21.1%)</option>
				
				<option value="file164">github.com/tellor-io/layer/x/reporter/keeper/indexes.go (100.0%)</option>
				
				<option value="file165">github.com/tellor-io/layer/x/reporter/keeper/jail.go (0.0%)</option>
				
				<option value="file166">github.com/tellor-io/layer/x/reporter/keeper/keeper.go (72.7%)</option>
				
				<option value="file167">github.com/tellor-io/layer/x/reporter/keeper/msg_server.go (5.0%)</option>
				
				<option value="file168">github.com/tellor-io/layer/x/reporter/keeper/msg_server_create_reporter.go (62.9%)</option>
				
				<option value="file169">github.com/tellor-io/layer/x/reporter/keeper/msg_server_delegate_reporter.go (60.0%)</option>
				
				<option value="file170">github.com/tellor-io/layer/x/reporter/keeper/msg_server_undelegate_reporter.go (73.1%)</option>
				
				<option value="file171">github.com/tellor-io/layer/x/reporter/keeper/msg_server_withdraw_tip.go (0.0%)</option>
				
				<option value="file172">github.com/tellor-io/layer/x/reporter/keeper/msg_update_params.go (83.3%)</option>
				
				<option value="file173">github.com/tellor-io/layer/x/reporter/keeper/params.go (100.0%)</option>
				
				<option value="file174">github.com/tellor-io/layer/x/reporter/keeper/query.go (1.3%)</option>
				
				<option value="file175">github.com/tellor-io/layer/x/reporter/keeper/query_params.go (71.4%)</option>
				
				<option value="file176">github.com/tellor-io/layer/x/reporter/keeper/reporter.go (58.8%)</option>
				
				<option value="file177">github.com/tellor-io/layer/x/reporter/keeper/withdraw.go (0.0%)</option>
				
				<option value="file178">github.com/tellor-io/layer/x/reporter/module/autocli.go (0.0%)</option>
				
				<option value="file179">github.com/tellor-io/layer/x/reporter/module/genesis.go (77.8%)</option>
				
				<option value="file180">github.com/tellor-io/layer/x/reporter/module/module.go (3.6%)</option>
				
				<option value="file181">github.com/tellor-io/layer/x/reporter/module/simulation.go (0.0%)</option>
				
				<option value="file182">github.com/tellor-io/layer/x/reporter/types/codec.go (0.0%)</option>
				
				<option value="file183">github.com/tellor-io/layer/x/reporter/types/delegation.go (0.0%)</option>
				
				<option value="file184">github.com/tellor-io/layer/x/reporter/types/delegation.pb.go (1.0%)</option>
				
				<option value="file185">github.com/tellor-io/layer/x/reporter/types/distribution.pb.go (0.9%)</option>
				
				<option value="file186">github.com/tellor-io/layer/x/reporter/types/genesis.go (100.0%)</option>
				
				<option value="file187">github.com/tellor-io/layer/x/reporter/types/genesis.pb.go (1.2%)</option>
				
				<option value="file188">github.com/tellor-io/layer/x/reporter/types/keys.go (0.0%)</option>
				
				<option value="file189">github.com/tellor-io/layer/x/reporter/types/message_create_reporter.go (80.0%)</option>
				
				<option value="file190">github.com/tellor-io/layer/x/reporter/types/message_delegate_reporter.go (80.0%)</option>
				
				<option value="file191">github.com/tellor-io/layer/x/reporter/types/message_undelegate_reporter.go (80.0%)</option>
				
				<option value="file192">github.com/tellor-io/layer/x/reporter/types/message_withdraw_tip.go (80.0%)</option>
				
				<option value="file193">github.com/tellor-io/layer/x/reporter/types/msg_update_params.go (0.0%)</option>
				
				<option value="file194">github.com/tellor-io/layer/x/reporter/types/oracle_reporter.go (0.0%)</option>
				
				<option value="file195">github.com/tellor-io/layer/x/reporter/types/oracle_reporter.pb.go (0.7%)</option>
				
				<option value="file196">github.com/tellor-io/layer/x/reporter/types/params.go (66.7%)</option>
				
				<option value="file197">github.com/tellor-io/layer/x/reporter/types/params.pb.go (1.1%)</option>
				
				<option value="file198">github.com/tellor-io/layer/x/reporter/types/query.pb.go (1.0%)</option>
				
				<option value="file199">github.com/tellor-io/layer/x/reporter/types/query.pb.gw.go (0.0%)</option>
				
				<option value="file200">github.com/tellor-io/layer/x/reporter/types/token_origin.pb.go (0.8%)</option>
				
				<option value="file201">github.com/tellor-io/layer/x/reporter/types/tx.pb.go (0.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package bridge

import (
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/bridge/keeper"
        "github.com/tellor-io/layer/x/bridge/types"
)

// InitGenesis initializes the module's state from a provided genesis state.
func InitGenesis(ctx sdk.Context, k keeper.Keeper, genState types.GenesisState) <span class="cov8" title="1">{
        // this line is used by starport scaffolding # genesis/module/init
        k.Params.Set(ctx, genState.Params)
}</span>

// ExportGenesis returns the module's exported genesis
func ExportGenesis(ctx sdk.Context, k keeper.Keeper) *types.GenesisState <span class="cov8" title="1">{
        genesis := types.DefaultGenesis()
        genesis.Params = k.GetParams(ctx)

        // this line is used by starport scaffolding # genesis/module/export

        return genesis
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package keeper

import (
        "bytes"
        "context"
        "crypto/sha256"
        "encoding/binary"
        "encoding/hex"
        "fmt"
        "math/big"
        "time"

        gomath "math"

        "cosmossdk.io/collections"
        storetypes "cosmossdk.io/core/store"
        "cosmossdk.io/log"
        math "cosmossdk.io/math"
        "github.com/cosmos/cosmos-sdk/codec"
        sdk "github.com/cosmos/cosmos-sdk/types"

        "github.com/ethereum/go-ethereum/accounts/abi"
        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/crypto"

        "sort"

        "github.com/tellor-io/layer/x/bridge/types"
)

type (
        Keeper struct {
                cdc          codec.BinaryCodec
                storeService storetypes.KVStoreService

                Schema                       collections.Schema
                Params                       collections.Item[types.Params]
                BridgeValset                 collections.Item[types.BridgeValidatorSet]
                ValidatorCheckpoint          collections.Item[types.ValidatorCheckpoint]
                OperatorToEVMAddressMap      collections.Map[string, types.EVMAddress]
                BridgeValsetSignaturesMap    collections.Map[uint64, types.BridgeValsetSignatures]
                ValidatorCheckpointParamsMap collections.Map[uint64, types.ValidatorCheckpointParams]
                ValidatorCheckpointIdxMap    collections.Map[uint64, types.CheckpointTimestamp]
                LatestCheckpointIdx          collections.Item[types.CheckpointIdx]
                BridgeValsetByTimestampMap   collections.Map[uint64, types.BridgeValidatorSet]
                ValsetTimestampToIdxMap      collections.Map[uint64, types.CheckpointIdx]
                AttestSnapshotsByReportMap   collections.Map[string, types.AttestationSnapshots]
                AttestSnapshotDataMap        collections.Map[string, types.AttestationSnapshotData]
                SnapshotToAttestationsMap    collections.Map[string, types.OracleAttestations]
                AttestRequestsByHeightMap    collections.Map[uint64, types.AttestationRequests]

                stakingKeeper  types.StakingKeeper
                slashingKeeper types.SlashingKeeper
                oracleKeeper   types.OracleKeeper
        }
)

func NewKeeper(
        cdc codec.BinaryCodec,
        storeService storetypes.KVStoreService,
        stakingKeeper types.StakingKeeper,
        slashingKeeper types.SlashingKeeper,
        oracleKeeper types.OracleKeeper,
) Keeper <span class="cov8" title="1">{
        sb := collections.NewSchemaBuilder(storeService)
        k := Keeper{
                cdc:                          cdc,
                storeService:                 storeService,
                Params:                       collections.NewItem(sb, types.ParamsKey, "params", codec.CollValue[types.Params](cdc)),
                BridgeValset:                 collections.NewItem(sb, types.BridgeValsetKey, "bridge_valset", codec.CollValue[types.BridgeValidatorSet](cdc)),
                ValidatorCheckpoint:          collections.NewItem(sb, types.ValidatorCheckpointKey, "validator_checkpoint", codec.CollValue[types.ValidatorCheckpoint](cdc)),
                OperatorToEVMAddressMap:      collections.NewMap(sb, types.OperatorToEVMAddressMapKey, "operator_to_evm_address_map", collections.StringKey, codec.CollValue[types.EVMAddress](cdc)),
                BridgeValsetSignaturesMap:    collections.NewMap(sb, types.BridgeValsetSignaturesMapKey, "bridge_valset_signatures_map", collections.Uint64Key, codec.CollValue[types.BridgeValsetSignatures](cdc)),
                ValidatorCheckpointParamsMap: collections.NewMap(sb, types.ValidatorCheckpointParamsMapKey, "validator_checkpoint_params_map", collections.Uint64Key, codec.CollValue[types.ValidatorCheckpointParams](cdc)),
                ValidatorCheckpointIdxMap:    collections.NewMap(sb, types.ValidatorCheckpointIdxMapKey, "validator_checkpoint_idx_map", collections.Uint64Key, codec.CollValue[types.CheckpointTimestamp](cdc)),
                LatestCheckpointIdx:          collections.NewItem(sb, types.LatestCheckpointIdxKey, "latest_checkpoint_idx", codec.CollValue[types.CheckpointIdx](cdc)),
                BridgeValsetByTimestampMap:   collections.NewMap(sb, types.BridgeValsetByTimestampMapKey, "bridge_valset_by_timestamp_map", collections.Uint64Key, codec.CollValue[types.BridgeValidatorSet](cdc)),
                ValsetTimestampToIdxMap:      collections.NewMap(sb, types.ValsetTimestampToIdxMapKey, "valset_timestamp_to_idx_map", collections.Uint64Key, codec.CollValue[types.CheckpointIdx](cdc)),
                AttestSnapshotsByReportMap:   collections.NewMap(sb, types.AttestSnapshotsByReportMapKey, "attest_snapshots_by_report_map", collections.StringKey, codec.CollValue[types.AttestationSnapshots](cdc)),
                AttestSnapshotDataMap:        collections.NewMap(sb, types.AttestSnapshotDataMapKey, "attest_snapshot_data_map", collections.StringKey, codec.CollValue[types.AttestationSnapshotData](cdc)),
                SnapshotToAttestationsMap:    collections.NewMap(sb, types.SnapshotToAttestationsMapKey, "snapshot_to_attestations_map", collections.StringKey, codec.CollValue[types.OracleAttestations](cdc)),
                AttestRequestsByHeightMap:    collections.NewMap(sb, types.AttestRequestsByHeightMapKey, "attest_requests_by_height_map", collections.Uint64Key, codec.CollValue[types.AttestationRequests](cdc)),

                stakingKeeper:  stakingKeeper,
                slashingKeeper: slashingKeeper,
                oracleKeeper:   oracleKeeper,
        }

        schema, err := sb.Build()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">k.Schema = schema
        return k</span>
}

func (k Keeper) Logger(ctx context.Context) log.Logger <span class="cov0" title="0">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)
        return sdkCtx.Logger().With("module", fmt.Sprintf("x/%s", types.ModuleName))
}</span>

func (k Keeper) GetCurrentValidatorsEVMCompatible(ctx context.Context) ([]*types.BridgeValidator, error) <span class="cov0" title="0">{
        validators, err := k.stakingKeeper.GetAllValidators(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">bridgeValset := make([]*types.BridgeValidator, len(validators))

        for i, validator := range validators </span><span class="cov0" title="0">{
                evmAddress, err := k.OperatorToEVMAddressMap.Get(ctx, validator.GetOperator())
                evmAddressHex := hex.EncodeToString(evmAddress.EVMAddress)
                if err != nil </span><span class="cov0" title="0">{
                        k.Logger(ctx).Info("Error getting EVM address from operator address", "error", err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">bridgeValset[i] = &amp;types.BridgeValidator{
                        EthereumAddress: evmAddressHex,
                        Power:           uint64(validator.GetConsensusPower(math.NewInt(10))),
                }</span>
        }

        // Sort the validators
        <span class="cov0" title="0">sort.Slice(bridgeValset, func(i, j int) bool </span><span class="cov0" title="0">{
                if bridgeValset[i].Power == bridgeValset[j].Power </span><span class="cov0" title="0">{
                        // If power is equal, sort alphabetically
                        return bridgeValset[i].EthereumAddress &lt; bridgeValset[j].EthereumAddress
                }</span>
                // Otherwise, sort by power in descending order
                <span class="cov0" title="0">return bridgeValset[i].Power &gt; bridgeValset[j].Power</span>
        })

        <span class="cov0" title="0">return bridgeValset, nil</span>
}

func (k Keeper) GetCurrentValidatorSetEVMCompatible(ctx context.Context) (*types.BridgeValidatorSet, error) <span class="cov0" title="0">{
        // use GetBridgeValidators to get the current bridge validator set
        bridgeValset, err := k.GetCurrentValidatorsEVMCompatible(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;types.BridgeValidatorSet{BridgeValidatorSet: bridgeValset}, nil</span>
}

// function for loading last saved bridge validator set and comparing it to current set
func (k Keeper) CompareBridgeValidators(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        // load current validator set in EVM compatible format
        currentValidatorSetEVMCompatible, err := k.GetCurrentValidatorSetEVMCompatible(ctx)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("No current validator set found")
                return false, err
        }</span>

        <span class="cov0" title="0">lastSavedBridgeValidators, err := k.BridgeValset.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("No saved bridge validator set found")
                err := k.BridgeValset.Set(ctx, *currentValidatorSetEVMCompatible)
                if err != nil </span><span class="cov0" title="0">{
                        k.Logger(ctx).Info("Error setting bridge validator set: ", "error", err)
                        return false, err
                }</span>
                <span class="cov0" title="0">error := k.SetBridgeValidatorParams(ctx, currentValidatorSetEVMCompatible)
                if error != nil </span><span class="cov0" title="0">{
                        k.Logger(ctx).Info("Error setting bridge validator params: ", "error", error)
                        return false, error
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov0" title="0">if bytes.Equal(k.cdc.MustMarshal(&amp;lastSavedBridgeValidators), k.cdc.MustMarshal(currentValidatorSetEVMCompatible)) </span><span class="cov0" title="0">{
                return false, nil
        }</span> else<span class="cov0" title="0"> if k.PowerDiff(ctx, lastSavedBridgeValidators, *currentValidatorSetEVMCompatible) &lt; 0.05 </span><span class="cov0" title="0">{
                return false, nil
        }</span> else<span class="cov0" title="0"> {
                err := k.BridgeValset.Set(ctx, *currentValidatorSetEVMCompatible)
                if err != nil </span><span class="cov0" title="0">{
                        k.Logger(ctx).Info("Error setting bridge validator set: ", "error", err)
                        return false, err
                }</span>
                <span class="cov0" title="0">error := k.SetBridgeValidatorParams(ctx, currentValidatorSetEVMCompatible)
                if error != nil </span><span class="cov0" title="0">{
                        k.Logger(ctx).Info("Error setting bridge validator params: ", "error", error)
                        return false, error
                }</span>
                <span class="cov0" title="0">return true, nil</span>
        }
}

func (k Keeper) SetBridgeValidatorParams(ctx context.Context, bridgeValidatorSet *types.BridgeValidatorSet) error <span class="cov0" title="0">{
        var totalPower uint64
        for _, validator := range bridgeValidatorSet.BridgeValidatorSet </span><span class="cov0" title="0">{
                totalPower += validator.GetPower()
        }</span>
        <span class="cov0" title="0">powerThreshold := totalPower * 2 / 3

        sdkCtx := sdk.UnwrapSDKContext(ctx)
        validatorTimestamp := uint64(sdkCtx.BlockTime().Unix())

        // calculate validator set hash
        _, validatorSetHash, err := k.EncodeAndHashValidatorSet(ctx, bridgeValidatorSet)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error encoding and hashing validator set: ", "error", err)
                return err
        }</span>

        // calculate validator set checkpoint
        <span class="cov0" title="0">checkpoint, err := k.CalculateValidatorSetCheckpoint(ctx, powerThreshold, validatorTimestamp, validatorSetHash)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error calculating validator set checkpoint: ", "error", err)
                return err
        }</span>

        // Set the validator checkpoint
        <span class="cov0" title="0">checkpointType := types.ValidatorCheckpoint{
                Checkpoint: checkpoint,
        }

        error := k.ValidatorCheckpoint.Set(ctx, checkpointType)
        if error != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error setting validator checkpoint: ", "error", error)
                return error
        }</span>

        // Set the bridge valset by timestamp
        <span class="cov0" title="0">err = k.BridgeValsetByTimestampMap.Set(ctx, validatorTimestamp, *bridgeValidatorSet)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error setting bridge valset by timestamp: ", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">valsetIdx, err := k.LatestCheckpointIdx.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting latest checkpoint index: ", "error", err)
                // TODO: handle error?
        }</span>
        <span class="cov0" title="0">if valsetIdx.Index == 0 </span><span class="cov0" title="0">{
                // TODO: no need to set signatures for the first valset
                valsetSigs := types.NewBridgeValsetSignatures(len(bridgeValidatorSet.BridgeValidatorSet))
                err = k.BridgeValsetSignaturesMap.Set(ctx, validatorTimestamp, *valsetSigs)
                if err != nil </span><span class="cov0" title="0">{
                        k.Logger(ctx).Info("Error setting bridge valset signatures: ", "error", err)
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">previousValsetTimestamp, err := k.ValidatorCheckpointIdxMap.Get(ctx, valsetIdx.Index-1)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting previous valset timestamp: ", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">previousValset, err := k.BridgeValsetByTimestampMap.Get(ctx, previousValsetTimestamp.Timestamp)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting previous valset: ", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">valsetSigs := types.NewBridgeValsetSignatures(len(previousValset.BridgeValidatorSet))
        err = k.BridgeValsetSignaturesMap.Set(ctx, validatorTimestamp, *valsetSigs)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error setting bridge valset signatures: ", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (k Keeper) CalculateValidatorSetCheckpoint(
        ctx context.Context,
        powerThreshold uint64,
        validatorTimestamp uint64,
        validatorSetHash []byte,
) ([]byte, error) <span class="cov0" title="0">{
        // Define the domain separator for the validator set hash, fixed size 32 bytes
        VALIDATOR_SET_HASH_DOMAIN_SEPARATOR := []byte("checkpoint")
        var domainSeparatorFixSize [32]byte
        copy(domainSeparatorFixSize[:], VALIDATOR_SET_HASH_DOMAIN_SEPARATOR)

        // Convert validatorSetHash to a fixed size 32 bytes
        var validatorSetHashFixSize [32]byte
        copy(validatorSetHashFixSize[:], validatorSetHash)

        // Convert powerThreshold and validatorTimestamp to *big.Int for ABI encoding
        powerThresholdBigInt := new(big.Int).SetUint64(powerThreshold)
        validatorTimestampBigInt := new(big.Int).SetUint64(validatorTimestamp)

        Bytes32Type, err := abi.NewType("bytes32", "", nil)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Warn("Error creating new bytes32 ABI type", "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">Uint256Type, err := abi.NewType("uint256", "", nil)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Warn("Error creating new uint256 ABI type", "error", err)
                return nil, err
        }</span>

        // Prepare the types for encoding
        <span class="cov0" title="0">arguments := abi.Arguments{
                {Type: Bytes32Type},
                {Type: Uint256Type},
                {Type: Uint256Type},
                {Type: Bytes32Type},
        }

        // Encode the arguments
        encodedCheckpointData, err := arguments.Pack(
                domainSeparatorFixSize,
                powerThresholdBigInt,
                validatorTimestampBigInt,
                validatorSetHashFixSize,
        )
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Warn("Error encoding arguments", "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">checkpoint := crypto.Keccak256(encodedCheckpointData)

        // save checkpoint params
        checkpointParams := types.ValidatorCheckpointParams{
                Checkpoint:     checkpoint,
                ValsetHash:     validatorSetHash,
                Timestamp:      int64(validatorTimestamp),
                PowerThreshold: int64(powerThreshold),
        }
        err = k.ValidatorCheckpointParamsMap.Set(ctx, validatorTimestamp, checkpointParams)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error setting validator checkpoint params: ", "error", err)
                return nil, err
        }</span>

        // load checkpoint index. if not found, set to 0
        <span class="cov0" title="0">checkpointIdx := types.CheckpointIdx{}
        lastCheckpointIdx, err := k.LatestCheckpointIdx.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting latest checkpoint index: ", "error", err)
                checkpointIdx.Index = 0
        }</span> else<span class="cov0" title="0"> {
                checkpointIdx.Index = lastCheckpointIdx.Index + 1
        }</span>

        // save checkpoint index
        <span class="cov0" title="0">err = k.ValidatorCheckpointIdxMap.Set(ctx, checkpointIdx.Index, types.CheckpointTimestamp{Timestamp: validatorTimestamp})
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error setting validator checkpoint index: ", "error", err)
                return nil, err
        }</span>

        // save latest checkpoint index
        <span class="cov0" title="0">err = k.LatestCheckpointIdx.Set(ctx, checkpointIdx)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error setting latest checkpoint index: ", "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">err = k.ValsetTimestampToIdxMap.Set(ctx, validatorTimestamp, checkpointIdx)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error setting valset timestamp to index: ", "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return checkpoint, nil</span>
}

func (k Keeper) GetValidatorCheckpointFromStorage(ctx context.Context) (*types.ValidatorCheckpoint, error) <span class="cov0" title="0">{
        checkpoint, err := k.ValidatorCheckpoint.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Error("Failed to get validator checkpoint", "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;checkpoint, nil</span>
}

func (k Keeper) GetValidatorCheckpointParamsFromStorage(ctx context.Context, timestamp uint64) (*types.ValidatorCheckpointParams, error) <span class="cov0" title="0">{
        checkpointParams, err := k.ValidatorCheckpointParamsMap.Get(ctx, timestamp)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Error("Failed to get validator checkpoint params", "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;checkpointParams, nil</span>
}

func (k Keeper) GetValidatorTimestampByIdxFromStorage(ctx context.Context, checkpointIdx uint64) (*types.CheckpointTimestamp, error) <span class="cov0" title="0">{
        checkpointTimestamp, err := k.ValidatorCheckpointIdxMap.Get(ctx, checkpointIdx)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Error("Failed to get validator checkpoint index", "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;checkpointTimestamp, nil</span>
}

func (k Keeper) GetValidatorSetSignaturesFromStorage(ctx context.Context, timestamp uint64) (*types.BridgeValsetSignatures, error) <span class="cov0" title="0">{
        valsetSigs, err := k.BridgeValsetSignaturesMap.Get(ctx, timestamp)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Error("Failed to get bridge valset signatures", "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;valsetSigs, nil</span>
}

func (k Keeper) EncodeAndHashValidatorSet(ctx context.Context, validatorSet *types.BridgeValidatorSet) (encodedBridgeValidatorSet []byte, bridgeValidatorSetHash []byte, err error) <span class="cov0" title="0">{
        // Define Go equivalent of the Solidity Validator struct
        type Validator struct {
                Addr  common.Address
                Power *big.Int
        }

        // Convert validatorSet to a slice of the Validator struct defined above
        var validators []Validator
        for _, v := range validatorSet.BridgeValidatorSet </span><span class="cov0" title="0">{
                addr := common.HexToAddress(v.EthereumAddress)
                power := big.NewInt(0).SetUint64(v.Power)
                validators = append(validators, Validator{Addr: addr, Power: power})
        }</span>

        // Solidity dynamic array encoding starts with the offset to the data
        // followed by the length of the array itself. Since we're directly encoding the array next,
        // the data starts immediately after these two fields, which is at 64 bytes offset.
        <span class="cov0" title="0">offsetToData := make([]byte, 32)
        binary.BigEndian.PutUint64(offsetToData[24:], uint64(32)) // 64 bytes offset to the start of the data

        // Encode the length of the array
        arrayLength := len(validators)
        lengthEncoded := make([]byte, 32)
        binary.BigEndian.PutUint64(lengthEncoded[24:], uint64(arrayLength))

        AddressType, err := abi.NewType("address", "", nil)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Warn("Error creating new address ABI type", "error", err)
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">UintType, err := abi.NewType("uint256", "", nil)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Warn("Error creating new uint256 ABI type", "error", err)
                return nil, nil, err
        }</span>

        // Encode each Validator struct
        <span class="cov0" title="0">var encodedVals []byte
        for _, val := range validators </span><span class="cov0" title="0">{
                encodedVal, err := abi.Arguments{
                        {Type: AddressType},
                        {Type: UintType},
                }.Pack(val.Addr, val.Power)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov0" title="0">encodedVals = append(encodedVals, encodedVal...)</span>
        }

        // Concatenate the offset, length, and encoded validators
        <span class="cov0" title="0">finalEncoded := append(offsetToData, lengthEncoded...)
        finalEncoded = append(finalEncoded, encodedVals...)

        // Hash the encoded bytes
        valSetHash := crypto.Keccak256(finalEncoded)

        return finalEncoded, valSetHash, nil</span>
}

func (k Keeper) PowerDiff(ctx context.Context, b types.BridgeValidatorSet, c types.BridgeValidatorSet) float64 <span class="cov0" title="0">{
        powers := map[string]int64{}
        var totalPower int64
        for _, bv := range b.BridgeValidatorSet </span><span class="cov0" title="0">{
                power := int64(bv.GetPower())
                powers[bv.EthereumAddress] = power
                totalPower += power
        }</span>

        <span class="cov0" title="0">for _, bv := range c.BridgeValidatorSet </span><span class="cov0" title="0">{
                if val, ok := powers[bv.EthereumAddress]; ok </span><span class="cov0" title="0">{
                        powers[bv.EthereumAddress] = val - int64(bv.GetPower())
                }</span> else<span class="cov0" title="0"> {
                        powers[bv.EthereumAddress] = -int64(bv.GetPower())
                }</span>
        }

        <span class="cov0" title="0">var delta float64
        for _, v := range powers </span><span class="cov0" title="0">{
                delta += gomath.Abs(float64(v))
        }</span>

        <span class="cov0" title="0">if totalPower == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">relativeDiff := delta / float64(totalPower)
        return relativeDiff</span>
}

func (k Keeper) EVMAddressFromSignatures(ctx sdk.Context, sigA []byte, sigB []byte) (common.Address, error) <span class="cov0" title="0">{
        msgA := "TellorLayer: Initial bridge signature A"
        msgB := "TellorLayer: Initial bridge signature B"

        // convert messages to bytes
        msgBytesA := []byte(msgA)
        msgBytesB := []byte(msgB)

        // hash messages
        msgHashBytes32A := sha256.Sum256(msgBytesA)
        msgHashBytesA := msgHashBytes32A[:]

        msgHashBytes32B := sha256.Sum256(msgBytesB)
        msgHashBytesB := msgHashBytes32B[:]

        // hash the hash, since the keyring signer automatically hashes the message
        msgDoubleHashBytes32A := sha256.Sum256(msgHashBytesA)
        msgDoubleHashBytesA := msgDoubleHashBytes32A[:]

        msgDoubleHashBytes32B := sha256.Sum256(msgHashBytesB)
        msgDoubleHashBytesB := msgDoubleHashBytes32B[:]

        addressesA, err := k.tryRecoverAddressWithBothIDs(sigA, msgDoubleHashBytesA)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Warn("Error trying to recover address with both IDs", "error", err)
                return common.Address{}, err
        }</span>
        <span class="cov0" title="0">addressesB, err := k.tryRecoverAddressWithBothIDs(sigB, msgDoubleHashBytesB)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Warn("Error trying to recover address with both IDs", "error", err)
                return common.Address{}, err
        }</span>

        // check if addresses match
        <span class="cov0" title="0">if bytes.Equal(addressesA[0].Bytes(), addressesB[0].Bytes()) || bytes.Equal(addressesA[0].Bytes(), addressesB[1].Bytes()) </span><span class="cov0" title="0">{
                return addressesA[0], nil
        }</span> else<span class="cov0" title="0"> if bytes.Equal(addressesA[1].Bytes(), addressesB[0].Bytes()) || bytes.Equal(addressesA[1].Bytes(), addressesB[1].Bytes()) </span><span class="cov0" title="0">{
                return addressesA[1], nil
        }</span> else<span class="cov0" title="0"> {
                k.Logger(ctx).Warn("EVM addresses do not match")
                return common.Address{}, fmt.Errorf("EVM addresses do not match")
        }</span>
}

func (k Keeper) tryRecoverAddressWithBothIDs(sig []byte, msgHash []byte) ([]common.Address, error) <span class="cov0" title="0">{
        var addrs []common.Address
        for _, id := range []byte{0, 1} </span><span class="cov0" title="0">{
                sigWithID := append(sig[:64], id)
                pubKey, err := crypto.SigToPub(msgHash, sigWithID)
                if err != nil </span><span class="cov0" title="0">{
                        return []common.Address{}, err
                }</span>
                <span class="cov0" title="0">recoveredAddr := crypto.PubkeyToAddress(*pubKey)
                addrs = append(addrs, recoveredAddr)</span>
        }
        <span class="cov0" title="0">return addrs, nil</span>
}

func (k Keeper) SetEVMAddressByOperator(ctx sdk.Context, operatorAddr string, evmAddr string) error <span class="cov0" title="0">{
        evmAddrBytes := common.HexToAddress(evmAddr).Bytes()
        evmAddrType := types.EVMAddress{
                EVMAddress: evmAddrBytes,
        }

        err := k.OperatorToEVMAddressMap.Set(ctx, operatorAddr, types.EVMAddress(evmAddrType))
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error setting EVM address by operator", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (k Keeper) SetBridgeValsetSignature(ctx context.Context, operatorAddress string, timestamp uint64, signature string) error <span class="cov0" title="0">{
        // get the bridge valset signatures array by timestamp
        valsetSigs, err := k.BridgeValsetSignaturesMap.Get(ctx, timestamp)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting bridge valset signatures", "error", err)
                return err
        }</span>
        // get the evm address associated with the operator address
        <span class="cov0" title="0">ethAddress, err := k.OperatorToEVMAddressMap.Get(ctx, operatorAddress)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting EVM address from operator address", "error", err)
                return err
        }</span>
        // get the valset index by timestamp
        <span class="cov0" title="0">valsetIdx, err := k.ValsetTimestampToIdxMap.Get(ctx, timestamp)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting valset index by timestamp", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">if valsetIdx.Index == 0 </span><span class="cov0" title="0">{
                k.Logger(ctx).Warn("Valset index is 0")
                return nil
        }</span>
        <span class="cov0" title="0">previousIndex := valsetIdx.Index - 1
        previousValsetTimestamp, err := k.ValidatorCheckpointIdxMap.Get(ctx, previousIndex)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting previous valset timestamp", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">previousValset, err := k.BridgeValsetByTimestampMap.Get(ctx, previousValsetTimestamp.Timestamp)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting previous valset", "error", err)
                return err
        }</span>
        // decode the signature hex
        <span class="cov0" title="0">signatureBytes, err := hex.DecodeString(signature)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error decoding signature hex", "error", err)
                return err
        }</span>
        // set the signature in the valset signatures array by finding the index of the operator address
        <span class="cov0" title="0">ethAddressHex := hex.EncodeToString(ethAddress.EVMAddress)
        for i, val := range previousValset.BridgeValidatorSet </span><span class="cov0" title="0">{
                if val.EthereumAddress == ethAddressHex </span><span class="cov0" title="0">{
                        valsetSigs.SetSignature(i, signatureBytes)
                }</span>
        }
        // set the valset signatures array by timestamp
        <span class="cov0" title="0">err = k.BridgeValsetSignaturesMap.Set(ctx, timestamp, valsetSigs)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error setting bridge valset signatures", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (k Keeper) SetOracleAttestation(ctx sdk.Context, operatorAddress string, snapshot []byte, sig []byte) error <span class="cov0" title="0">{
        // get the evm address associated with the operator address
        ethAddress, err := k.OperatorToEVMAddressMap.Get(ctx, operatorAddress)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting EVM address from operator address", "error", err)
                return err
        }</span>
        // get the last saved bridge validator set
        <span class="cov0" title="0">lastSavedBridgeValidators, err := k.BridgeValset.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting last saved bridge validators", "error", err)
                return err
        }</span>
        // set the signature in the oracle attestation map by finding the index of the operator address
        <span class="cov0" title="0">ethAddressHex := hex.EncodeToString(ethAddress.EVMAddress)
        snapshotHex := hex.EncodeToString(snapshot)
        for i, val := range lastSavedBridgeValidators.BridgeValidatorSet </span><span class="cov0" title="0">{
                if val.EthereumAddress == ethAddressHex </span><span class="cov0" title="0">{
                        snapshotToSigsMap, err := k.SnapshotToAttestationsMap.Get(ctx, snapshotHex)
                        if err != nil </span><span class="cov0" title="0">{
                                k.Logger(ctx).Info("Error getting snapshot to attestations map", "error", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">snapshotToSigsMap.SetAttestation(i, sig)
                        err = k.SnapshotToAttestationsMap.Set(ctx, snapshotHex, snapshotToSigsMap)
                        if err != nil </span><span class="cov0" title="0">{
                                k.Logger(ctx).Info("Error setting snapshot to attestations map", "error", err)
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (k Keeper) GetEVMAddressByOperator(ctx sdk.Context, operatorAddress string) (string, error) <span class="cov0" title="0">{
        ethAddress, err := k.OperatorToEVMAddressMap.Get(ctx, operatorAddress)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting EVM address from operator address", "error", err)
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(ethAddress.EVMAddress), nil</span>
}

func (k Keeper) SetBridgeValsetByTimestamp(ctx context.Context, timestamp uint64, bridgeValset types.BridgeValidatorSet) error <span class="cov0" title="0">{
        err := k.BridgeValsetByTimestampMap.Set(ctx, timestamp, bridgeValset)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error setting bridge valset by timestamp", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (k Keeper) GetBridgeValsetByTimestamp(ctx context.Context, timestamp uint64) (*types.BridgeValidatorSet, error) <span class="cov0" title="0">{
        bridgeValset, err := k.BridgeValsetByTimestampMap.Get(ctx, timestamp)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting bridge valset by timestamp", "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;bridgeValset, nil</span>
}

func (k Keeper) GetLatestCheckpointIndex(ctx context.Context) (uint64, error) <span class="cov0" title="0">{
        checkpointIdx, err := k.LatestCheckpointIdx.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting latest checkpoint index", "error", err)
                return 0, err
        }</span>
        <span class="cov0" title="0">return checkpointIdx.Index, nil</span>
}

func (k Keeper) GetValidatorDidSignCheckpoint(ctx context.Context, operatorAddr string, checkpointTimestamp uint64) (didSign bool, prevValsetIndex int64, err error) <span class="cov0" title="0">{
        // get the valset index by timestamp
        valsetIdx, err := k.ValsetTimestampToIdxMap.Get(ctx, checkpointTimestamp)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting valset index by timestamp", "error", err)
                return false, -1, err
        }</span>
        <span class="cov0" title="0">if valsetIdx.Index == 0 </span><span class="cov0" title="0">{
                k.Logger(ctx).Warn("Valset index is 0")
                return false, -1, nil
        }</span>
        // get previous valset
        <span class="cov0" title="0">previousIndex := valsetIdx.Index - 1
        previousValsetTimestamp, err := k.ValidatorCheckpointIdxMap.Get(ctx, previousIndex)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting previous valset timestamp", "error", err)
                return false, -1, err
        }</span>
        <span class="cov0" title="0">previousValset, err := k.BridgeValsetByTimestampMap.Get(ctx, previousValsetTimestamp.Timestamp)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting previous valset", "error", err)
                return false, -1, err
        }</span>
        // get the evm address associated with the operator address
        <span class="cov0" title="0">ethAddress, err := k.OperatorToEVMAddressMap.Get(ctx, operatorAddr)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting EVM address from operator address", "error", err)
                return false, -1, err
        }</span>
        // get the valset signatures array by timestamp
        <span class="cov0" title="0">valsetSigs, err := k.BridgeValsetSignaturesMap.Get(ctx, checkpointTimestamp)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting bridge valset signatures", "error", err)
                return false, -1, err
        }</span>
        // get the index of the evm address in the previous valset
        <span class="cov0" title="0">ethAddressHex := hex.EncodeToString(ethAddress.EVMAddress)
        for i, val := range previousValset.BridgeValidatorSet </span><span class="cov0" title="0">{
                if val.EthereumAddress == ethAddressHex </span><span class="cov0" title="0">{
                        // check if the signature exists
                        if len(valsetSigs.Signatures[i]) != 0 </span><span class="cov0" title="0">{
                                return true, int64(i), nil
                        }</span> else<span class="cov0" title="0"> {
                                return false, int64(i), nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return false, -1, nil</span>
}

func (k Keeper) CreateNewReportSnapshots(ctx sdk.Context) error <span class="cov0" title="0">{
        blockHeight := ctx.BlockHeight()

        reports := k.oracleKeeper.GetAggregatedReportsByHeight(ctx, blockHeight)
        for _, report := range reports </span><span class="cov0" title="0">{
                queryId := report.QueryId
                timeNow := time.Now().Add(time.Second)
                reportTime, err := k.oracleKeeper.GetTimestampBefore(ctx, queryId, timeNow)
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">err = k.CreateSnapshot(ctx, queryId, reportTime)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Called with each new agg report and with new request for optimistic attestations
func (k Keeper) CreateSnapshot(ctx sdk.Context, queryId []byte, timestamp time.Time) error <span class="cov0" title="0">{
        aggReport, err := k.oracleKeeper.GetAggregateByTimestamp(ctx, queryId, timestamp)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting aggregate report by timestamp", "error", err)
                return err
        }</span>
        // get the current validator checkpoint
        <span class="cov0" title="0">validatorCheckpoint, err := k.GetValidatorCheckpointFromStorage(ctx)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting validator checkpoint from storage", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">tsBefore, err := k.oracleKeeper.GetTimestampBefore(ctx, queryId, timestamp)
        if err != nil </span><span class="cov0" title="0">{
                tsBefore = time.Unix(0, 0)
        }</span>

        <span class="cov0" title="0">tsAfter, err := k.oracleKeeper.GetTimestampAfter(ctx, queryId, timestamp)
        if err != nil </span><span class="cov0" title="0">{
                tsAfter = time.Unix(0, 0)
        }</span>

        // use current block time for attestationTimestamp
        <span class="cov0" title="0">attestationTimestamp := ctx.BlockTime()

        snapshotBytes, err := k.EncodeOracleAttestationData(
                hex.EncodeToString(queryId),
                aggReport.AggregateValue,
                timestamp.Unix(),
                aggReport.ReporterPower,
                tsBefore.Unix(),
                tsAfter.Unix(),
                hex.EncodeToString(validatorCheckpoint.Checkpoint),
                attestationTimestamp.Unix(),
        )
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error encoding oracle attestation data", "error", err)
                return err
        }</span>

        // set snapshot by report
        <span class="cov0" title="0">key := hex.EncodeToString(crypto.Keccak256([]byte(hex.EncodeToString(queryId) + fmt.Sprint(timestamp.Unix()))))
        // check if map for this key exists, otherwise create a new map
        exists, err := k.AttestSnapshotsByReportMap.Has(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error checking if attestation snapshots by report map exists", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                attestationSnapshots := types.NewAttestationSnapshots()
                err = k.AttestSnapshotsByReportMap.Set(ctx, key, *attestationSnapshots)
                if err != nil </span><span class="cov0" title="0">{
                        k.Logger(ctx).Info("Error setting attestation snapshots by report", "error", err)
                        return err
                }</span>
        }
        <span class="cov0" title="0">attestationSnapshots, err := k.AttestSnapshotsByReportMap.Get(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting attestation snapshots by report", "error", err)
                return err
        }</span>
        // set the snapshot by report
        <span class="cov0" title="0">attestationSnapshots.SetSnapshot(snapshotBytes)
        err = k.AttestSnapshotsByReportMap.Set(ctx, key, attestationSnapshots)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error setting attestation snapshots by report", "error", err)
                return err
        }</span>

        // set snapshot to snapshot data map
        <span class="cov0" title="0">snapshotData := types.AttestationSnapshotData{
                ValidatorCheckpoint:  validatorCheckpoint.Checkpoint,
                AttestationTimestamp: int64(attestationTimestamp.Unix()),
                PrevReportTimestamp:  int64(tsBefore.Unix()),
                NextReportTimestamp:  int64(tsAfter.Unix()),
                QueryId:              queryId,
                Timestamp:            int64(timestamp.Unix()),
        }
        err = k.AttestSnapshotDataMap.Set(ctx, hex.EncodeToString(snapshotBytes), snapshotData)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error setting attestation snapshot data", "error", err)
                return err
        }</span>

        // initialize snapshot to attestations map
        <span class="cov0" title="0">lastSavedBridgeValidators, err := k.BridgeValset.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting last saved bridge validators", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">oracleAttestations := types.NewOracleAttestations(len(lastSavedBridgeValidators.BridgeValidatorSet))
        // set the map
        err = k.SnapshotToAttestationsMap.Set(ctx, hex.EncodeToString(snapshotBytes), *oracleAttestations)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error setting snapshot to attestations map", "error", err)
                return err
        }</span>

        // add to attestation requests
        <span class="cov0" title="0">blockHeight := uint64(ctx.BlockHeight())
        exists, err = k.AttestRequestsByHeightMap.Has(ctx, blockHeight)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error checking if attestation requests by height map exists", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                attestRequests := types.AttestationRequests{}
                err = k.AttestRequestsByHeightMap.Set(ctx, blockHeight, attestRequests)
                if err != nil </span><span class="cov0" title="0">{
                        k.Logger(ctx).Info("Error setting attestation requests by height", "error", err)
                        return err
                }</span>
        }
        <span class="cov0" title="0">attestRequests, err := k.AttestRequestsByHeightMap.Get(ctx, blockHeight)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting attestation requests by height", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">request := types.AttestationRequest{
                Snapshot: snapshotBytes,
        }
        attestRequests.AddRequest(&amp;request)
        return k.AttestRequestsByHeightMap.Set(ctx, blockHeight, attestRequests)</span>
}

func (k Keeper) EncodeOracleAttestationData(
        queryId string,
        value string,
        timestamp int64,
        aggregatePower int64,
        previousTimestamp int64,
        nextTimestamp int64,
        valsetCheckpoint string,
        attestationTimestamp int64,
) ([]byte, error) <span class="cov0" title="0">{
        // domainSeparator is bytes "tellorNewReport"
        domainSep := "74656c6c6f7243757272656e744174746573746174696f6e0000000000000000"
        NEW_REPORT_ATTESTATION_DOMAIN_SEPERATOR, err := hex.DecodeString(domainSep)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Convert domain separator to bytes32
        <span class="cov0" title="0">var domainSepBytes32 [32]byte
        copy(domainSepBytes32[:], NEW_REPORT_ATTESTATION_DOMAIN_SEPERATOR)

        // Convert queryId to bytes32
        queryIdBytes, err := hex.DecodeString(queryId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var queryIdBytes32 [32]byte
        copy(queryIdBytes32[:], queryIdBytes)

        // Convert value to bytes
        valueBytes, err := hex.DecodeString(value)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert timestamp to uint64
        <span class="cov0" title="0">timestampUint64 := new(big.Int)
        timestampUint64.SetInt64(timestamp)

        // Convert aggregatePower to uint64
        aggregatePowerUint64 := new(big.Int)
        aggregatePowerUint64.SetInt64(aggregatePower)

        // Convert previousTimestamp to uint64
        previousTimestampUint64 := new(big.Int)
        previousTimestampUint64.SetInt64(previousTimestamp)

        // Convert nextTimestamp to uint64
        nextTimestampUint64 := new(big.Int)
        nextTimestampUint64.SetInt64(nextTimestamp)

        // Convert valsetCheckpoint to bytes32
        valsetCheckpointBytes, err := hex.DecodeString(valsetCheckpoint)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var valsetCheckpointBytes32 [32]byte
        copy(valsetCheckpointBytes32[:], valsetCheckpointBytes)

        // Convert attestationTimestamp to uint64
        attestationTimestampUint64 := new(big.Int)
        attestationTimestampUint64.SetInt64(attestationTimestamp)

        // Prepare Encoding
        Bytes32Type, err := abi.NewType("bytes32", "", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Uint256Type, err := abi.NewType("uint256", "", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">BytesType, err := abi.NewType("bytes", "", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">arguments := abi.Arguments{
                {Type: Bytes32Type},
                {Type: Bytes32Type},
                {Type: BytesType},
                {Type: Uint256Type},
                {Type: Uint256Type},
                {Type: Uint256Type},
                {Type: Uint256Type},
                {Type: Bytes32Type},
                {Type: Uint256Type},
        }

        // Encode the data
        encodedData, err := arguments.Pack(
                domainSepBytes32,
                queryIdBytes32,
                valueBytes,
                timestampUint64,
                aggregatePowerUint64,
                previousTimestampUint64,
                nextTimestampUint64,
                valsetCheckpointBytes32,
                attestationTimestampUint64,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">oracleAttestationHash := crypto.Keccak256(encodedData)
        return oracleAttestationHash, nil</span>
}

func (k Keeper) GetAttestationRequestsByHeight(ctx sdk.Context, height uint64) (*types.AttestationRequests, error) <span class="cov0" title="0">{
        attestRequests, err := k.AttestRequestsByHeightMap.Get(ctx, height)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Info("Error getting attestation requests by height", "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;attestRequests, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package keeper

import (
        "github.com/tellor-io/layer/x/bridge/types"
)

type msgServer struct {
        Keeper
}

// NewMsgServerImpl returns an implementation of the MsgServer interface
// for the provided Keeper.
func NewMsgServerImpl(keeper Keeper) types.MsgServer <span class="cov8" title="1">{
        return &amp;msgServer{Keeper: keeper}
}</span>

var _ types.MsgServer = msgServer{}
</pre>
		
		<pre class="file" id="file3" style="display: none">package keeper

import (
        "context"
        "encoding/hex"
        "strconv"
        "time"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/bridge/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k msgServer) RequestAttestations(ctx context.Context, msg *types.MsgRequestAttestations) (*types.MsgRequestAttestationsResponse, error) <span class="cov0" title="0">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)

        queryId, err := hex.DecodeString(msg.QueryId)
        if err != nil </span><span class="cov0" title="0">{
                k.Keeper.Logger(sdkCtx).Error("failed to decode query id", "error", err)
                return nil, status.Error(codes.InvalidArgument, err.Error())
        }</span>

        <span class="cov0" title="0">timestampInt, err := strconv.ParseUint(msg.Timestamp, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                k.Keeper.Logger(sdkCtx).Error("failed to parse timestamp", "error", err)
                return nil, status.Error(codes.InvalidArgument, err.Error())
        }</span>
        <span class="cov0" title="0">timestamp := time.Unix(int64(timestampInt), 0)
        err = k.Keeper.CreateSnapshot(sdkCtx, queryId, timestamp)
        if err != nil </span><span class="cov0" title="0">{
                k.Keeper.Logger(sdkCtx).Error("failed to create snapshot", "error", err)
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;types.MsgRequestAttestationsResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package keeper

import (
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/bridge/types"
)

// GetParams get all parameters as types.Params
func (k Keeper) GetParams(ctx sdk.Context) types.Params <span class="cov8" title="1">{
        return types.NewParams()
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package keeper

import (
        "github.com/tellor-io/layer/x/bridge/types"
)

type Querier struct {
        Keeper
}

func NewQuerier(keeper Keeper) Querier <span class="cov8" title="1">{
        return Querier{Keeper: keeper}
}</span>

var _ types.QueryServer = Querier{}
</pre>
		
		<pre class="file" id="file6" style="display: none">package keeper

import (
        "context"
        "encoding/hex"
        "fmt"
        "strconv"
        "time"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/bridge/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Keeper) GetAttestationDataBySnapshot(goCtx context.Context, req *types.QueryGetAttestationDataBySnapshotRequest) (*types.QueryGetAttestationDataBySnapshotResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>
        <span class="cov0" title="0">snapshot := req.Snapshot

        ctx := sdk.UnwrapSDKContext(goCtx)

        snapshotData, err := k.AttestSnapshotDataMap.Get(ctx, snapshot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("snapshot not found for snapshot %s", snapshot))
        }</span>
        <span class="cov0" title="0">queryId := snapshotData.QueryId
        timestampTime := time.Unix(snapshotData.Timestamp, 0)

        aggReport, err := k.oracleKeeper.GetAggregateByTimestamp(ctx, queryId, timestampTime)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("aggregate not found for queryId %s and timestamp %s", queryId, timestampTime))
        }</span>

        <span class="cov0" title="0">queryIdStr := hex.EncodeToString(queryId)
        timestampStr := strconv.FormatInt(snapshotData.Timestamp, 10)
        aggValueStr := aggReport.AggregateValue
        aggPowerStr := strconv.FormatInt(aggReport.ReporterPower, 10)
        checkpointStr := hex.EncodeToString(snapshotData.ValidatorCheckpoint)
        attestationTimestampStr := strconv.FormatInt(snapshotData.AttestationTimestamp, 10)
        previousReportTimestampStr := strconv.FormatInt(snapshotData.PrevReportTimestamp, 10)
        nextReportTimestampStr := strconv.FormatInt(snapshotData.NextReportTimestamp, 10)

        return &amp;types.QueryGetAttestationDataBySnapshotResponse{QueryId: queryIdStr, Timestamp: timestampStr, AggregateValue: aggValueStr, AggregatePower: aggPowerStr, Checkpoint: checkpointStr, AttestationTimestamp: attestationTimestampStr, PreviousReportTimestamp: previousReportTimestampStr, NextReportTimestamp: nextReportTimestampStr}, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package keeper

import (
        "context"
        "encoding/hex"
        "fmt"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/bridge/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Keeper) GetAttestationsBySnapshot(goCtx context.Context, req *types.QueryGetAttestationsBySnapshotRequest) (*types.QueryGetAttestationsBySnapshotResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>
        <span class="cov0" title="0">snapshot := req.Snapshot

        ctx := sdk.UnwrapSDKContext(goCtx)

        attestations, err := k.SnapshotToAttestationsMap.Get(ctx, snapshot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("attestations not found for snapshot %s", snapshot))
        }</span>

        <span class="cov0" title="0">var attestationStringArray []string
        for _, attestation := range attestations.Attestations </span><span class="cov0" title="0">{
                attestationStringArray = append(attestationStringArray, hex.EncodeToString(attestation))
        }</span>

        <span class="cov0" title="0">return &amp;types.QueryGetAttestationsBySnapshotResponse{Attestations: attestationStringArray}, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package keeper

import (
        "context"
        "encoding/hex"

        "github.com/tellor-io/layer/x/bridge/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Keeper) GetCurrentAggregateReport(ctx context.Context, req *types.QueryGetCurrentAggregateReportRequest) (*types.QueryGetCurrentAggregateReportResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov0" title="0">queryId, err := hex.DecodeString(req.QueryId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid query id")
        }</span>
        <span class="cov0" title="0">aggregate, timestamp := k.oracleKeeper.GetCurrentAggregateReport(ctx, queryId)
        if aggregate == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.NotFound, "aggregate not found")
        }</span>
        <span class="cov0" title="0">timeUnix := timestamp.Unix()

        // convert oracletypes.Reporters to bridgetypes.Reporters
        convertedReporters := make([]*types.AggregateReporter, len(aggregate.Reporters))
        for i, reporter := range aggregate.Reporters </span><span class="cov0" title="0">{
                convertedReporters[i] = &amp;types.AggregateReporter{
                        Reporter: reporter.Reporter,
                        Power:    reporter.Power,
                }
        }</span>

        // convert oracletypes.Aggregate to bridgetypes.Aggregate
        <span class="cov0" title="0">bridgeAggregate := types.Aggregate{
                QueryId:              aggregate.QueryId,
                AggregateValue:       aggregate.AggregateValue,
                AggregateReporter:    aggregate.AggregateReporter,
                ReporterPower:        aggregate.ReporterPower,
                StandardDeviation:    aggregate.StandardDeviation,
                Reporters:            convertedReporters,
                Flagged:              aggregate.Flagged,
                Nonce:                int64(aggregate.Nonce),
                AggregateReportIndex: aggregate.AggregateReportIndex,
                Height:               aggregate.Height,
        }

        return &amp;types.QueryGetCurrentAggregateReportResponse{
                Aggregate: &amp;bridgeAggregate,
                Timestamp: uint64(timeUnix),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package keeper

import (
        "context"
        "time"

        "github.com/tellor-io/layer/x/bridge/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Keeper) GetDataBefore(ctx context.Context, req *types.QueryGetDataBeforeRequest) (*types.QueryGetDataBeforeResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov0" title="0">aggregate, timestamp, err := k.oracleKeeper.GetAggregateBefore(ctx, req.QueryId, time.Unix(req.Timestamp, 0))
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "failed to get aggregate before")
        }</span>
        <span class="cov0" title="0">if aggregate == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.NotFound, "aggregate before not found")
        }</span>
        <span class="cov0" title="0">timeUnix := timestamp.Unix()

        return &amp;types.QueryGetDataBeforeResponse{
                Aggregate: aggregate,
                Timestamp: uint64(timeUnix),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package keeper

import (
        "context"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/bridge/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Keeper) GetEvmAddressByValidatorAddress(goCtx context.Context, req *types.QueryGetEvmAddressByValidatorAddressRequest) (*types.QueryGetEvmAddressByValidatorAddressResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov0" title="0">ctx := sdk.UnwrapSDKContext(goCtx)

        ethAddress, err := k.GetEVMAddressByOperator(ctx, req.ValidatorAddress)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "failed to get eth address")
        }</span>

        <span class="cov0" title="0">return &amp;types.QueryGetEvmAddressByValidatorAddressResponse{EvmAddress: ethAddress}, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package keeper

import (
        "context"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/bridge/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Keeper) GetEvmValidators(goCtx context.Context, req *types.QueryGetEvmValidatorsRequest) (*types.QueryGetEvmValidatorsResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov0" title="0">ctx := sdk.UnwrapSDKContext(goCtx)

        ethAddresses, err := k.GetCurrentValidatorsEVMCompatible(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "failed to get current validators")
        }</span>
        <span class="cov0" title="0">ethAddressesStr := make([]string, len(ethAddresses))
        for i, ethAddresses := range ethAddresses </span><span class="cov0" title="0">{
                ethAddressesStr[i] = ethAddresses.EthereumAddress
        }</span>

        <span class="cov0" title="0">return &amp;types.QueryGetEvmValidatorsResponse{BridgeValidatorSet: ethAddresses}, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package keeper

import (
        "context"
        "encoding/hex"
        "fmt"
        "strconv"
        "time"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/ethereum/go-ethereum/crypto"
        "github.com/tellor-io/layer/x/bridge/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Keeper) GetSnapshotsByReport(goCtx context.Context, req *types.QueryGetSnapshotsByReportRequest) (*types.QueryGetSnapshotsByReportResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>
        <span class="cov0" title="0">queryIdStr := req.QueryId
        timestampStr := req.Timestamp
        queryIdBytes, err := hex.DecodeString(queryIdStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("invalid queryId %s", queryIdStr))
        }</span>
        <span class="cov0" title="0">timestampInt, err := strconv.ParseInt(timestampStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("invalid timestamp %s", timestampStr))
        }</span>
        <span class="cov0" title="0">timestampTime := time.Unix(timestampInt, 0)

        ctx := sdk.UnwrapSDKContext(goCtx)
        key := hex.EncodeToString(crypto.Keccak256([]byte(hex.EncodeToString(queryIdBytes) + fmt.Sprint(timestampTime.Unix()))))
        // key := hex.EncodeToString(crypto.Keccak256([]byte(queryId + timestamp)))
        snapshots, err := k.AttestSnapshotsByReportMap.Get(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("snapshots not found for queryId %s and timestamp %s", queryIdStr, timestampStr))
        }</span>

        <span class="cov0" title="0">var snapshotStringArray []string
        for _, snapshot := range snapshots.Snapshots </span><span class="cov0" title="0">{
                snapshotStringArray = append(snapshotStringArray, hex.EncodeToString(snapshot))
        }</span>

        <span class="cov0" title="0">return &amp;types.QueryGetSnapshotsByReportResponse{Snapshots: snapshotStringArray}, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package keeper

import (
        "context"
        "encoding/hex"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/bridge/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Keeper) GetValidatorCheckpoint(goCtx context.Context, req *types.QueryGetValidatorCheckpointRequest) (*types.QueryGetValidatorCheckpointResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov0" title="0">ctx := sdk.UnwrapSDKContext(goCtx)

        checkpoint, err := k.GetValidatorCheckpointFromStorage(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "failed to get validator checkpoint")
        }</span>

        <span class="cov0" title="0">checkpointHexString := hex.EncodeToString(checkpoint.Checkpoint)

        return &amp;types.QueryGetValidatorCheckpointResponse{ValidatorCheckpoint: checkpointHexString}, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package keeper

import (
        "context"
        "encoding/hex"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/bridge/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Keeper) GetValidatorCheckpointParams(goCtx context.Context, req *types.QueryGetValidatorCheckpointParamsRequest) (*types.QueryGetValidatorCheckpointParamsResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov0" title="0">ctx := sdk.UnwrapSDKContext(goCtx)

        checkpointParams, err := k.GetValidatorCheckpointParamsFromStorage(ctx, uint64(req.Timestamp))
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "failed to get validator checkpoint params")
        }</span>

        <span class="cov0" title="0">checkpointHexString := hex.EncodeToString(checkpointParams.Checkpoint)
        valsetHashString := hex.EncodeToString(checkpointParams.ValsetHash)

        return &amp;types.QueryGetValidatorCheckpointParamsResponse{
                Checkpoint:     checkpointHexString,
                ValsetHash:     valsetHashString,
                Timestamp:      checkpointParams.Timestamp,
                PowerThreshold: checkpointParams.PowerThreshold,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package keeper

import (
        "context"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/bridge/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Keeper) GetValidatorTimestampByIndex(goCtx context.Context, req *types.QueryGetValidatorTimestampByIndexRequest) (*types.QueryGetValidatorTimestampByIndexResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov0" title="0">ctx := sdk.UnwrapSDKContext(goCtx)

        validatorTimestamp, err := k.GetValidatorTimestampByIdxFromStorage(ctx, uint64(req.Index))
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "failed to get validator timestamp by index")
        }</span>

        <span class="cov0" title="0">return &amp;types.QueryGetValidatorTimestampByIndexResponse{
                Timestamp: int64(validatorTimestamp.Timestamp),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package keeper

import (
        "context"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/bridge/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Keeper) GetValsetByTimestamp(goCtx context.Context, req *types.QueryGetValsetByTimestampRequest) (*types.QueryGetValsetByTimestampResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov0" title="0">ctx := sdk.UnwrapSDKContext(goCtx)

        valset, err := k.GetBridgeValsetByTimestamp(ctx, uint64(req.Timestamp))
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "failed to get eth address")
        }</span>

        <span class="cov0" title="0">valsetArray := make([]*types.BridgeValidator, len(valset.BridgeValidatorSet))
        for i, val := range valset.BridgeValidatorSet </span><span class="cov0" title="0">{
                valsetArray[i] = &amp;types.BridgeValidator{
                        EthereumAddress: val.EthereumAddress,
                        Power:           val.Power,
                }
        }</span>

        <span class="cov0" title="0">return &amp;types.QueryGetValsetByTimestampResponse{BridgeValidatorSet: valsetArray}, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package keeper

import (
        "context"
        "encoding/hex"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/bridge/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Keeper) GetValsetSigs(goCtx context.Context, req *types.QueryGetValsetSigsRequest) (*types.QueryGetValsetSigsResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov0" title="0">ctx := sdk.UnwrapSDKContext(goCtx)

        sigs, err := k.GetValidatorSetSignaturesFromStorage(ctx, uint64(req.Timestamp))
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "failed to get validator signatures")
        }</span>

        // iterate through sigs and convert to hex + '0x'
        <span class="cov0" title="0">sigsHex := make([]string, len(sigs.Signatures))
        for i, sig := range sigs.Signatures </span><span class="cov0" title="0">{
                sigsHex[i] = "0x" + hex.EncodeToString(sig)
        }</span>

        <span class="cov0" title="0">return &amp;types.QueryGetValsetSigsResponse{
                Signatures: sigsHex,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package keeper

import (
        "context"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/bridge/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Querier) Params(goCtx context.Context, req *types.QueryParamsRequest) (*types.QueryParamsResponse, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>
        <span class="cov8" title="1">ctx := sdk.UnwrapSDKContext(goCtx)

        return &amp;types.QueryParamsResponse{Params: k.GetParams(ctx)}, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package bridge

import (
        "context"
        "encoding/json"
        "fmt"

        // this line is used by starport scaffolding # 1

        "github.com/grpc-ecosystem/grpc-gateway/runtime"
        "github.com/spf13/cobra"

        abci "github.com/cometbft/cometbft/abci/types"

        "cosmossdk.io/core/appmodule"
        "github.com/cosmos/cosmos-sdk/client"
        "github.com/cosmos/cosmos-sdk/codec"
        cdctypes "github.com/cosmos/cosmos-sdk/codec/types"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/module"
        "github.com/tellor-io/layer/x/bridge/client/cli"
        "github.com/tellor-io/layer/x/bridge/keeper"
        "github.com/tellor-io/layer/x/bridge/types"
)

var (
        _ appmodule.AppModule     = AppModule{}
        _ module.AppModuleBasic   = AppModuleBasic{}
        _ appmodule.HasEndBlocker = AppModule{}
)

// ----------------------------------------------------------------------------
// AppModuleBasic
// ----------------------------------------------------------------------------

// AppModuleBasic implements the AppModuleBasic interface that defines the independent methods a Cosmos SDK module needs to implement.
type AppModuleBasic struct {
        cdc codec.BinaryCodec
}

func NewAppModuleBasic(cdc codec.BinaryCodec) AppModuleBasic <span class="cov0" title="0">{
        return AppModuleBasic{cdc: cdc}
}</span>

// Name returns the name of the module as a string
func (AppModuleBasic) Name() string <span class="cov0" title="0">{
        return types.ModuleName
}</span>

// RegisterLegacyAminoCodec registers the amino codec for the module, which is used to marshal and unmarshal structs to/from []byte in order to persist them in the module's KVStore
func (AppModuleBasic) RegisterLegacyAminoCodec(cdc *codec.LegacyAmino) <span class="cov0" title="0">{
        types.RegisterCodec(cdc)
}</span>

// RegisterInterfaces registers a module's interface types and their concrete implementations as proto.Message
func (a AppModuleBasic) RegisterInterfaces(reg cdctypes.InterfaceRegistry) <span class="cov0" title="0">{
        types.RegisterInterfaces(reg)
}</span>

// DefaultGenesis returns a default GenesisState for the module, marshalled to json.RawMessage. The default GenesisState need to be defined by the module developer and is primarily used for testing
func (AppModuleBasic) DefaultGenesis(cdc codec.JSONCodec) json.RawMessage <span class="cov0" title="0">{
        return cdc.MustMarshalJSON(types.DefaultGenesis())
}</span>

// ValidateGenesis used to validate the GenesisState, given in its json.RawMessage form
func (AppModuleBasic) ValidateGenesis(cdc codec.JSONCodec, config client.TxEncodingConfig, bz json.RawMessage) error <span class="cov0" title="0">{
        var genState types.GenesisState
        if err := cdc.UnmarshalJSON(bz, &amp;genState); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal %s genesis state: %w", types.ModuleName, err)
        }</span>
        <span class="cov0" title="0">return genState.Validate()</span>
}

// RegisterGRPCGatewayRoutes registers the gRPC Gateway routes for the module
func (AppModuleBasic) RegisterGRPCGatewayRoutes(clientCtx client.Context, mux *runtime.ServeMux) <span class="cov0" title="0">{
        types.RegisterQueryHandlerClient(context.Background(), mux, types.NewQueryClient(clientCtx))
}</span>

// GetTxCmd returns the root Tx command for the module. The subcommands of this root command are used by end-users to generate new transactions containing messages defined in the module
func (a AppModuleBasic) GetTxCmd() *cobra.Command <span class="cov0" title="0">{
        return cli.GetTxCmd()
}</span>

// GetQueryCmd returns the root query command for the module. The subcommands of this root command are used by end-users to generate new queries to the subset of the state defined by the module
func (AppModuleBasic) GetQueryCmd() *cobra.Command <span class="cov0" title="0">{
        return cli.GetQueryCmd(types.StoreKey)
}</span>

// ----------------------------------------------------------------------------
// AppModule
// ----------------------------------------------------------------------------

// AppModule implements the AppModule interface that defines the inter-dependent methods that modules need to implement
type AppModule struct {
        AppModuleBasic

        keeper        keeper.Keeper
        accountKeeper types.AccountKeeper
        bankKeeper    types.BankKeeper
}

// IsAppModule implements appmodule.AppModule.
func (AppModule) IsAppModule() {<span class="cov0" title="0">}</span>

// IsOnePerModuleType implements appmodule.AppModule.
func (AppModule) IsOnePerModuleType() {<span class="cov0" title="0">}</span>

func NewAppModule(
        cdc codec.Codec,
        keeper keeper.Keeper,
        accountKeeper types.AccountKeeper,
        bankKeeper types.BankKeeper,
) AppModule <span class="cov0" title="0">{
        return AppModule{
                AppModuleBasic: NewAppModuleBasic(cdc),
                keeper:         keeper,
                accountKeeper:  accountKeeper,
                bankKeeper:     bankKeeper,
        }
}</span>

// RegisterServices registers a gRPC query service to respond to the module-specific gRPC queries
func (am AppModule) RegisterServices(cfg module.Configurator) <span class="cov0" title="0">{
        types.RegisterMsgServer(cfg.MsgServer(), keeper.NewMsgServerImpl(am.keeper))
        types.RegisterQueryServer(cfg.QueryServer(), keeper.NewQuerier(am.keeper))
}</span>

// RegisterInvariants registers the invariants of the module. If an invariant deviates from its predicted value, the InvariantRegistry triggers appropriate logic (most often the chain will be halted)
func (am AppModule) RegisterInvariants(_ sdk.InvariantRegistry) {<span class="cov0" title="0">}</span>

// InitGenesis performs the module's genesis initialization. It returns no validator updates.
func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, gs json.RawMessage) []abci.ValidatorUpdate <span class="cov0" title="0">{
        var genState types.GenesisState
        // Initialize global index to index in genesis state
        cdc.MustUnmarshalJSON(gs, &amp;genState)

        InitGenesis(ctx, am.keeper, genState)

        return []abci.ValidatorUpdate{}
}</span>

// ExportGenesis returns the module's exported genesis state as raw JSON bytes.
func (am AppModule) ExportGenesis(ctx sdk.Context, cdc codec.JSONCodec) json.RawMessage <span class="cov0" title="0">{
        genState := ExportGenesis(ctx, am.keeper)
        return cdc.MustMarshalJSON(genState)
}</span>

// ConsensusVersion is a sequence number for state-breaking change of the module. It should be incremented on each consensus-breaking change introduced by the module. To avoid wrong/empty versions, the initial version should be set to 1
func (AppModule) ConsensusVersion() uint64 <span class="cov0" title="0">{ return 1 }</span>

// EndBlock contains the logic that is automatically triggered at the end of each block
func (am AppModule) EndBlock(ctx context.Context) error <span class="cov0" title="0">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)
        am.keeper.CompareBridgeValidators(sdkCtx)
        am.keeper.CreateNewReportSnapshots(sdkCtx)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package bridge

import (
        "math/rand"

        "github.com/cosmos/cosmos-sdk/baseapp"
        "github.com/cosmos/cosmos-sdk/types/module"
        simtypes "github.com/cosmos/cosmos-sdk/types/simulation"
        "github.com/cosmos/cosmos-sdk/x/simulation"
        "github.com/tellor-io/layer/testutil/sample"
        bridgesimulation "github.com/tellor-io/layer/x/bridge/simulation"
        "github.com/tellor-io/layer/x/bridge/types"
)

// avoid unused import issue
var (
        _ = sample.AccAddress
        _ = bridgesimulation.FindAccount
        _ = simulation.MsgEntryKind
        _ = baseapp.Paramspace
        _ = rand.Rand{}
)

const (
// this line is used by starport scaffolding # simapp/module/const
)

// GenerateGenesisState creates a randomized GenState of the module.
func (AppModule) GenerateGenesisState(simState *module.SimulationState) <span class="cov0" title="0">{
        accs := make([]string, len(simState.Accounts))
        for i, acc := range simState.Accounts </span><span class="cov0" title="0">{
                accs[i] = acc.Address.String()
        }</span>
        <span class="cov0" title="0">bridgeGenesis := types.GenesisState{
                Params: types.DefaultParams(),
                // this line is used by starport scaffolding # simapp/module/genesisState
        }
        simState.GenState[types.ModuleName] = simState.Cdc.MustMarshalJSON(&amp;bridgeGenesis)</span>
}

// RegisterStoreDecoder registers a decoder.
func (am AppModule) RegisterStoreDecoder(_ simtypes.StoreDecoderRegistry) {<span class="cov0" title="0">}</span>

// ProposalContents doesn't return any content functions for governance proposals.
func (AppModule) ProposalContents(_ module.SimulationState) []simtypes.WeightedProposalContent <span class="cov0" title="0">{
        return nil
}</span>

// WeightedOperations returns the all the gov module operations with their respective weights.
func (am AppModule) WeightedOperations(simState module.SimulationState) []simtypes.WeightedOperation <span class="cov0" title="0">{
        operations := make([]simtypes.WeightedOperation, 0)

        // this line is used by starport scaffolding # simapp/module/operation

        return operations
}</span>

// ProposalMsgs returns msgs used for governance proposals for simulations.
func (am AppModule) ProposalMsgs(simState module.SimulationState) []simtypes.WeightedProposalMsg <span class="cov0" title="0">{
        return []simtypes.WeightedProposalMsg{
                // this line is used by starport scaffolding # simapp/module/OpMsg
        }
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package types

import (
        "github.com/gogo/protobuf/proto"
)

type AttestationRequest struct {
        Snapshot []byte `protobuf:"bytes,1,opt,name=snapshot,proto3"`
}

// AttestationRequests holds requests for attestations.
type AttestationRequests struct {
        Requests []*AttestationRequest `protobuf:"bytes,1,rep,name=requests,proto3"`
}

// AddRequest adds a request for an attestation to the list of requests.
// `request` is the request for an attestation.
func (b *AttestationRequests) AddRequest(request *AttestationRequest) <span class="cov0" title="0">{
        b.Requests = append(b.Requests, request)
}</span>

// Ensure OracleAttestations implements proto.Message
var _ proto.Message = &amp;AttestationRequests{}

// ProtoMessage is a no-op method to satisfy the proto.Message interface
func (*AttestationRequests) ProtoMessage() {<span class="cov0" title="0">}</span>

// Reset is a no-op method to satisfy the proto.Message interface
func (*AttestationRequests) Reset() {<span class="cov0" title="0">}</span>

// String returns a string representation, satisfying the proto.Message interface
func (m *AttestationRequests) String() string <span class="cov0" title="0">{
        return proto.CompactTextString(m)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package types

import (
        "github.com/gogo/protobuf/proto"
)

// AttestationSnapshots holds the snapshots of attestations.
// Each attestation's snapshots are stored in a slice of bytes.
type AttestationSnapshotData struct {
        ValidatorCheckpoint  []byte `protobuf:"bytes,1,rep,name=validator_checkpoint,proto3"`
        AttestationTimestamp int64  `protobuf:"varint,2,rep,name=attestation_timestamp,proto3"`
        PrevReportTimestamp  int64  `protobuf:"varint,3,rep,name=prev_report_timestamp,proto3"`
        NextReportTimestamp  int64  `protobuf:"varint,4,rep,name=next_report_timestamp,proto3"`
        QueryId              []byte `protobuf:"bytes,5,rep,name=query_id,proto3"`
        Timestamp            int64  `protobuf:"varint,6,rep,name=timestamp,proto3"`
}

// Ensure AttestationSnapshotData implements proto.Message
var _ proto.Message = &amp;AttestationSnapshotData{}

// ProtoMessage is a no-op method to satisfy the proto.Message interface
func (*AttestationSnapshotData) ProtoMessage() {<span class="cov0" title="0">}</span>

// Reset is a no-op method to satisfy the proto.Message interface
func (*AttestationSnapshotData) Reset() {<span class="cov0" title="0">}</span>

// String returns a string representation, satisfying the proto.Message interface
func (m *AttestationSnapshotData) String() string <span class="cov0" title="0">{
        return proto.CompactTextString(m)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package types

import (
        "github.com/gogo/protobuf/proto"
)

// AttestationSnapshots holds the snapshots of attestations.
// Each attestation's snapshots are stored in a slice of bytes.
type AttestationSnapshots struct {
        Snapshots [][]byte `protobuf:"bytes,1,rep,name=snapshots,proto3"`
}

// NewAttestationSnapshots initializes a AttestationSnapshots with a given size.
func NewAttestationSnapshots() *AttestationSnapshots <span class="cov0" title="0">{
        snapshots := make([][]byte, 0) // Initialize with empty slice, adjust according to needs
        return &amp;AttestationSnapshots{Snapshots: snapshots}
}</span>

// SetSnapshot appends an attestation snapshot to the list of snapshots for a given aggregate report.
// `snapshot` is the attestation's snapshot.
func (b *AttestationSnapshots) SetSnapshot(snapshot []byte) <span class="cov0" title="0">{
        b.Snapshots = append(b.Snapshots, snapshot)
}</span>

// Ensure AttestationSnapshots implements proto.Message
var _ proto.Message = &amp;AttestationSnapshots{}

// ProtoMessage is a no-op method to satisfy the proto.Message interface
func (*AttestationSnapshots) ProtoMessage() {<span class="cov0" title="0">}</span>

// Reset is a no-op method to satisfy the proto.Message interface
func (*AttestationSnapshots) Reset() {<span class="cov0" title="0">}</span>

// String returns a string representation, satisfying the proto.Message interface
func (m *AttestationSnapshots) String() string <span class="cov0" title="0">{
        return proto.CompactTextString(m)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package types

import (
        "github.com/gogo/protobuf/proto"
)

// BridgeValsetSignatures holds the signatures of validators.
// Each validator's signatures are stored in a slice of bytes.
type BridgeValsetSignatures struct {
        Signatures [][]byte `protobuf:"bytes,1,rep,name=signatures,proto3"`
}

// NewBridgeValsetSignatures initializes a BridgeValsetSignatures with a given size.
func NewBridgeValsetSignatures(valsetSize int) *BridgeValsetSignatures <span class="cov0" title="0">{
        signatures := make([][]byte, valsetSize)
        for i := range signatures </span><span class="cov0" title="0">{
                signatures[i] = make([]byte, 0) // Initialize with empty slice, adjust according to needs
        }</span>
        <span class="cov0" title="0">return &amp;BridgeValsetSignatures{Signatures: signatures}</span>
}

// SetSignature sets a signature for a validator at the given index.
// `validatorIndex` is the position of the validator in the bridge valset.
// `signature` is the validator's signature.
// Note: Ensure `validatorIndex` is within bounds before calling this method.
func (b *BridgeValsetSignatures) SetSignature(validatorIndex int, signature []byte) <span class="cov0" title="0">{
        if validatorIndex &gt;= 0 &amp;&amp; validatorIndex &lt; len(b.Signatures) </span><span class="cov0" title="0">{
                b.Signatures[validatorIndex] = signature
        }</span>
}

// Ensure BridgeValsetSignatures implements proto.Message
var _ proto.Message = &amp;BridgeValsetSignatures{}

// ProtoMessage is a no-op method to satisfy the proto.Message interface
func (*BridgeValsetSignatures) ProtoMessage() {<span class="cov0" title="0">}</span>

// Reset is a no-op method to satisfy the proto.Message interface
func (*BridgeValsetSignatures) Reset() {<span class="cov0" title="0">}</span>

// String returns a string representation, satisfying the proto.Message interface
func (m *BridgeValsetSignatures) String() string <span class="cov0" title="0">{
        return proto.CompactTextString(m)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package types

import (
        "github.com/gogo/protobuf/proto"
)

// CheckpointIdx wraps a uint64 to be used with the codec
type CheckpointIdx struct {
        Index uint64 `protobuf:"varint,1,opt,name=index,proto3"`
}

// Ensure CheckpointIdx implements proto.Message
var _ proto.Message = &amp;CheckpointIdx{}

// ProtoMessage is a no-op method to satisfy the proto.Message interface
func (*CheckpointIdx) ProtoMessage() {<span class="cov0" title="0">}</span>

// Reset is a no-op method to satisfy the proto.Message interface
func (*CheckpointIdx) Reset() {<span class="cov0" title="0">}</span>

// String returns a string representation, satisfying the proto.Message interface
func (m *CheckpointIdx) String() string <span class="cov0" title="0">{
        return proto.CompactTextString(m)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package types

import (
        "github.com/gogo/protobuf/proto"
)

// CheckpointTimestamp wraps a uint64 to be used with the codec
type CheckpointTimestamp struct {
        Timestamp uint64 `protobuf:"varint,1,opt,name=timestamp,proto3"`
}

// Ensure CheckpointTimestamp implements proto.Message
var _ proto.Message = &amp;CheckpointTimestamp{}

// ProtoMessage is a no-op method to satisfy the proto.Message interface
func (*CheckpointTimestamp) ProtoMessage() {<span class="cov0" title="0">}</span>

// Reset is a no-op method to satisfy the proto.Message interface
func (*CheckpointTimestamp) Reset() {<span class="cov0" title="0">}</span>

// String returns a string representation, satisfying the proto.Message interface
func (m *CheckpointTimestamp) String() string <span class="cov0" title="0">{
        return proto.CompactTextString(m)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package types

import (
        "github.com/cosmos/cosmos-sdk/codec"
        cdctypes "github.com/cosmos/cosmos-sdk/codec/types"
        // this line is used by starport scaffolding # 1
        "github.com/cosmos/cosmos-sdk/types/msgservice"
)

func RegisterCodec(cdc *codec.LegacyAmino) {<span class="cov0" title="0">
        // this line is used by starport scaffolding # 2
}</span>

func RegisterInterfaces(registry cdctypes.InterfaceRegistry) <span class="cov0" title="0">{
        // this line is used by starport scaffolding # 3

        msgservice.RegisterMsgServiceDesc(registry, &amp;_Msg_serviceDesc)
}</span>

var (
        Amino     = codec.NewLegacyAmino()
        ModuleCdc = codec.NewProtoCodec(cdctypes.NewInterfaceRegistry())
)
</pre>
		
		<pre class="file" id="file28" style="display: none">package types

import (
        "github.com/gogo/protobuf/proto"
)

// EVMAddress wraps a [32]byte to be used with the codec
type EVMAddress struct {
        EVMAddress []byte `protobuf:"bytes,1,opt,name=evm_address,proto3,casttype=[32]byte"`
}

// Ensure EVMAddress implements proto.Message
var _ proto.Message = &amp;EVMAddress{}

// ProtoMessage is a no-op method to satisfy the proto.Message interface
func (*EVMAddress) ProtoMessage() {<span class="cov0" title="0">}</span>

// Reset is a no-op method to satisfy the proto.Message interface
func (*EVMAddress) Reset() {<span class="cov0" title="0">}</span>

// String returns a string representation, satisfying the proto.Message interface
func (m *EVMAddress) String() string <span class="cov0" title="0">{
        return proto.CompactTextString(m)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package types

import (
// this line is used by starport scaffolding # genesis/types/import
)

// DefaultIndex is the default global index
const DefaultIndex uint64 = 1

// DefaultGenesis returns the default genesis state
func DefaultGenesis() *GenesisState <span class="cov8" title="1">{
        return &amp;GenesisState{
                // this line is used by starport scaffolding # genesis/types/default
                Params: DefaultParams(),
        }
}</span>

// Validate performs basic genesis state validation returning an error upon any
// failure.
func (gs GenesisState) Validate() error <span class="cov8" title="1">{
        // this line is used by starport scaffolding # genesis/types/validate

        return gs.Params.Validate()
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/bridge/genesis.proto

package types

import (
        fmt "fmt"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GenesisState defines the bridge module's genesis state.
type GenesisState struct {
        Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
}

func (m *GenesisState) Reset()         <span class="cov0" title="0">{ *m = GenesisState{} }</span>
func (m *GenesisState) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GenesisState) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GenesisState) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_233d9732da3f6137, []int{0}
}</span>
func (m *GenesisState) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *GenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_GenesisState.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *GenesisState) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GenesisState.Merge(m, src)
}</span>
func (m *GenesisState) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *GenesisState) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GenesisState.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GenesisState proto.InternalMessageInfo

func (m *GenesisState) GetParams() Params <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Params
        }</span>
        <span class="cov0" title="0">return Params{}</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*GenesisState)(nil), "layer.bridge.GenesisState")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/bridge/genesis.proto", fileDescriptor_233d9732da3f6137) }</span>

var fileDescriptor_233d9732da3f6137 = []byte{
        // 191 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0xca, 0x49, 0xac, 0x4c,
        0x2d, 0xd2, 0x4f, 0x2a, 0xca, 0x4c, 0x49, 0x4f, 0xd5, 0x4f, 0x4f, 0xcd, 0x4b, 0x2d, 0xce, 0x2c,
        0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x01, 0xcb, 0xe9, 0x41, 0xe4, 0xa4, 0x44, 0xd2,
        0xf3, 0xd3, 0xf3, 0xc1, 0x12, 0xfa, 0x20, 0x16, 0x44, 0x8d, 0x94, 0x24, 0x8a, 0xfe, 0x82, 0xc4,
        0xa2, 0xc4, 0x5c, 0xa8, 0x76, 0x25, 0x27, 0x2e, 0x1e, 0x77, 0x88, 0x79, 0xc1, 0x25, 0x89, 0x25,
        0xa9, 0x42, 0x46, 0x5c, 0x6c, 0x10, 0x79, 0x09, 0x46, 0x05, 0x46, 0x0d, 0x6e, 0x23, 0x11, 0x3d,
        0x64, 0xf3, 0xf5, 0x02, 0xc0, 0x72, 0x4e, 0x2c, 0x27, 0xee, 0xc9, 0x33, 0x04, 0x41, 0x55, 0x3a,
        0x39, 0x9f, 0x78, 0x24, 0xc7, 0x78, 0xe1, 0x91, 0x1c, 0xe3, 0x83, 0x47, 0x72, 0x8c, 0x13, 0x1e,
        0xcb, 0x31, 0x5c, 0x78, 0x2c, 0xc7, 0x70, 0xe3, 0xb1, 0x1c, 0x43, 0x94, 0x66, 0x7a, 0x66, 0x49,
        0x46, 0x69, 0x92, 0x5e, 0x72, 0x7e, 0xae, 0x7e, 0x49, 0x6a, 0x4e, 0x4e, 0x7e, 0x91, 0x6e, 0x66,
        0xbe, 0x3e, 0xc4, 0x35, 0x15, 0x30, 0xf7, 0x94, 0x54, 0x16, 0xa4, 0x16, 0x27, 0xb1, 0x81, 0xdd,
        0x63, 0x0c, 0x08, 0x00, 0x00, 0xff, 0xff, 0x33, 0x08, 0x8e, 0x0e, 0xec, 0x00, 0x00, 0x00,
}

func (m *GenesisState) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *GenesisState) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *GenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintGenesis(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func encodeVarintGenesis(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovGenesis(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *GenesisState) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Params.Size()
        n += 1 + l + sovGenesis(uint64(l))
        return n</span>
}

func sovGenesis(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozGenesis(x uint64) (n int) <span class="cov0" title="0">{
        return sovGenesis(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *GenesisState) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowGenesis
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipGenesis(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipGenesis(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowGenesis
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupGenesis
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthGenesis
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthGenesis        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowGenesis          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupGenesis = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file31" style="display: none">package types

import (
        errorsmod "cosmossdk.io/errors"
        sdk "github.com/cosmos/cosmos-sdk/types"
        sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
)

const TypeMsgRequestAttestations = "request_attestations"

var _ sdk.Msg = &amp;MsgRequestAttestations{}

func NewMsgRequestAttestations(creator string, queryId string, timestamp string) *MsgRequestAttestations <span class="cov0" title="0">{
        return &amp;MsgRequestAttestations{
                Creator:   creator,
                QueryId:   queryId,
                Timestamp: timestamp,
        }
}</span>

func (msg *MsgRequestAttestations) Route() string <span class="cov0" title="0">{
        return RouterKey
}</span>

func (msg *MsgRequestAttestations) Type() string <span class="cov0" title="0">{
        return TypeMsgRequestAttestations
}</span>

func (msg *MsgRequestAttestations) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        creator, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return []sdk.AccAddress{creator}</span>
}

func (msg *MsgRequestAttestations) GetSignBytes() []byte <span class="cov0" title="0">{
        bz := ModuleCdc.MustMarshalJSON(msg)
        return sdk.MustSortJSON(bz)
}</span>

func (msg *MsgRequestAttestations) ValidateBasic() error <span class="cov0" title="0">{
        _, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov0" title="0">{
                return errorsmod.Wrapf(sdkerrors.ErrInvalidAddress, "invalid creator address (%s)", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package types

import (
        "github.com/gogo/protobuf/proto"
)

// OperatorAddress wraps a [32]byte to be used with the codec
type OperatorAddress struct {
        OperatorAddress []byte `protobuf:"bytes,1,opt,name=operator_address,proto3,casttype=[32]byte"`
}

// Ensure OperatorAddress implements proto.Message
var _ proto.Message = &amp;OperatorAddress{}

// ProtoMessage is a no-op method to satisfy the proto.Message interface
func (*OperatorAddress) ProtoMessage() {<span class="cov0" title="0">}</span>

// Reset is a no-op method to satisfy the proto.Message interface
func (*OperatorAddress) Reset() {<span class="cov0" title="0">}</span>

// String returns a string representation, satisfying the proto.Message interface
func (m *OperatorAddress) String() string <span class="cov0" title="0">{
        return proto.CompactTextString(m)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package types

import (
        "github.com/gogo/protobuf/proto"
)

// OracleAttestations holds the attestations of validators.
// Each validator's attestations are stored in a slice of bytes.
type OracleAttestations struct {
        Attestations [][]byte `protobuf:"bytes,1,rep,name=attestations,proto3"`
}

// NewOracleAttestations initializes a OracleAttestations with a given size.
func NewOracleAttestations(valsetSize int) *OracleAttestations <span class="cov0" title="0">{
        attestations := make([][]byte, valsetSize)
        for i := range attestations </span><span class="cov0" title="0">{
                attestations[i] = make([]byte, 0) // Initialize with empty slice, adjust according to needs
        }</span>
        <span class="cov0" title="0">return &amp;OracleAttestations{Attestations: attestations}</span>
}

// SetAttestation sets an attestation for a validator at the given index.
// `validatorIndex` is the position of the validator in the bridge valset.
// `attestation` is the validator's signature.
// Note: Ensure `validatorIndex` is within bounds before calling this method.
func (b *OracleAttestations) SetAttestation(validatorIndex int, attestation []byte) <span class="cov0" title="0">{
        if validatorIndex &gt;= 0 &amp;&amp; validatorIndex &lt; len(b.Attestations) </span><span class="cov0" title="0">{
                b.Attestations[validatorIndex] = attestation
        }</span>
}

// Ensure OracleAttestations implements proto.Message
var _ proto.Message = &amp;OracleAttestations{}

// ProtoMessage is a no-op method to satisfy the proto.Message interface
func (*OracleAttestations) ProtoMessage() {<span class="cov0" title="0">}</span>

// Reset is a no-op method to satisfy the proto.Message interface
func (*OracleAttestations) Reset() {<span class="cov0" title="0">}</span>

// String returns a string representation, satisfying the proto.Message interface
func (m *OracleAttestations) String() string <span class="cov0" title="0">{
        return proto.CompactTextString(m)
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package types

import (
        paramtypes "github.com/cosmos/cosmos-sdk/x/params/types"
        "gopkg.in/yaml.v2"
)

var _ paramtypes.ParamSet = (*Params)(nil)

// ParamKeyTable the param key table for launch module
func ParamKeyTable() paramtypes.KeyTable <span class="cov0" title="0">{
        return paramtypes.NewKeyTable().RegisterParamSet(&amp;Params{})
}</span>

// NewParams creates a new Params instance
func NewParams() Params <span class="cov8" title="1">{
        return Params{}
}</span>

// DefaultParams returns a default set of parameters
func DefaultParams() Params <span class="cov8" title="1">{
        return NewParams()
}</span>

// ParamSetPairs get the params.ParamSet
func (p *Params) ParamSetPairs() paramtypes.ParamSetPairs <span class="cov0" title="0">{
        return paramtypes.ParamSetPairs{}
}</span>

// Validate validates the set of params
func (p Params) Validate() error <span class="cov8" title="1">{
        return nil
}</span>

// String implements the Stringer interface.
func (p Params) String() string <span class="cov0" title="0">{
        out, _ := yaml.Marshal(p)
        return string(out)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/bridge/params.proto

package types

import (
        fmt "fmt"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines the parameters for the module.
type Params struct {
}

func (m *Params) Reset()      <span class="cov0" title="0">{ *m = Params{} }</span>
func (*Params) ProtoMessage() {<span class="cov0" title="0">}</span>
func (*Params) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_f88be139eaafb360, []int{0}
}</span>
func (m *Params) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Params.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Params) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Params.Merge(m, src)
}</span>
func (m *Params) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Params) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Params.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Params proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Params)(nil), "layer.bridge.Params")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/bridge/params.proto", fileDescriptor_f88be139eaafb360) }</span>

var fileDescriptor_f88be139eaafb360 = []byte{
        // 150 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0xcc, 0x49, 0xac, 0x4c,
        0x2d, 0xd2, 0x4f, 0x2a, 0xca, 0x4c, 0x49, 0x4f, 0xd5, 0x2f, 0x48, 0x2c, 0x4a, 0xcc, 0x2d, 0xd6,
        0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x01, 0x4b, 0xe9, 0x41, 0xa4, 0xa4, 0x44, 0xd2, 0xf3,
        0xd3, 0xf3, 0xc1, 0x12, 0xfa, 0x20, 0x16, 0x44, 0x8d, 0x12, 0x1f, 0x17, 0x5b, 0x00, 0x58, 0x8f,
        0x15, 0xcb, 0x8c, 0x05, 0xf2, 0x0c, 0x4e, 0xce, 0x27, 0x1e, 0xc9, 0x31, 0x5e, 0x78, 0x24, 0xc7,
        0xf8, 0xe0, 0x91, 0x1c, 0xe3, 0x84, 0xc7, 0x72, 0x0c, 0x17, 0x1e, 0xcb, 0x31, 0xdc, 0x78, 0x2c,
        0xc7, 0x10, 0xa5, 0x99, 0x9e, 0x59, 0x92, 0x51, 0x9a, 0xa4, 0x97, 0x9c, 0x9f, 0xab, 0x5f, 0x92,
        0x9a, 0x93, 0x93, 0x5f, 0xa4, 0x9b, 0x99, 0xaf, 0x0f, 0xb1, 0xbd, 0x02, 0x66, 0x7f, 0x49, 0x65,
        0x41, 0x6a, 0x71, 0x12, 0x1b, 0xd8, 0x6c, 0x63, 0x40, 0x00, 0x00, 0x00, 0xff, 0xff, 0x14, 0xb6,
        0x31, 0xe7, 0x9c, 0x00, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func encodeVarintParams(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovParams(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Params) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func sovParams(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozParams(x uint64) (n int) <span class="cov0" title="0">{
        return sovParams(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Params) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Params: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipParams(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipParams(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupParams
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthParams
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthParams        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowParams          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupParams = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file36" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/bridge/query.proto

package types

import (
        context "context"
        encoding_binary "encoding/binary"
        fmt "fmt"
        _ "github.com/cosmos/cosmos-sdk/types/query"
        _ "github.com/cosmos/gogoproto/gogoproto"
        grpc1 "github.com/cosmos/gogoproto/grpc"
        proto "github.com/cosmos/gogoproto/proto"
        types "github.com/tellor-io/layer/x/oracle/types"
        _ "google.golang.org/genproto/googleapis/api/annotations"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QueryParamsRequest is request type for the Query/Params RPC method.
type QueryParamsRequest struct {
}

func (m *QueryParamsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryParamsRequest{} }</span>
func (m *QueryParamsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryParamsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryParamsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{0}
}</span>
func (m *QueryParamsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryParamsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryParamsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsRequest.Merge(m, src)
}</span>
func (m *QueryParamsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryParamsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryParamsRequest proto.InternalMessageInfo

// QueryParamsResponse is response type for the Query/Params RPC method.
type QueryParamsResponse struct {
        // params holds all the parameters of this module.
        Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
}

func (m *QueryParamsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryParamsResponse{} }</span>
func (m *QueryParamsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryParamsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryParamsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{1}
}</span>
func (m *QueryParamsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryParamsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryParamsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsResponse.Merge(m, src)
}</span>
func (m *QueryParamsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryParamsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryParamsResponse proto.InternalMessageInfo

func (m *QueryParamsResponse) GetParams() Params <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Params
        }</span>
        <span class="cov0" title="0">return Params{}</span>
}

type QueryGetEvmValidatorsRequest struct {
}

func (m *QueryGetEvmValidatorsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryGetEvmValidatorsRequest{} }</span>
func (m *QueryGetEvmValidatorsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetEvmValidatorsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetEvmValidatorsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{2}
}</span>
func (m *QueryGetEvmValidatorsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetEvmValidatorsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetEvmValidatorsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetEvmValidatorsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetEvmValidatorsRequest.Merge(m, src)
}</span>
func (m *QueryGetEvmValidatorsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetEvmValidatorsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetEvmValidatorsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetEvmValidatorsRequest proto.InternalMessageInfo

type QueryGetEvmValidatorsResponse struct {
        BridgeValidatorSet []*BridgeValidator `protobuf:"bytes,1,rep,name=bridgeValidatorSet,proto3" json:"bridgeValidatorSet,omitempty"`
}

func (m *QueryGetEvmValidatorsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryGetEvmValidatorsResponse{} }</span>
func (m *QueryGetEvmValidatorsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetEvmValidatorsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetEvmValidatorsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{3}
}</span>
func (m *QueryGetEvmValidatorsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetEvmValidatorsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetEvmValidatorsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetEvmValidatorsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetEvmValidatorsResponse.Merge(m, src)
}</span>
func (m *QueryGetEvmValidatorsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetEvmValidatorsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetEvmValidatorsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetEvmValidatorsResponse proto.InternalMessageInfo

func (m *QueryGetEvmValidatorsResponse) GetBridgeValidatorSet() []*BridgeValidator <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BridgeValidatorSet
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type QueryGetValidatorCheckpointRequest struct {
}

func (m *QueryGetValidatorCheckpointRequest) Reset()         <span class="cov0" title="0">{ *m = QueryGetValidatorCheckpointRequest{} }</span>
func (m *QueryGetValidatorCheckpointRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetValidatorCheckpointRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetValidatorCheckpointRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{4}
}</span>
func (m *QueryGetValidatorCheckpointRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetValidatorCheckpointRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetValidatorCheckpointRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetValidatorCheckpointRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetValidatorCheckpointRequest.Merge(m, src)
}</span>
func (m *QueryGetValidatorCheckpointRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetValidatorCheckpointRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetValidatorCheckpointRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetValidatorCheckpointRequest proto.InternalMessageInfo

type QueryGetValidatorCheckpointResponse struct {
        ValidatorCheckpoint string `protobuf:"bytes,1,opt,name=validatorCheckpoint,proto3" json:"validatorCheckpoint,omitempty"`
}

func (m *QueryGetValidatorCheckpointResponse) Reset()         <span class="cov0" title="0">{ *m = QueryGetValidatorCheckpointResponse{} }</span>
func (m *QueryGetValidatorCheckpointResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetValidatorCheckpointResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetValidatorCheckpointResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{5}
}</span>
func (m *QueryGetValidatorCheckpointResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetValidatorCheckpointResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetValidatorCheckpointResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetValidatorCheckpointResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetValidatorCheckpointResponse.Merge(m, src)
}</span>
func (m *QueryGetValidatorCheckpointResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetValidatorCheckpointResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetValidatorCheckpointResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetValidatorCheckpointResponse proto.InternalMessageInfo

func (m *QueryGetValidatorCheckpointResponse) GetValidatorCheckpoint() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ValidatorCheckpoint
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type BridgeValidator struct {
        EthereumAddress string `protobuf:"bytes,1,opt,name=ethereumAddress,proto3" json:"ethereumAddress,omitempty"`
        Power           uint64 `protobuf:"varint,2,opt,name=power,proto3" json:"power,omitempty"`
}

func (m *BridgeValidator) Reset()         <span class="cov0" title="0">{ *m = BridgeValidator{} }</span>
func (m *BridgeValidator) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*BridgeValidator) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*BridgeValidator) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{6}
}</span>
func (m *BridgeValidator) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *BridgeValidator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_BridgeValidator.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *BridgeValidator) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_BridgeValidator.Merge(m, src)
}</span>
func (m *BridgeValidator) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *BridgeValidator) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_BridgeValidator.DiscardUnknown(m)
}</span>

var xxx_messageInfo_BridgeValidator proto.InternalMessageInfo

func (m *BridgeValidator) GetEthereumAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.EthereumAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BridgeValidator) GetPower() uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Power
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type BridgeValidatorSet struct {
        BridgeValidatorSet []*BridgeValidator `protobuf:"bytes,1,rep,name=bridgeValidatorSet,proto3" json:"bridgeValidatorSet,omitempty"`
}

func (m *BridgeValidatorSet) Reset()         <span class="cov0" title="0">{ *m = BridgeValidatorSet{} }</span>
func (m *BridgeValidatorSet) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*BridgeValidatorSet) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*BridgeValidatorSet) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{7}
}</span>
func (m *BridgeValidatorSet) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *BridgeValidatorSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_BridgeValidatorSet.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *BridgeValidatorSet) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_BridgeValidatorSet.Merge(m, src)
}</span>
func (m *BridgeValidatorSet) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *BridgeValidatorSet) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_BridgeValidatorSet.DiscardUnknown(m)
}</span>

var xxx_messageInfo_BridgeValidatorSet proto.InternalMessageInfo

func (m *BridgeValidatorSet) GetBridgeValidatorSet() []*BridgeValidator <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BridgeValidatorSet
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BridgeValidatorSetParams struct {
        BridgeValidatorSet      *BridgeValidatorSet `protobuf:"bytes,1,opt,name=bridgeValidatorSet,proto3" json:"bridgeValidatorSet,omitempty"`
        ValidatorTimestamp      int64               `protobuf:"varint,2,opt,name=validatorTimestamp,proto3" json:"validatorTimestamp,omitempty"`
        ValidatorPowerThreshold int64               `protobuf:"varint,3,opt,name=validatorPowerThreshold,proto3" json:"validatorPowerThreshold,omitempty"`
        ValidatorSetHash        []byte              `protobuf:"bytes,4,opt,name=validatorSetHash,proto3" json:"validatorSetHash,omitempty"`
        ValidatorCheckpoint     []byte              `protobuf:"bytes,5,opt,name=validatorCheckpoint,proto3" json:"validatorCheckpoint,omitempty"`
}

func (m *BridgeValidatorSetParams) Reset()         <span class="cov0" title="0">{ *m = BridgeValidatorSetParams{} }</span>
func (m *BridgeValidatorSetParams) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*BridgeValidatorSetParams) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*BridgeValidatorSetParams) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{8}
}</span>
func (m *BridgeValidatorSetParams) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *BridgeValidatorSetParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_BridgeValidatorSetParams.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *BridgeValidatorSetParams) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_BridgeValidatorSetParams.Merge(m, src)
}</span>
func (m *BridgeValidatorSetParams) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *BridgeValidatorSetParams) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_BridgeValidatorSetParams.DiscardUnknown(m)
}</span>

var xxx_messageInfo_BridgeValidatorSetParams proto.InternalMessageInfo

func (m *BridgeValidatorSetParams) GetBridgeValidatorSet() *BridgeValidatorSet <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BridgeValidatorSet
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *BridgeValidatorSetParams) GetValidatorTimestamp() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ValidatorTimestamp
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *BridgeValidatorSetParams) GetValidatorPowerThreshold() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ValidatorPowerThreshold
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *BridgeValidatorSetParams) GetValidatorSetHash() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ValidatorSetHash
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *BridgeValidatorSetParams) GetValidatorCheckpoint() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ValidatorCheckpoint
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BridgeValidatorSetCheckpointParams struct {
        ValidatorTimestamp      int64  `protobuf:"varint,1,opt,name=validatorTimestamp,proto3" json:"validatorTimestamp,omitempty"`
        ValidatorPowerThreshold int64  `protobuf:"varint,2,opt,name=validatorPowerThreshold,proto3" json:"validatorPowerThreshold,omitempty"`
        ValidatorSetHash        []byte `protobuf:"bytes,3,opt,name=validatorSetHash,proto3" json:"validatorSetHash,omitempty"`
}

func (m *BridgeValidatorSetCheckpointParams) Reset()         <span class="cov0" title="0">{ *m = BridgeValidatorSetCheckpointParams{} }</span>
func (m *BridgeValidatorSetCheckpointParams) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*BridgeValidatorSetCheckpointParams) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*BridgeValidatorSetCheckpointParams) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{9}
}</span>
func (m *BridgeValidatorSetCheckpointParams) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *BridgeValidatorSetCheckpointParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_BridgeValidatorSetCheckpointParams.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *BridgeValidatorSetCheckpointParams) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_BridgeValidatorSetCheckpointParams.Merge(m, src)
}</span>
func (m *BridgeValidatorSetCheckpointParams) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *BridgeValidatorSetCheckpointParams) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_BridgeValidatorSetCheckpointParams.DiscardUnknown(m)
}</span>

var xxx_messageInfo_BridgeValidatorSetCheckpointParams proto.InternalMessageInfo

func (m *BridgeValidatorSetCheckpointParams) GetValidatorTimestamp() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ValidatorTimestamp
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *BridgeValidatorSetCheckpointParams) GetValidatorPowerThreshold() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ValidatorPowerThreshold
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *BridgeValidatorSetCheckpointParams) GetValidatorSetHash() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ValidatorSetHash
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BridgeValidatorSetCheckpoint struct {
        ValidatorCheckpoint []byte `protobuf:"bytes,1,opt,name=validatorCheckpoint,proto3" json:"validatorCheckpoint,omitempty"`
}

func (m *BridgeValidatorSetCheckpoint) Reset()         <span class="cov0" title="0">{ *m = BridgeValidatorSetCheckpoint{} }</span>
func (m *BridgeValidatorSetCheckpoint) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*BridgeValidatorSetCheckpoint) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*BridgeValidatorSetCheckpoint) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{10}
}</span>
func (m *BridgeValidatorSetCheckpoint) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *BridgeValidatorSetCheckpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_BridgeValidatorSetCheckpoint.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *BridgeValidatorSetCheckpoint) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_BridgeValidatorSetCheckpoint.Merge(m, src)
}</span>
func (m *BridgeValidatorSetCheckpoint) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *BridgeValidatorSetCheckpoint) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_BridgeValidatorSetCheckpoint.DiscardUnknown(m)
}</span>

var xxx_messageInfo_BridgeValidatorSetCheckpoint proto.InternalMessageInfo

func (m *BridgeValidatorSetCheckpoint) GetValidatorCheckpoint() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ValidatorCheckpoint
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type QueryGetValidatorCheckpointParamsRequest struct {
        Timestamp int64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *QueryGetValidatorCheckpointParamsRequest) Reset() <span class="cov0" title="0">{
        *m = QueryGetValidatorCheckpointParamsRequest{}
}</span>
func (m *QueryGetValidatorCheckpointParamsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetValidatorCheckpointParamsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetValidatorCheckpointParamsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{11}
}</span>
func (m *QueryGetValidatorCheckpointParamsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetValidatorCheckpointParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetValidatorCheckpointParamsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetValidatorCheckpointParamsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetValidatorCheckpointParamsRequest.Merge(m, src)
}</span>
func (m *QueryGetValidatorCheckpointParamsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetValidatorCheckpointParamsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetValidatorCheckpointParamsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetValidatorCheckpointParamsRequest proto.InternalMessageInfo

func (m *QueryGetValidatorCheckpointParamsRequest) GetTimestamp() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Timestamp
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type QueryGetValidatorCheckpointParamsResponse struct {
        Checkpoint     string `protobuf:"bytes,1,opt,name=checkpoint,proto3" json:"checkpoint,omitempty"`
        ValsetHash     string `protobuf:"bytes,2,opt,name=valsetHash,proto3" json:"valsetHash,omitempty"`
        Timestamp      int64  `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
        PowerThreshold int64  `protobuf:"varint,4,opt,name=powerThreshold,proto3" json:"powerThreshold,omitempty"`
}

func (m *QueryGetValidatorCheckpointParamsResponse) Reset() <span class="cov0" title="0">{
        *m = QueryGetValidatorCheckpointParamsResponse{}
}</span>
func (m *QueryGetValidatorCheckpointParamsResponse) String() string <span class="cov0" title="0">{
        return proto.CompactTextString(m)
}</span>
func (*QueryGetValidatorCheckpointParamsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>
func (*QueryGetValidatorCheckpointParamsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{12}
}</span>
func (m *QueryGetValidatorCheckpointParamsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetValidatorCheckpointParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetValidatorCheckpointParamsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetValidatorCheckpointParamsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetValidatorCheckpointParamsResponse.Merge(m, src)
}</span>
func (m *QueryGetValidatorCheckpointParamsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetValidatorCheckpointParamsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetValidatorCheckpointParamsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetValidatorCheckpointParamsResponse proto.InternalMessageInfo

func (m *QueryGetValidatorCheckpointParamsResponse) GetCheckpoint() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Checkpoint
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *QueryGetValidatorCheckpointParamsResponse) GetValsetHash() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ValsetHash
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *QueryGetValidatorCheckpointParamsResponse) GetTimestamp() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Timestamp
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *QueryGetValidatorCheckpointParamsResponse) GetPowerThreshold() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PowerThreshold
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type QueryGetValidatorTimestampByIndexRequest struct {
        Index int64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
}

func (m *QueryGetValidatorTimestampByIndexRequest) Reset() <span class="cov0" title="0">{
        *m = QueryGetValidatorTimestampByIndexRequest{}
}</span>
func (m *QueryGetValidatorTimestampByIndexRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetValidatorTimestampByIndexRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetValidatorTimestampByIndexRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{13}
}</span>
func (m *QueryGetValidatorTimestampByIndexRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetValidatorTimestampByIndexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetValidatorTimestampByIndexRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetValidatorTimestampByIndexRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetValidatorTimestampByIndexRequest.Merge(m, src)
}</span>
func (m *QueryGetValidatorTimestampByIndexRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetValidatorTimestampByIndexRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetValidatorTimestampByIndexRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetValidatorTimestampByIndexRequest proto.InternalMessageInfo

func (m *QueryGetValidatorTimestampByIndexRequest) GetIndex() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Index
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type QueryGetValidatorTimestampByIndexResponse struct {
        Timestamp int64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *QueryGetValidatorTimestampByIndexResponse) Reset() <span class="cov0" title="0">{
        *m = QueryGetValidatorTimestampByIndexResponse{}
}</span>
func (m *QueryGetValidatorTimestampByIndexResponse) String() string <span class="cov0" title="0">{
        return proto.CompactTextString(m)
}</span>
func (*QueryGetValidatorTimestampByIndexResponse) ProtoMessage() {<span class="cov0" title="0">}</span>
func (*QueryGetValidatorTimestampByIndexResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{14}
}</span>
func (m *QueryGetValidatorTimestampByIndexResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetValidatorTimestampByIndexResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetValidatorTimestampByIndexResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetValidatorTimestampByIndexResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetValidatorTimestampByIndexResponse.Merge(m, src)
}</span>
func (m *QueryGetValidatorTimestampByIndexResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetValidatorTimestampByIndexResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetValidatorTimestampByIndexResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetValidatorTimestampByIndexResponse proto.InternalMessageInfo

func (m *QueryGetValidatorTimestampByIndexResponse) GetTimestamp() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Timestamp
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type QueryGetValsetSigsRequest struct {
        Timestamp int64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *QueryGetValsetSigsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryGetValsetSigsRequest{} }</span>
func (m *QueryGetValsetSigsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetValsetSigsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetValsetSigsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{15}
}</span>
func (m *QueryGetValsetSigsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetValsetSigsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetValsetSigsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetValsetSigsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetValsetSigsRequest.Merge(m, src)
}</span>
func (m *QueryGetValsetSigsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetValsetSigsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetValsetSigsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetValsetSigsRequest proto.InternalMessageInfo

func (m *QueryGetValsetSigsRequest) GetTimestamp() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Timestamp
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type QueryGetValsetSigsResponse struct {
        Signatures []string `protobuf:"bytes,1,rep,name=signatures,proto3" json:"signatures,omitempty"`
}

func (m *QueryGetValsetSigsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryGetValsetSigsResponse{} }</span>
func (m *QueryGetValsetSigsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetValsetSigsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetValsetSigsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{16}
}</span>
func (m *QueryGetValsetSigsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetValsetSigsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetValsetSigsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetValsetSigsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetValsetSigsResponse.Merge(m, src)
}</span>
func (m *QueryGetValsetSigsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetValsetSigsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetValsetSigsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetValsetSigsResponse proto.InternalMessageInfo

func (m *QueryGetValsetSigsResponse) GetSignatures() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Signatures
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type QueryGetEvmAddressByValidatorAddressRequest struct {
        ValidatorAddress string `protobuf:"bytes,1,opt,name=validatorAddress,proto3" json:"validatorAddress,omitempty"`
}

func (m *QueryGetEvmAddressByValidatorAddressRequest) Reset() <span class="cov0" title="0">{
        *m = QueryGetEvmAddressByValidatorAddressRequest{}
}</span>
func (m *QueryGetEvmAddressByValidatorAddressRequest) String() string <span class="cov0" title="0">{
        return proto.CompactTextString(m)
}</span>
func (*QueryGetEvmAddressByValidatorAddressRequest) ProtoMessage() {<span class="cov0" title="0">}</span>
func (*QueryGetEvmAddressByValidatorAddressRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{17}
}</span>
func (m *QueryGetEvmAddressByValidatorAddressRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetEvmAddressByValidatorAddressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetEvmAddressByValidatorAddressRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetEvmAddressByValidatorAddressRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetEvmAddressByValidatorAddressRequest.Merge(m, src)
}</span>
func (m *QueryGetEvmAddressByValidatorAddressRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetEvmAddressByValidatorAddressRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetEvmAddressByValidatorAddressRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetEvmAddressByValidatorAddressRequest proto.InternalMessageInfo

func (m *QueryGetEvmAddressByValidatorAddressRequest) GetValidatorAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ValidatorAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type QueryGetEvmAddressByValidatorAddressResponse struct {
        EvmAddress string `protobuf:"bytes,1,opt,name=evmAddress,proto3" json:"evmAddress,omitempty"`
}

func (m *QueryGetEvmAddressByValidatorAddressResponse) Reset() <span class="cov0" title="0">{
        *m = QueryGetEvmAddressByValidatorAddressResponse{}
}</span>
func (m *QueryGetEvmAddressByValidatorAddressResponse) String() string <span class="cov0" title="0">{
        return proto.CompactTextString(m)
}</span>
func (*QueryGetEvmAddressByValidatorAddressResponse) ProtoMessage() {<span class="cov0" title="0">}</span>
func (*QueryGetEvmAddressByValidatorAddressResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{18}
}</span>
func (m *QueryGetEvmAddressByValidatorAddressResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetEvmAddressByValidatorAddressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetEvmAddressByValidatorAddressResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetEvmAddressByValidatorAddressResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetEvmAddressByValidatorAddressResponse.Merge(m, src)
}</span>
func (m *QueryGetEvmAddressByValidatorAddressResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetEvmAddressByValidatorAddressResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetEvmAddressByValidatorAddressResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetEvmAddressByValidatorAddressResponse proto.InternalMessageInfo

func (m *QueryGetEvmAddressByValidatorAddressResponse) GetEvmAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.EvmAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type QueryGetValsetByTimestampRequest struct {
        Timestamp int64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *QueryGetValsetByTimestampRequest) Reset()         <span class="cov0" title="0">{ *m = QueryGetValsetByTimestampRequest{} }</span>
func (m *QueryGetValsetByTimestampRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetValsetByTimestampRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetValsetByTimestampRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{19}
}</span>
func (m *QueryGetValsetByTimestampRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetValsetByTimestampRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetValsetByTimestampRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetValsetByTimestampRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetValsetByTimestampRequest.Merge(m, src)
}</span>
func (m *QueryGetValsetByTimestampRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetValsetByTimestampRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetValsetByTimestampRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetValsetByTimestampRequest proto.InternalMessageInfo

func (m *QueryGetValsetByTimestampRequest) GetTimestamp() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Timestamp
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type QueryGetValsetByTimestampResponse struct {
        BridgeValidatorSet []*BridgeValidator `protobuf:"bytes,1,rep,name=bridgeValidatorSet,proto3" json:"bridgeValidatorSet,omitempty"`
}

func (m *QueryGetValsetByTimestampResponse) Reset()         <span class="cov0" title="0">{ *m = QueryGetValsetByTimestampResponse{} }</span>
func (m *QueryGetValsetByTimestampResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetValsetByTimestampResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetValsetByTimestampResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{20}
}</span>
func (m *QueryGetValsetByTimestampResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetValsetByTimestampResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetValsetByTimestampResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetValsetByTimestampResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetValsetByTimestampResponse.Merge(m, src)
}</span>
func (m *QueryGetValsetByTimestampResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetValsetByTimestampResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetValsetByTimestampResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetValsetByTimestampResponse proto.InternalMessageInfo

func (m *QueryGetValsetByTimestampResponse) GetBridgeValidatorSet() []*BridgeValidator <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BridgeValidatorSet
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type QueryGetCurrentAggregateReportRequest struct {
        QueryId string `protobuf:"bytes,1,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
}

func (m *QueryGetCurrentAggregateReportRequest) Reset()         <span class="cov0" title="0">{ *m = QueryGetCurrentAggregateReportRequest{} }</span>
func (m *QueryGetCurrentAggregateReportRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetCurrentAggregateReportRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetCurrentAggregateReportRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{21}
}</span>
func (m *QueryGetCurrentAggregateReportRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetCurrentAggregateReportRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetCurrentAggregateReportRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetCurrentAggregateReportRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetCurrentAggregateReportRequest.Merge(m, src)
}</span>
func (m *QueryGetCurrentAggregateReportRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetCurrentAggregateReportRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetCurrentAggregateReportRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetCurrentAggregateReportRequest proto.InternalMessageInfo

func (m *QueryGetCurrentAggregateReportRequest) GetQueryId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type QueryGetCurrentAggregateReportResponse struct {
        Aggregate *Aggregate `protobuf:"bytes,1,opt,name=aggregate,proto3" json:"aggregate,omitempty"`
        Timestamp uint64     `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *QueryGetCurrentAggregateReportResponse) Reset() <span class="cov0" title="0">{
        *m = QueryGetCurrentAggregateReportResponse{}
}</span>
func (m *QueryGetCurrentAggregateReportResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetCurrentAggregateReportResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetCurrentAggregateReportResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{22}
}</span>
func (m *QueryGetCurrentAggregateReportResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetCurrentAggregateReportResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetCurrentAggregateReportResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetCurrentAggregateReportResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetCurrentAggregateReportResponse.Merge(m, src)
}</span>
func (m *QueryGetCurrentAggregateReportResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetCurrentAggregateReportResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetCurrentAggregateReportResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetCurrentAggregateReportResponse proto.InternalMessageInfo

func (m *QueryGetCurrentAggregateReportResponse) GetAggregate() *Aggregate <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Aggregate
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *QueryGetCurrentAggregateReportResponse) GetTimestamp() uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Timestamp
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type Aggregate struct {
        QueryId              []byte               `protobuf:"bytes,1,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
        AggregateValue       string               `protobuf:"bytes,2,opt,name=aggregateValue,proto3" json:"aggregateValue,omitempty"`
        AggregateReporter    string               `protobuf:"bytes,3,opt,name=aggregateReporter,proto3" json:"aggregateReporter,omitempty"`
        ReporterPower        int64                `protobuf:"varint,4,opt,name=reporterPower,proto3" json:"reporterPower,omitempty"`
        StandardDeviation    float64              `protobuf:"fixed64,5,opt,name=standardDeviation,proto3" json:"standardDeviation,omitempty"`
        Reporters            []*AggregateReporter `protobuf:"bytes,6,rep,name=reporters,proto3" json:"reporters,omitempty"`
        Flagged              bool                 `protobuf:"varint,7,opt,name=flagged,proto3" json:"flagged,omitempty"`
        Nonce                int64                `protobuf:"varint,8,opt,name=nonce,proto3" json:"nonce,omitempty"`
        AggregateReportIndex int64                `protobuf:"varint,9,opt,name=aggregateReportIndex,proto3" json:"aggregateReportIndex,omitempty"`
        Height               int64                `protobuf:"varint,10,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *Aggregate) Reset()         <span class="cov0" title="0">{ *m = Aggregate{} }</span>
func (m *Aggregate) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Aggregate) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Aggregate) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{23}
}</span>
func (m *Aggregate) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Aggregate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Aggregate.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Aggregate) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Aggregate.Merge(m, src)
}</span>
func (m *Aggregate) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Aggregate) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Aggregate.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Aggregate proto.InternalMessageInfo

func (m *Aggregate) GetQueryId() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryId
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Aggregate) GetAggregateValue() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AggregateValue
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Aggregate) GetAggregateReporter() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AggregateReporter
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Aggregate) GetReporterPower() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ReporterPower
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Aggregate) GetStandardDeviation() float64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.StandardDeviation
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Aggregate) GetReporters() []*AggregateReporter <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Reporters
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Aggregate) GetFlagged() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Flagged
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *Aggregate) GetNonce() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Nonce
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Aggregate) GetAggregateReportIndex() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AggregateReportIndex
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Aggregate) GetHeight() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Height
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type AggregateReporter struct {
        Reporter string `protobuf:"bytes,1,opt,name=reporter,proto3" json:"reporter,omitempty"`
        Power    int64  `protobuf:"varint,2,opt,name=power,proto3" json:"power,omitempty"`
}

func (m *AggregateReporter) Reset()         <span class="cov0" title="0">{ *m = AggregateReporter{} }</span>
func (m *AggregateReporter) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*AggregateReporter) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*AggregateReporter) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{24}
}</span>
func (m *AggregateReporter) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *AggregateReporter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_AggregateReporter.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *AggregateReporter) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_AggregateReporter.Merge(m, src)
}</span>
func (m *AggregateReporter) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *AggregateReporter) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_AggregateReporter.DiscardUnknown(m)
}</span>

var xxx_messageInfo_AggregateReporter proto.InternalMessageInfo

func (m *AggregateReporter) GetReporter() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Reporter
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *AggregateReporter) GetPower() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Power
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type QueryGetDataBeforeRequest struct {
        QueryId   []byte `protobuf:"bytes,1,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
        Timestamp int64  `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *QueryGetDataBeforeRequest) Reset()         <span class="cov0" title="0">{ *m = QueryGetDataBeforeRequest{} }</span>
func (m *QueryGetDataBeforeRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetDataBeforeRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetDataBeforeRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{25}
}</span>
func (m *QueryGetDataBeforeRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetDataBeforeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetDataBeforeRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetDataBeforeRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetDataBeforeRequest.Merge(m, src)
}</span>
func (m *QueryGetDataBeforeRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetDataBeforeRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetDataBeforeRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetDataBeforeRequest proto.InternalMessageInfo

func (m *QueryGetDataBeforeRequest) GetQueryId() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryId
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *QueryGetDataBeforeRequest) GetTimestamp() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Timestamp
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type QueryGetDataBeforeResponse struct {
        Aggregate *types.Aggregate `protobuf:"bytes,1,opt,name=aggregate,proto3" json:"aggregate,omitempty"`
        Timestamp uint64           `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *QueryGetDataBeforeResponse) Reset()         <span class="cov0" title="0">{ *m = QueryGetDataBeforeResponse{} }</span>
func (m *QueryGetDataBeforeResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetDataBeforeResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetDataBeforeResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{26}
}</span>
func (m *QueryGetDataBeforeResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetDataBeforeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetDataBeforeResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetDataBeforeResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetDataBeforeResponse.Merge(m, src)
}</span>
func (m *QueryGetDataBeforeResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetDataBeforeResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetDataBeforeResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetDataBeforeResponse proto.InternalMessageInfo

func (m *QueryGetDataBeforeResponse) GetAggregate() *types.Aggregate <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Aggregate
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *QueryGetDataBeforeResponse) GetTimestamp() uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Timestamp
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type QueryGetSnapshotsByReportRequest struct {
        QueryId   string `protobuf:"bytes,1,opt,name=queryId,proto3" json:"queryId,omitempty"`
        Timestamp string `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *QueryGetSnapshotsByReportRequest) Reset()         <span class="cov0" title="0">{ *m = QueryGetSnapshotsByReportRequest{} }</span>
func (m *QueryGetSnapshotsByReportRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetSnapshotsByReportRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetSnapshotsByReportRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{27}
}</span>
func (m *QueryGetSnapshotsByReportRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetSnapshotsByReportRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetSnapshotsByReportRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetSnapshotsByReportRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetSnapshotsByReportRequest.Merge(m, src)
}</span>
func (m *QueryGetSnapshotsByReportRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetSnapshotsByReportRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetSnapshotsByReportRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetSnapshotsByReportRequest proto.InternalMessageInfo

func (m *QueryGetSnapshotsByReportRequest) GetQueryId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *QueryGetSnapshotsByReportRequest) GetTimestamp() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Timestamp
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type QueryGetSnapshotsByReportResponse struct {
        Snapshots []string `protobuf:"bytes,1,rep,name=snapshots,proto3" json:"snapshots,omitempty"`
}

func (m *QueryGetSnapshotsByReportResponse) Reset()         <span class="cov0" title="0">{ *m = QueryGetSnapshotsByReportResponse{} }</span>
func (m *QueryGetSnapshotsByReportResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetSnapshotsByReportResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetSnapshotsByReportResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{28}
}</span>
func (m *QueryGetSnapshotsByReportResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetSnapshotsByReportResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetSnapshotsByReportResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetSnapshotsByReportResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetSnapshotsByReportResponse.Merge(m, src)
}</span>
func (m *QueryGetSnapshotsByReportResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetSnapshotsByReportResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetSnapshotsByReportResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetSnapshotsByReportResponse proto.InternalMessageInfo

func (m *QueryGetSnapshotsByReportResponse) GetSnapshots() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Snapshots
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type QueryGetAttestationDataBySnapshotRequest struct {
        Snapshot string `protobuf:"bytes,1,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
}

func (m *QueryGetAttestationDataBySnapshotRequest) Reset() <span class="cov0" title="0">{
        *m = QueryGetAttestationDataBySnapshotRequest{}
}</span>
func (m *QueryGetAttestationDataBySnapshotRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetAttestationDataBySnapshotRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetAttestationDataBySnapshotRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{29}
}</span>
func (m *QueryGetAttestationDataBySnapshotRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetAttestationDataBySnapshotRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetAttestationDataBySnapshotRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetAttestationDataBySnapshotRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetAttestationDataBySnapshotRequest.Merge(m, src)
}</span>
func (m *QueryGetAttestationDataBySnapshotRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetAttestationDataBySnapshotRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetAttestationDataBySnapshotRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetAttestationDataBySnapshotRequest proto.InternalMessageInfo

func (m *QueryGetAttestationDataBySnapshotRequest) GetSnapshot() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Snapshot
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type QueryGetAttestationDataBySnapshotResponse struct {
        QueryId                 string `protobuf:"bytes,1,opt,name=queryId,proto3" json:"queryId,omitempty"`
        Timestamp               string `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
        AggregateValue          string `protobuf:"bytes,3,opt,name=aggregateValue,proto3" json:"aggregateValue,omitempty"`
        AggregatePower          string `protobuf:"bytes,4,opt,name=aggregatePower,proto3" json:"aggregatePower,omitempty"`
        Checkpoint              string `protobuf:"bytes,5,opt,name=checkpoint,proto3" json:"checkpoint,omitempty"`
        AttestationTimestamp    string `protobuf:"bytes,6,opt,name=attestationTimestamp,proto3" json:"attestationTimestamp,omitempty"`
        PreviousReportTimestamp string `protobuf:"bytes,7,opt,name=previousReportTimestamp,proto3" json:"previousReportTimestamp,omitempty"`
        NextReportTimestamp     string `protobuf:"bytes,8,opt,name=nextReportTimestamp,proto3" json:"nextReportTimestamp,omitempty"`
}

func (m *QueryGetAttestationDataBySnapshotResponse) Reset() <span class="cov0" title="0">{
        *m = QueryGetAttestationDataBySnapshotResponse{}
}</span>
func (m *QueryGetAttestationDataBySnapshotResponse) String() string <span class="cov0" title="0">{
        return proto.CompactTextString(m)
}</span>
func (*QueryGetAttestationDataBySnapshotResponse) ProtoMessage() {<span class="cov0" title="0">}</span>
func (*QueryGetAttestationDataBySnapshotResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{30}
}</span>
func (m *QueryGetAttestationDataBySnapshotResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetAttestationDataBySnapshotResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetAttestationDataBySnapshotResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetAttestationDataBySnapshotResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetAttestationDataBySnapshotResponse.Merge(m, src)
}</span>
func (m *QueryGetAttestationDataBySnapshotResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetAttestationDataBySnapshotResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetAttestationDataBySnapshotResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetAttestationDataBySnapshotResponse proto.InternalMessageInfo

func (m *QueryGetAttestationDataBySnapshotResponse) GetQueryId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *QueryGetAttestationDataBySnapshotResponse) GetTimestamp() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Timestamp
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *QueryGetAttestationDataBySnapshotResponse) GetAggregateValue() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AggregateValue
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *QueryGetAttestationDataBySnapshotResponse) GetAggregatePower() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AggregatePower
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *QueryGetAttestationDataBySnapshotResponse) GetCheckpoint() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Checkpoint
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *QueryGetAttestationDataBySnapshotResponse) GetAttestationTimestamp() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AttestationTimestamp
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *QueryGetAttestationDataBySnapshotResponse) GetPreviousReportTimestamp() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PreviousReportTimestamp
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *QueryGetAttestationDataBySnapshotResponse) GetNextReportTimestamp() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.NextReportTimestamp
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type QueryGetAttestationsBySnapshotRequest struct {
        Snapshot string `protobuf:"bytes,1,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
}

func (m *QueryGetAttestationsBySnapshotRequest) Reset()         <span class="cov0" title="0">{ *m = QueryGetAttestationsBySnapshotRequest{} }</span>
func (m *QueryGetAttestationsBySnapshotRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetAttestationsBySnapshotRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetAttestationsBySnapshotRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{31}
}</span>
func (m *QueryGetAttestationsBySnapshotRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetAttestationsBySnapshotRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetAttestationsBySnapshotRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetAttestationsBySnapshotRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetAttestationsBySnapshotRequest.Merge(m, src)
}</span>
func (m *QueryGetAttestationsBySnapshotRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetAttestationsBySnapshotRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetAttestationsBySnapshotRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetAttestationsBySnapshotRequest proto.InternalMessageInfo

func (m *QueryGetAttestationsBySnapshotRequest) GetSnapshot() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Snapshot
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type QueryGetAttestationsBySnapshotResponse struct {
        Attestations []string `protobuf:"bytes,1,rep,name=attestations,proto3" json:"attestations,omitempty"`
}

func (m *QueryGetAttestationsBySnapshotResponse) Reset() <span class="cov0" title="0">{
        *m = QueryGetAttestationsBySnapshotResponse{}
}</span>
func (m *QueryGetAttestationsBySnapshotResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetAttestationsBySnapshotResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetAttestationsBySnapshotResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e48df680904493de, []int{32}
}</span>
func (m *QueryGetAttestationsBySnapshotResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetAttestationsBySnapshotResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetAttestationsBySnapshotResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetAttestationsBySnapshotResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetAttestationsBySnapshotResponse.Merge(m, src)
}</span>
func (m *QueryGetAttestationsBySnapshotResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetAttestationsBySnapshotResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetAttestationsBySnapshotResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetAttestationsBySnapshotResponse proto.InternalMessageInfo

func (m *QueryGetAttestationsBySnapshotResponse) GetAttestations() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Attestations
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*QueryParamsRequest)(nil), "layer.bridge.QueryParamsRequest")
        proto.RegisterType((*QueryParamsResponse)(nil), "layer.bridge.QueryParamsResponse")
        proto.RegisterType((*QueryGetEvmValidatorsRequest)(nil), "layer.bridge.QueryGetEvmValidatorsRequest")
        proto.RegisterType((*QueryGetEvmValidatorsResponse)(nil), "layer.bridge.QueryGetEvmValidatorsResponse")
        proto.RegisterType((*QueryGetValidatorCheckpointRequest)(nil), "layer.bridge.QueryGetValidatorCheckpointRequest")
        proto.RegisterType((*QueryGetValidatorCheckpointResponse)(nil), "layer.bridge.QueryGetValidatorCheckpointResponse")
        proto.RegisterType((*BridgeValidator)(nil), "layer.bridge.BridgeValidator")
        proto.RegisterType((*BridgeValidatorSet)(nil), "layer.bridge.BridgeValidatorSet")
        proto.RegisterType((*BridgeValidatorSetParams)(nil), "layer.bridge.BridgeValidatorSetParams")
        proto.RegisterType((*BridgeValidatorSetCheckpointParams)(nil), "layer.bridge.BridgeValidatorSetCheckpointParams")
        proto.RegisterType((*BridgeValidatorSetCheckpoint)(nil), "layer.bridge.BridgeValidatorSetCheckpoint")
        proto.RegisterType((*QueryGetValidatorCheckpointParamsRequest)(nil), "layer.bridge.QueryGetValidatorCheckpointParamsRequest")
        proto.RegisterType((*QueryGetValidatorCheckpointParamsResponse)(nil), "layer.bridge.QueryGetValidatorCheckpointParamsResponse")
        proto.RegisterType((*QueryGetValidatorTimestampByIndexRequest)(nil), "layer.bridge.QueryGetValidatorTimestampByIndexRequest")
        proto.RegisterType((*QueryGetValidatorTimestampByIndexResponse)(nil), "layer.bridge.QueryGetValidatorTimestampByIndexResponse")
        proto.RegisterType((*QueryGetValsetSigsRequest)(nil), "layer.bridge.QueryGetValsetSigsRequest")
        proto.RegisterType((*QueryGetValsetSigsResponse)(nil), "layer.bridge.QueryGetValsetSigsResponse")
        proto.RegisterType((*QueryGetEvmAddressByValidatorAddressRequest)(nil), "layer.bridge.QueryGetEvmAddressByValidatorAddressRequest")
        proto.RegisterType((*QueryGetEvmAddressByValidatorAddressResponse)(nil), "layer.bridge.QueryGetEvmAddressByValidatorAddressResponse")
        proto.RegisterType((*QueryGetValsetByTimestampRequest)(nil), "layer.bridge.QueryGetValsetByTimestampRequest")
        proto.RegisterType((*QueryGetValsetByTimestampResponse)(nil), "layer.bridge.QueryGetValsetByTimestampResponse")
        proto.RegisterType((*QueryGetCurrentAggregateReportRequest)(nil), "layer.bridge.QueryGetCurrentAggregateReportRequest")
        proto.RegisterType((*QueryGetCurrentAggregateReportResponse)(nil), "layer.bridge.QueryGetCurrentAggregateReportResponse")
        proto.RegisterType((*Aggregate)(nil), "layer.bridge.Aggregate")
        proto.RegisterType((*AggregateReporter)(nil), "layer.bridge.AggregateReporter")
        proto.RegisterType((*QueryGetDataBeforeRequest)(nil), "layer.bridge.QueryGetDataBeforeRequest")
        proto.RegisterType((*QueryGetDataBeforeResponse)(nil), "layer.bridge.QueryGetDataBeforeResponse")
        proto.RegisterType((*QueryGetSnapshotsByReportRequest)(nil), "layer.bridge.QueryGetSnapshotsByReportRequest")
        proto.RegisterType((*QueryGetSnapshotsByReportResponse)(nil), "layer.bridge.QueryGetSnapshotsByReportResponse")
        proto.RegisterType((*QueryGetAttestationDataBySnapshotRequest)(nil), "layer.bridge.QueryGetAttestationDataBySnapshotRequest")
        proto.RegisterType((*QueryGetAttestationDataBySnapshotResponse)(nil), "layer.bridge.QueryGetAttestationDataBySnapshotResponse")
        proto.RegisterType((*QueryGetAttestationsBySnapshotRequest)(nil), "layer.bridge.QueryGetAttestationsBySnapshotRequest")
        proto.RegisterType((*QueryGetAttestationsBySnapshotResponse)(nil), "layer.bridge.QueryGetAttestationsBySnapshotResponse")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/bridge/query.proto", fileDescriptor_e48df680904493de) }</span>

var fileDescriptor_e48df680904493de = []byte{
        // 1626 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xcf, 0x6f, 0x1b, 0xc5,
        0x17, 0xcf, 0xc6, 0xf9, 0xe5, 0xd7, 0xf4, 0xdb, 0x76, 0x6a, 0xb5, 0x1b, 0x2b, 0x75, 0xdd, 0xfd,
        0x96, 0xe2, 0xfe, 0xc0, 0xdb, 0xa4, 0x3f, 0x43, 0x5b, 0xd4, 0x38, 0x2d, 0x6d, 0x24, 0x8a, 0x52,
        0xa7, 0x2a, 0xa2, 0x17, 0x6b, 0x6c, 0x4f, 0xd7, 0xab, 0xda, 0xbb, 0xee, 0xee, 0xd8, 0xd4, 0x8a,
        0x72, 0xe1, 0xca, 0x05, 0x09, 0x71, 0xe7, 0x1f, 0xe0, 0x00, 0xe2, 0x84, 0xb8, 0x22, 0xf5, 0x46,
        0x05, 0x17, 0x4e, 0x08, 0x5a, 0x24, 0xfe, 0x00, 0xfe, 0x01, 0xb4, 0xb3, 0xb3, 0xbf, 0x77, 0xd6,
        0x4e, 0x04, 0xa7, 0x78, 0xe7, 0xbd, 0x79, 0xf3, 0xf9, 0xbc, 0x79, 0xf3, 0xe6, 0x33, 0x01, 0xb9,
        0x8b, 0x47, 0xc4, 0x52, 0x9b, 0x96, 0xde, 0xd6, 0x88, 0xfa, 0x7c, 0x40, 0xac, 0x51, 0xb5, 0x6f,
        0x99, 0xd4, 0x44, 0x8b, 0xcc, 0x52, 0x75, 0x2d, 0xc5, 0x82, 0x66, 0x6a, 0x26, 0x33, 0xa8, 0xce,
        0x2f, 0xd7, 0xa7, 0xb8, 0xac, 0x99, 0xa6, 0xd6, 0x25, 0x2a, 0xee, 0xeb, 0x2a, 0x36, 0x0c, 0x93,
        0x62, 0xaa, 0x9b, 0x86, 0xcd, 0xad, 0xe7, 0x5a, 0xa6, 0xdd, 0x33, 0x6d, 0xb5, 0x89, 0x6d, 0x1e,
        0x5a, 0x1d, 0xae, 0x34, 0x09, 0xc5, 0x2b, 0x6a, 0x1f, 0x6b, 0xba, 0xc1, 0x9c, 0xb9, 0xef, 0x52,
        0x04, 0x47, 0x1f, 0x5b, 0xb8, 0xe7, 0x85, 0x59, 0x76, 0x4d, 0xa6, 0x85, 0x5b, 0xce, 0x52, 0x9a,
        0x66, 0x11, 0x0d, 0x53, 0xe2, 0x5a, 0x95, 0x02, 0xa0, 0x87, 0x4e, 0xe8, 0x2d, 0x36, 0xa5, 0x4e,
        0x9e, 0x0f, 0x88, 0x4d, 0x95, 0x4d, 0x38, 0x1a, 0x19, 0xb5, 0xfb, 0xa6, 0x61, 0x13, 0xb4, 0x0a,
        0x73, 0x6e, 0x68, 0x59, 0x2a, 0x4b, 0x95, 0x03, 0xab, 0x85, 0x6a, 0x98, 0x64, 0xd5, 0xf5, 0xae,
        0xcd, 0xbc, 0xfc, 0xed, 0xe4, 0x54, 0x9d, 0x7b, 0x2a, 0x25, 0x58, 0x66, 0xa1, 0xee, 0x11, 0x7a,
        0x77, 0xd8, 0x7b, 0x8c, 0xbb, 0x7a, 0x1b, 0x53, 0xd3, 0xf2, 0x97, 0x32, 0xe0, 0x84, 0xc0, 0xce,
        0x17, 0x7d, 0x00, 0xc8, 0x8d, 0xef, 0xdb, 0xb6, 0x09, 0x95, 0xa5, 0x72, 0xae, 0x72, 0x60, 0xf5,
        0x44, 0x14, 0x40, 0x2d, 0xea, 0x57, 0x4f, 0x99, 0xa8, 0x9c, 0x06, 0xc5, 0x5b, 0xcf, 0x1f, 0xdf,
        0xe8, 0x90, 0xd6, 0xb3, 0xbe, 0xa9, 0x1b, 0xd4, 0x43, 0xf5, 0x11, 0xfc, 0x3f, 0xd3, 0x8b, 0x63,
        0xbb, 0x08, 0x47, 0x87, 0x49, 0x33, 0xcb, 0x4e, 0xbe, 0x9e, 0x66, 0x52, 0x1e, 0xc2, 0xa1, 0x18,
        0x4a, 0x54, 0x81, 0x43, 0x84, 0x76, 0x88, 0x45, 0x06, 0xbd, 0xf5, 0x76, 0xdb, 0x22, 0xb6, 0xcd,
        0x03, 0xc4, 0x87, 0x51, 0x01, 0x66, 0xfb, 0xe6, 0x27, 0xc4, 0x92, 0xa7, 0xcb, 0x52, 0x65, 0xa6,
        0xee, 0x7e, 0x28, 0x2d, 0x40, 0xb5, 0x04, 0xcf, 0x7f, 0x3b, 0x6d, 0xdf, 0x4d, 0x83, 0x9c, 0x5c,
        0xc5, 0xdd, 0x71, 0xb4, 0x25, 0x58, 0xcb, 0xa9, 0x91, 0x72, 0xe6, 0x5a, 0xdb, 0x84, 0xa6, 0x2d,
        0x87, 0xaa, 0x80, 0xfc, 0xec, 0x3d, 0xd2, 0x7b, 0xc4, 0xa6, 0xb8, 0xd7, 0x67, 0xb4, 0x73, 0xf5,
        0x14, 0x0b, 0xba, 0x0e, 0xc7, 0xfd, 0xd1, 0x2d, 0x27, 0x2b, 0x8f, 0x3a, 0x16, 0xb1, 0x3b, 0x66,
        0xb7, 0x2d, 0xe7, 0xd8, 0x24, 0x91, 0x19, 0x9d, 0x83, 0xc3, 0xc3, 0xd0, 0xca, 0xf7, 0xb1, 0xdd,
        0x91, 0x67, 0xca, 0x52, 0x65, 0xb1, 0x9e, 0x18, 0x17, 0x6d, 0xf7, 0x2c, 0x73, 0x4f, 0xdd, 0xee,
        0xef, 0x25, 0x50, 0x92, 0x94, 0x03, 0x07, 0x9e, 0xc0, 0x74, 0xba, 0xd2, 0x7e, 0xe8, 0x4e, 0xef,
        0x9d, 0x6e, 0x2e, 0x9d, 0xae, 0xb2, 0x05, 0xcb, 0x59, 0xd8, 0xb3, 0xaa, 0x5f, 0x90, 0x8e, 0xfb,
        0x50, 0xc9, 0x38, 0x56, 0x91, 0x1e, 0x84, 0x96, 0x21, 0x4f, 0x63, 0xa9, 0x08, 0x06, 0x94, 0x6f,
        0x24, 0x38, 0x3b, 0x41, 0x28, 0x7e, 0x4e, 0x4b, 0x00, 0xad, 0xf8, 0xf1, 0x0c, 0x8d, 0x38, 0xf6,
        0x21, 0xee, 0xda, 0x3c, 0x1f, 0xd3, 0xae, 0x3d, 0x18, 0x89, 0x62, 0xc9, 0xc5, 0xb0, 0xa0, 0x33,
        0xf0, 0xbf, 0x7e, 0x74, 0x13, 0x66, 0x98, 0x4b, 0x6c, 0x54, 0xb9, 0x9d, 0xc2, 0xde, 0xdf, 0xd3,
        0xda, 0x68, 0xd3, 0x68, 0x93, 0x17, 0x1e, 0xfb, 0x02, 0xcc, 0xea, 0xce, 0x37, 0x67, 0xee, 0x7e,
        0x28, 0x9b, 0x29, 0xa4, 0x93, 0x11, 0x38, 0xe9, 0xec, 0x04, 0xae, 0xc1, 0x52, 0x28, 0x94, 0x4d,
        0xe8, 0xb6, 0xae, 0x4d, 0x98, 0xfb, 0x9b, 0x50, 0x4c, 0x9b, 0x1a, 0xe4, 0xda, 0xd6, 0x35, 0x03,
        0xd3, 0x81, 0x45, 0x6c, 0xd6, 0x70, 0xf2, 0xf5, 0xd0, 0x88, 0xf2, 0x31, 0x9c, 0x0f, 0x35, 0x7c,
        0xde, 0xda, 0x6a, 0x23, 0x9f, 0x0f, 0x1f, 0xf1, 0xa0, 0x84, 0x0b, 0x36, 0xda, 0x1e, 0x13, 0xe3,
        0xca, 0x87, 0x70, 0x61, 0xb2, 0xd0, 0x01, 0x54, 0x32, 0x8c, 0x35, 0xdd, 0xd0, 0x88, 0x72, 0x1b,
        0xca, 0x51, 0xa2, 0xb5, 0x91, 0x9f, 0xed, 0xc9, 0x52, 0x65, 0xc1, 0xa9, 0x8c, 0x08, 0xff, 0xcd,
        0x0d, 0x57, 0x83, 0xb7, 0xbc, 0x35, 0x37, 0x06, 0x96, 0x45, 0x0c, 0xba, 0xee, 0x5d, 0xfa, 0x75,
        0xd2, 0x37, 0x2d, 0xef, 0x92, 0x43, 0x4b, 0xb0, 0xc0, 0x64, 0x45, 0x43, 0x6f, 0x73, 0xf2, 0xf3,
        0xec, 0x7b, 0xb3, 0xad, 0xec, 0xc2, 0x99, 0x71, 0x31, 0x38, 0xf8, 0x2b, 0x90, 0xf7, 0x35, 0x05,
        0x6f, 0xf9, 0xc7, 0xa3, 0x98, 0x83, 0x99, 0x81, 0x67, 0x34, 0x6d, 0xee, 0x75, 0x16, 0x4a, 0xdb,
        0x67, 0x39, 0xc8, 0xfb, 0xd3, 0x12, 0x38, 0x17, 0x7d, 0x9c, 0xce, 0xd1, 0xf3, 0x63, 0x3e, 0xc6,
        0xdd, 0x01, 0xe1, 0x87, 0x37, 0x36, 0x8a, 0x2e, 0xc0, 0x11, 0x1c, 0x25, 0x40, 0x2c, 0x76, 0x90,
        0xf3, 0xf5, 0xa4, 0x01, 0x9d, 0x86, 0x83, 0x16, 0xff, 0xcd, 0xda, 0x27, 0x3f, 0xcf, 0xd1, 0x41,
        0x27, 0xa6, 0x4d, 0xb1, 0xd1, 0xc6, 0x56, 0xfb, 0x0e, 0x19, 0xea, 0x4c, 0x8e, 0xb1, 0xbb, 0x40,
        0xaa, 0x27, 0x0d, 0xe8, 0x16, 0xe4, 0xbd, 0xe9, 0xb6, 0x3c, 0xc7, 0xf6, 0xf6, 0xa4, 0x28, 0x4f,
        0xdc, 0xaf, 0x1e, 0xcc, 0x40, 0x32, 0xcc, 0x3f, 0xed, 0x62, 0x4d, 0x23, 0x6d, 0x79, 0xbe, 0x2c,
        0x55, 0x16, 0xea, 0xde, 0xa7, 0xd3, 0x29, 0x0c, 0xd3, 0x68, 0x11, 0x79, 0xc1, 0xed, 0x14, 0xec,
        0x03, 0xad, 0x42, 0x21, 0xc6, 0x8b, 0x35, 0x07, 0x39, 0xcf, 0x9c, 0x52, 0x6d, 0xe8, 0x18, 0xcc,
        0x75, 0x88, 0xae, 0x75, 0xa8, 0x0c, 0xcc, 0x8b, 0x7f, 0x29, 0x77, 0xe1, 0x48, 0x02, 0x1b, 0x2a,
        0xc2, 0x82, 0x87, 0x8e, 0x17, 0x8f, 0xff, 0x1d, 0xd5, 0x29, 0x39, 0x4f, 0xa7, 0x3c, 0x0a, 0x3a,
        0xce, 0x1d, 0x4c, 0x71, 0x8d, 0x3c, 0x35, 0x2d, 0x22, 0xaa, 0xc5, 0xd0, 0x1e, 0x27, 0x4a, 0x25,
        0x72, 0xc2, 0x9e, 0x07, 0xcd, 0x28, 0x1c, 0x75, 0x7c, 0x75, 0xba, 0x82, 0x78, 0x3f, 0xd5, 0xf9,
        0x24, 0x68, 0x0b, 0xdb, 0x06, 0xee, 0xdb, 0x1d, 0x93, 0xda, 0xb5, 0x51, 0xf4, 0x6c, 0xc9, 0xe0,
        0xe1, 0x8f, 0x1d, 0xad, 0x64, 0xec, 0x7c, 0x38, 0xf6, 0x7a, 0xd0, 0x30, 0x52, 0x62, 0x07, 0x9d,
        0xdd, 0xf6, 0x8c, 0xbc, 0xc3, 0x06, 0x03, 0xca, 0xfb, 0xc1, 0x35, 0xb3, 0x4e, 0xa9, 0x13, 0xd7,
        0x29, 0x40, 0x96, 0x9c, 0x91, 0x17, 0xd3, 0x83, 0x59, 0x84, 0x05, 0x6f, 0xa2, 0xb7, 0x8b, 0xde,
        0xb7, 0xf2, 0xf7, 0x74, 0x70, 0xdb, 0x64, 0x04, 0xe2, 0x98, 0xf6, 0x49, 0x38, 0xe5, 0x04, 0xe7,
        0x52, 0x4f, 0x70, 0xd8, 0x2f, 0x38, 0x94, 0x61, 0x3f, 0xf7, 0x54, 0x46, 0xaf, 0xfa, 0xd9, 0xc4,
        0x55, 0xef, 0x1c, 0x8c, 0x80, 0x4c, 0x20, 0xb6, 0xe6, 0x98, 0x67, 0xaa, 0xcd, 0x91, 0x5b, 0x7d,
        0x8b, 0x0c, 0x75, 0x73, 0x60, 0xbb, 0x3b, 0x11, 0x4c, 0x9b, 0x67, 0xd3, 0x44, 0x66, 0x47, 0x22,
        0x19, 0xe4, 0x05, 0x8d, 0xcf, 0x5a, 0x70, 0x1f, 0x08, 0x29, 0x26, 0x65, 0x23, 0xe8, 0xde, 0xa1,
        0xa4, 0xdb, 0x7b, 0xdb, 0xba, 0x0f, 0x82, 0xf6, 0x2d, 0x0a, 0xc2, 0xb7, 0x4d, 0x81, 0xc5, 0x10,
        0x65, 0xaf, 0x9a, 0x22, 0x63, 0xab, 0x7f, 0x20, 0x98, 0x65, 0xe1, 0xd0, 0x33, 0x98, 0xe3, 0x8a,
        0x35, 0x26, 0xeb, 0x93, 0x6f, 0xc8, 0xe2, 0xa9, 0x0c, 0x0f, 0x77, 0x71, 0x65, 0xf9, 0xd3, 0x5f,
        0xfe, 0xfc, 0x62, 0xfa, 0x18, 0x2a, 0xa8, 0x29, 0xcf, 0x57, 0xf4, 0xa5, 0x04, 0x87, 0xe3, 0xaf,
        0x42, 0x74, 0x2e, 0x25, 0xaa, 0xe0, 0x69, 0x59, 0x3c, 0x3f, 0x91, 0x2f, 0xc7, 0x52, 0x61, 0x58,
        0x14, 0x54, 0x8e, 0x62, 0xd1, 0x08, 0x6d, 0x90, 0x61, 0xaf, 0x31, 0x0c, 0x20, 0x7c, 0x2d, 0xc1,
        0xb1, 0x74, 0xd5, 0x89, 0x2e, 0xa6, 0xaf, 0x28, 0x7e, 0x68, 0x16, 0x57, 0xf6, 0x30, 0x83, 0x23,
        0xad, 0x32, 0xa4, 0x15, 0x74, 0x26, 0x89, 0xd4, 0x47, 0xd9, 0x08, 0x55, 0xfc, 0xcf, 0x12, 0x2c,
        0x67, 0xa9, 0x64, 0x74, 0x75, 0x62, 0x0c, 0xd1, 0x1d, 0xbe, 0xb6, 0xe7, 0x79, 0x9c, 0xc1, 0x3a,
        0x63, 0x70, 0x03, 0xad, 0x4d, 0xc6, 0xa0, 0xe1, 0x16, 0x84, 0xba, 0xe3, 0x77, 0x8d, 0x5d, 0xf4,
        0x53, 0x8c, 0x54, 0x5c, 0x05, 0x8f, 0x25, 0x25, 0x10, 0xde, 0x63, 0x49, 0x89, 0xe4, 0xb6, 0xf2,
        0x1e, 0x23, 0x75, 0x1d, 0x5d, 0xcd, 0x22, 0xe5, 0x33, 0x68, 0x34, 0x47, 0x0d, 0xa6, 0xe9, 0xd5,
        0x1d, 0xf6, 0x67, 0xd7, 0x29, 0xf7, 0x83, 0x11, 0x45, 0x8d, 0xde, 0x16, 0x42, 0x89, 0xca, 0xf5,
        0x62, 0x65, 0xbc, 0x23, 0x07, 0xb9, 0xc2, 0x40, 0x9e, 0x47, 0x67, 0x53, 0x41, 0xda, 0x84, 0x36,
        0x6c, 0x5d, 0x8b, 0x66, 0xfa, 0x2f, 0x09, 0x4e, 0x8e, 0x11, 0xd4, 0x68, 0x4d, 0x78, 0xd2, 0xc6,
        0xe9, 0xfb, 0xe2, 0xbb, 0xfb, 0x99, 0xca, 0xd9, 0x3c, 0x60, 0x6c, 0xee, 0xa1, 0xbb, 0xe9, 0x67,
        0x16, 0xbb, 0xee, 0x4e, 0xaa, 0x83, 0x1d, 0xe0, 0x83, 0xea, 0x4e, 0xfc, 0xf5, 0xb0, 0x8b, 0xbe,
        0x95, 0xa0, 0x90, 0x26, 0xd4, 0x51, 0x35, 0x2b, 0xbf, 0xc9, 0x37, 0x41, 0x51, 0x9d, 0xd8, 0x9f,
        0x13, 0x59, 0x63, 0x44, 0x2e, 0xa1, 0x15, 0xe1, 0xb6, 0x34, 0x47, 0x41, 0xed, 0x44, 0xb6, 0xe7,
        0x47, 0x09, 0x96, 0x84, 0x2a, 0x1d, 0x5d, 0x4a, 0x47, 0x92, 0xf9, 0x2e, 0x28, 0x5e, 0xde, 0xdb,
        0x24, 0xce, 0xe1, 0x16, 0xe3, 0x70, 0x0d, 0x5d, 0x49, 0x72, 0x68, 0xb9, 0x33, 0x1b, 0xfe, 0x55,
        0xdd, 0x70, 0xa5, 0xa2, 0xba, 0xe3, 0x69, 0xbe, 0x5d, 0xf4, 0x95, 0x5b, 0xfe, 0x81, 0x86, 0x13,
        0x95, 0x7f, 0x42, 0x3b, 0x8a, 0xca, 0x3f, 0x29, 0x07, 0x95, 0x9b, 0x0c, 0xe3, 0x55, 0x74, 0x39,
        0x89, 0xb1, 0x8d, 0x29, 0x6e, 0x34, 0x99, 0x7b, 0x08, 0x56, 0x24, 0xd5, 0x3f, 0xb8, 0xf5, 0x91,
        0xd0, 0x65, 0xa2, 0xfa, 0x10, 0x89, 0x43, 0x51, 0x7d, 0x08, 0x05, 0x9f, 0xb2, 0xc1, 0x70, 0xdf,
        0x42, 0x37, 0x92, 0xb8, 0x7d, 0xdd, 0xe7, 0x94, 0x48, 0x24, 0xad, 0x9b, 0x31, 0xf8, 0xfc, 0x1e,
        0x10, 0x4a, 0x39, 0x51, 0xcb, 0x1c, 0x27, 0x22, 0x45, 0x2d, 0x73, 0xac, 0x66, 0xcc, 0xba, 0x07,
        0x42, 0x02, 0x84, 0x6f, 0xcd, 0xc8, 0xa7, 0xaa, 0xee, 0x78, 0xbf, 0xfc, 0xf2, 0x4f, 0x57, 0x39,
        0xa2, 0xf2, 0xcf, 0x14, 0x56, 0xa2, 0xf2, 0xcf, 0x16, 0x52, 0x59, 0xe5, 0x1f, 0x16, 0x53, 0x02,
        0x1e, 0xb5, 0x8d, 0x97, 0xaf, 0x4b, 0xd2, 0xab, 0xd7, 0x25, 0xe9, 0xf7, 0xd7, 0x25, 0xe9, 0xf3,
        0x37, 0xa5, 0xa9, 0x57, 0x6f, 0x4a, 0x53, 0xbf, 0xbe, 0x29, 0x4d, 0x3d, 0x39, 0xab, 0xe9, 0xb4,
        0x33, 0x68, 0x56, 0x5b, 0x66, 0x4f, 0xa5, 0xa4, 0xdb, 0x35, 0xad, 0x77, 0x74, 0x93, 0x2f, 0xf2,
        0xc2, 0x5b, 0x86, 0x8e, 0xfa, 0xc4, 0x6e, 0xce, 0xb1, 0xff, 0xe9, 0x5f, 0xfa, 0x27, 0x00, 0x00,
        0xff, 0xff, 0x4d, 0x8c, 0xec, 0xff, 0x96, 0x18, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
        // Parameters queries the parameters of the module.
        Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error)
        // Queries a list of GetEvmValidators items.
        GetEvmValidators(ctx context.Context, in *QueryGetEvmValidatorsRequest, opts ...grpc.CallOption) (*QueryGetEvmValidatorsResponse, error)
        GetValidatorCheckpoint(ctx context.Context, in *QueryGetValidatorCheckpointRequest, opts ...grpc.CallOption) (*QueryGetValidatorCheckpointResponse, error)
        GetValidatorCheckpointParams(ctx context.Context, in *QueryGetValidatorCheckpointParamsRequest, opts ...grpc.CallOption) (*QueryGetValidatorCheckpointParamsResponse, error)
        GetValidatorTimestampByIndex(ctx context.Context, in *QueryGetValidatorTimestampByIndexRequest, opts ...grpc.CallOption) (*QueryGetValidatorTimestampByIndexResponse, error)
        GetValsetSigs(ctx context.Context, in *QueryGetValsetSigsRequest, opts ...grpc.CallOption) (*QueryGetValsetSigsResponse, error)
        GetEvmAddressByValidatorAddress(ctx context.Context, in *QueryGetEvmAddressByValidatorAddressRequest, opts ...grpc.CallOption) (*QueryGetEvmAddressByValidatorAddressResponse, error)
        GetValsetByTimestamp(ctx context.Context, in *QueryGetValsetByTimestampRequest, opts ...grpc.CallOption) (*QueryGetValsetByTimestampResponse, error)
        GetCurrentAggregateReport(ctx context.Context, in *QueryGetCurrentAggregateReportRequest, opts ...grpc.CallOption) (*QueryGetCurrentAggregateReportResponse, error)
        GetDataBefore(ctx context.Context, in *QueryGetDataBeforeRequest, opts ...grpc.CallOption) (*QueryGetDataBeforeResponse, error)
        GetSnapshotsByReport(ctx context.Context, in *QueryGetSnapshotsByReportRequest, opts ...grpc.CallOption) (*QueryGetSnapshotsByReportResponse, error)
        GetAttestationDataBySnapshot(ctx context.Context, in *QueryGetAttestationDataBySnapshotRequest, opts ...grpc.CallOption) (*QueryGetAttestationDataBySnapshotResponse, error)
        GetAttestationsBySnapshot(ctx context.Context, in *QueryGetAttestationsBySnapshotRequest, opts ...grpc.CallOption) (*QueryGetAttestationsBySnapshotResponse, error)
}

type queryClient struct {
        cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient <span class="cov0" title="0">{
        return &amp;queryClient{cc}
}</span>

func (c *queryClient) Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error) <span class="cov0" title="0">{
        out := new(QueryParamsResponse)
        err := c.cc.Invoke(ctx, "/layer.bridge.Query/Params", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) GetEvmValidators(ctx context.Context, in *QueryGetEvmValidatorsRequest, opts ...grpc.CallOption) (*QueryGetEvmValidatorsResponse, error) <span class="cov0" title="0">{
        out := new(QueryGetEvmValidatorsResponse)
        err := c.cc.Invoke(ctx, "/layer.bridge.Query/GetEvmValidators", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) GetValidatorCheckpoint(ctx context.Context, in *QueryGetValidatorCheckpointRequest, opts ...grpc.CallOption) (*QueryGetValidatorCheckpointResponse, error) <span class="cov0" title="0">{
        out := new(QueryGetValidatorCheckpointResponse)
        err := c.cc.Invoke(ctx, "/layer.bridge.Query/GetValidatorCheckpoint", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) GetValidatorCheckpointParams(ctx context.Context, in *QueryGetValidatorCheckpointParamsRequest, opts ...grpc.CallOption) (*QueryGetValidatorCheckpointParamsResponse, error) <span class="cov0" title="0">{
        out := new(QueryGetValidatorCheckpointParamsResponse)
        err := c.cc.Invoke(ctx, "/layer.bridge.Query/GetValidatorCheckpointParams", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) GetValidatorTimestampByIndex(ctx context.Context, in *QueryGetValidatorTimestampByIndexRequest, opts ...grpc.CallOption) (*QueryGetValidatorTimestampByIndexResponse, error) <span class="cov0" title="0">{
        out := new(QueryGetValidatorTimestampByIndexResponse)
        err := c.cc.Invoke(ctx, "/layer.bridge.Query/GetValidatorTimestampByIndex", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) GetValsetSigs(ctx context.Context, in *QueryGetValsetSigsRequest, opts ...grpc.CallOption) (*QueryGetValsetSigsResponse, error) <span class="cov0" title="0">{
        out := new(QueryGetValsetSigsResponse)
        err := c.cc.Invoke(ctx, "/layer.bridge.Query/GetValsetSigs", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) GetEvmAddressByValidatorAddress(ctx context.Context, in *QueryGetEvmAddressByValidatorAddressRequest, opts ...grpc.CallOption) (*QueryGetEvmAddressByValidatorAddressResponse, error) <span class="cov0" title="0">{
        out := new(QueryGetEvmAddressByValidatorAddressResponse)
        err := c.cc.Invoke(ctx, "/layer.bridge.Query/GetEvmAddressByValidatorAddress", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) GetValsetByTimestamp(ctx context.Context, in *QueryGetValsetByTimestampRequest, opts ...grpc.CallOption) (*QueryGetValsetByTimestampResponse, error) <span class="cov0" title="0">{
        out := new(QueryGetValsetByTimestampResponse)
        err := c.cc.Invoke(ctx, "/layer.bridge.Query/GetValsetByTimestamp", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) GetCurrentAggregateReport(ctx context.Context, in *QueryGetCurrentAggregateReportRequest, opts ...grpc.CallOption) (*QueryGetCurrentAggregateReportResponse, error) <span class="cov0" title="0">{
        out := new(QueryGetCurrentAggregateReportResponse)
        err := c.cc.Invoke(ctx, "/layer.bridge.Query/GetCurrentAggregateReport", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) GetDataBefore(ctx context.Context, in *QueryGetDataBeforeRequest, opts ...grpc.CallOption) (*QueryGetDataBeforeResponse, error) <span class="cov0" title="0">{
        out := new(QueryGetDataBeforeResponse)
        err := c.cc.Invoke(ctx, "/layer.bridge.Query/GetDataBefore", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) GetSnapshotsByReport(ctx context.Context, in *QueryGetSnapshotsByReportRequest, opts ...grpc.CallOption) (*QueryGetSnapshotsByReportResponse, error) <span class="cov0" title="0">{
        out := new(QueryGetSnapshotsByReportResponse)
        err := c.cc.Invoke(ctx, "/layer.bridge.Query/GetSnapshotsByReport", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) GetAttestationDataBySnapshot(ctx context.Context, in *QueryGetAttestationDataBySnapshotRequest, opts ...grpc.CallOption) (*QueryGetAttestationDataBySnapshotResponse, error) <span class="cov0" title="0">{
        out := new(QueryGetAttestationDataBySnapshotResponse)
        err := c.cc.Invoke(ctx, "/layer.bridge.Query/GetAttestationDataBySnapshot", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) GetAttestationsBySnapshot(ctx context.Context, in *QueryGetAttestationsBySnapshotRequest, opts ...grpc.CallOption) (*QueryGetAttestationsBySnapshotResponse, error) <span class="cov0" title="0">{
        out := new(QueryGetAttestationsBySnapshotResponse)
        err := c.cc.Invoke(ctx, "/layer.bridge.Query/GetAttestationsBySnapshot", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// QueryServer is the server API for Query service.
type QueryServer interface {
        // Parameters queries the parameters of the module.
        Params(context.Context, *QueryParamsRequest) (*QueryParamsResponse, error)
        // Queries a list of GetEvmValidators items.
        GetEvmValidators(context.Context, *QueryGetEvmValidatorsRequest) (*QueryGetEvmValidatorsResponse, error)
        GetValidatorCheckpoint(context.Context, *QueryGetValidatorCheckpointRequest) (*QueryGetValidatorCheckpointResponse, error)
        GetValidatorCheckpointParams(context.Context, *QueryGetValidatorCheckpointParamsRequest) (*QueryGetValidatorCheckpointParamsResponse, error)
        GetValidatorTimestampByIndex(context.Context, *QueryGetValidatorTimestampByIndexRequest) (*QueryGetValidatorTimestampByIndexResponse, error)
        GetValsetSigs(context.Context, *QueryGetValsetSigsRequest) (*QueryGetValsetSigsResponse, error)
        GetEvmAddressByValidatorAddress(context.Context, *QueryGetEvmAddressByValidatorAddressRequest) (*QueryGetEvmAddressByValidatorAddressResponse, error)
        GetValsetByTimestamp(context.Context, *QueryGetValsetByTimestampRequest) (*QueryGetValsetByTimestampResponse, error)
        GetCurrentAggregateReport(context.Context, *QueryGetCurrentAggregateReportRequest) (*QueryGetCurrentAggregateReportResponse, error)
        GetDataBefore(context.Context, *QueryGetDataBeforeRequest) (*QueryGetDataBeforeResponse, error)
        GetSnapshotsByReport(context.Context, *QueryGetSnapshotsByReportRequest) (*QueryGetSnapshotsByReportResponse, error)
        GetAttestationDataBySnapshot(context.Context, *QueryGetAttestationDataBySnapshotRequest) (*QueryGetAttestationDataBySnapshotResponse, error)
        GetAttestationsBySnapshot(context.Context, *QueryGetAttestationsBySnapshotRequest) (*QueryGetAttestationsBySnapshotResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) Params(ctx context.Context, req *QueryParamsRequest) (*QueryParamsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Params not implemented")
}</span>
func (*UnimplementedQueryServer) GetEvmValidators(ctx context.Context, req *QueryGetEvmValidatorsRequest) (*QueryGetEvmValidatorsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetEvmValidators not implemented")
}</span>
func (*UnimplementedQueryServer) GetValidatorCheckpoint(ctx context.Context, req *QueryGetValidatorCheckpointRequest) (*QueryGetValidatorCheckpointResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetValidatorCheckpoint not implemented")
}</span>
func (*UnimplementedQueryServer) GetValidatorCheckpointParams(ctx context.Context, req *QueryGetValidatorCheckpointParamsRequest) (*QueryGetValidatorCheckpointParamsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetValidatorCheckpointParams not implemented")
}</span>
func (*UnimplementedQueryServer) GetValidatorTimestampByIndex(ctx context.Context, req *QueryGetValidatorTimestampByIndexRequest) (*QueryGetValidatorTimestampByIndexResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetValidatorTimestampByIndex not implemented")
}</span>
func (*UnimplementedQueryServer) GetValsetSigs(ctx context.Context, req *QueryGetValsetSigsRequest) (*QueryGetValsetSigsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetValsetSigs not implemented")
}</span>
func (*UnimplementedQueryServer) GetEvmAddressByValidatorAddress(ctx context.Context, req *QueryGetEvmAddressByValidatorAddressRequest) (*QueryGetEvmAddressByValidatorAddressResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetEvmAddressByValidatorAddress not implemented")
}</span>
func (*UnimplementedQueryServer) GetValsetByTimestamp(ctx context.Context, req *QueryGetValsetByTimestampRequest) (*QueryGetValsetByTimestampResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetValsetByTimestamp not implemented")
}</span>
func (*UnimplementedQueryServer) GetCurrentAggregateReport(ctx context.Context, req *QueryGetCurrentAggregateReportRequest) (*QueryGetCurrentAggregateReportResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetCurrentAggregateReport not implemented")
}</span>
func (*UnimplementedQueryServer) GetDataBefore(ctx context.Context, req *QueryGetDataBeforeRequest) (*QueryGetDataBeforeResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetDataBefore not implemented")
}</span>
func (*UnimplementedQueryServer) GetSnapshotsByReport(ctx context.Context, req *QueryGetSnapshotsByReportRequest) (*QueryGetSnapshotsByReportResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetSnapshotsByReport not implemented")
}</span>
func (*UnimplementedQueryServer) GetAttestationDataBySnapshot(ctx context.Context, req *QueryGetAttestationDataBySnapshotRequest) (*QueryGetAttestationDataBySnapshotResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetAttestationDataBySnapshot not implemented")
}</span>
func (*UnimplementedQueryServer) GetAttestationsBySnapshot(ctx context.Context, req *QueryGetAttestationsBySnapshotRequest) (*QueryGetAttestationsBySnapshotResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetAttestationsBySnapshot not implemented")
}</span>

func RegisterQueryServer(s grpc1.Server, srv QueryServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;_Query_serviceDesc, srv)
}</span>

func _Query_Params_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryParamsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).Params(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.bridge.Query/Params",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).Params(ctx, req.(*QueryParamsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_GetEvmValidators_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryGetEvmValidatorsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetEvmValidators(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.bridge.Query/GetEvmValidators",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetEvmValidators(ctx, req.(*QueryGetEvmValidatorsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_GetValidatorCheckpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryGetValidatorCheckpointRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetValidatorCheckpoint(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.bridge.Query/GetValidatorCheckpoint",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetValidatorCheckpoint(ctx, req.(*QueryGetValidatorCheckpointRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_GetValidatorCheckpointParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryGetValidatorCheckpointParamsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetValidatorCheckpointParams(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.bridge.Query/GetValidatorCheckpointParams",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetValidatorCheckpointParams(ctx, req.(*QueryGetValidatorCheckpointParamsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_GetValidatorTimestampByIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryGetValidatorTimestampByIndexRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetValidatorTimestampByIndex(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.bridge.Query/GetValidatorTimestampByIndex",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetValidatorTimestampByIndex(ctx, req.(*QueryGetValidatorTimestampByIndexRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_GetValsetSigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryGetValsetSigsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetValsetSigs(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.bridge.Query/GetValsetSigs",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetValsetSigs(ctx, req.(*QueryGetValsetSigsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_GetEvmAddressByValidatorAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryGetEvmAddressByValidatorAddressRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetEvmAddressByValidatorAddress(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.bridge.Query/GetEvmAddressByValidatorAddress",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetEvmAddressByValidatorAddress(ctx, req.(*QueryGetEvmAddressByValidatorAddressRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_GetValsetByTimestamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryGetValsetByTimestampRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetValsetByTimestamp(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.bridge.Query/GetValsetByTimestamp",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetValsetByTimestamp(ctx, req.(*QueryGetValsetByTimestampRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_GetCurrentAggregateReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryGetCurrentAggregateReportRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetCurrentAggregateReport(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.bridge.Query/GetCurrentAggregateReport",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetCurrentAggregateReport(ctx, req.(*QueryGetCurrentAggregateReportRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_GetDataBefore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryGetDataBeforeRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetDataBefore(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.bridge.Query/GetDataBefore",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetDataBefore(ctx, req.(*QueryGetDataBeforeRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_GetSnapshotsByReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryGetSnapshotsByReportRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetSnapshotsByReport(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.bridge.Query/GetSnapshotsByReport",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetSnapshotsByReport(ctx, req.(*QueryGetSnapshotsByReportRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_GetAttestationDataBySnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryGetAttestationDataBySnapshotRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetAttestationDataBySnapshot(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.bridge.Query/GetAttestationDataBySnapshot",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetAttestationDataBySnapshot(ctx, req.(*QueryGetAttestationDataBySnapshotRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_GetAttestationsBySnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryGetAttestationsBySnapshotRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetAttestationsBySnapshot(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.bridge.Query/GetAttestationsBySnapshot",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetAttestationsBySnapshot(ctx, req.(*QueryGetAttestationsBySnapshotRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _Query_serviceDesc = grpc.ServiceDesc{
        ServiceName: "layer.bridge.Query",
        HandlerType: (*QueryServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Params",
                        Handler:    _Query_Params_Handler,
                },
                {
                        MethodName: "GetEvmValidators",
                        Handler:    _Query_GetEvmValidators_Handler,
                },
                {
                        MethodName: "GetValidatorCheckpoint",
                        Handler:    _Query_GetValidatorCheckpoint_Handler,
                },
                {
                        MethodName: "GetValidatorCheckpointParams",
                        Handler:    _Query_GetValidatorCheckpointParams_Handler,
                },
                {
                        MethodName: "GetValidatorTimestampByIndex",
                        Handler:    _Query_GetValidatorTimestampByIndex_Handler,
                },
                {
                        MethodName: "GetValsetSigs",
                        Handler:    _Query_GetValsetSigs_Handler,
                },
                {
                        MethodName: "GetEvmAddressByValidatorAddress",
                        Handler:    _Query_GetEvmAddressByValidatorAddress_Handler,
                },
                {
                        MethodName: "GetValsetByTimestamp",
                        Handler:    _Query_GetValsetByTimestamp_Handler,
                },
                {
                        MethodName: "GetCurrentAggregateReport",
                        Handler:    _Query_GetCurrentAggregateReport_Handler,
                },
                {
                        MethodName: "GetDataBefore",
                        Handler:    _Query_GetDataBefore_Handler,
                },
                {
                        MethodName: "GetSnapshotsByReport",
                        Handler:    _Query_GetSnapshotsByReport_Handler,
                },
                {
                        MethodName: "GetAttestationDataBySnapshot",
                        Handler:    _Query_GetAttestationDataBySnapshot_Handler,
                },
                {
                        MethodName: "GetAttestationsBySnapshot",
                        Handler:    _Query_GetAttestationsBySnapshot_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "layer/bridge/query.proto",
}

func (m *QueryParamsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryParamsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryParamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *QueryParamsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryParamsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func (m *QueryGetEvmValidatorsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetEvmValidatorsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetEvmValidatorsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *QueryGetEvmValidatorsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetEvmValidatorsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetEvmValidatorsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.BridgeValidatorSet) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.BridgeValidatorSet) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.BridgeValidatorSet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetValidatorCheckpointRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetValidatorCheckpointRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetValidatorCheckpointRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *QueryGetValidatorCheckpointResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetValidatorCheckpointResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetValidatorCheckpointResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ValidatorCheckpoint) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ValidatorCheckpoint)
                copy(dAtA[i:], m.ValidatorCheckpoint)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.ValidatorCheckpoint)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *BridgeValidator) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *BridgeValidator) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *BridgeValidator) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Power != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.Power))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.EthereumAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.EthereumAddress)
                copy(dAtA[i:], m.EthereumAddress)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.EthereumAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *BridgeValidatorSet) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *BridgeValidatorSet) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *BridgeValidatorSet) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.BridgeValidatorSet) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.BridgeValidatorSet) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.BridgeValidatorSet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *BridgeValidatorSetParams) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *BridgeValidatorSetParams) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *BridgeValidatorSetParams) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ValidatorCheckpoint) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ValidatorCheckpoint)
                copy(dAtA[i:], m.ValidatorCheckpoint)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.ValidatorCheckpoint)))
                i--
                dAtA[i] = 0x2a
        }</span>
        <span class="cov0" title="0">if len(m.ValidatorSetHash) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ValidatorSetHash)
                copy(dAtA[i:], m.ValidatorSetHash)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.ValidatorSetHash)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov0" title="0">if m.ValidatorPowerThreshold != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.ValidatorPowerThreshold))
                i--
                dAtA[i] = 0x18
        }</span>
        <span class="cov0" title="0">if m.ValidatorTimestamp != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.ValidatorTimestamp))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if m.BridgeValidatorSet != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.BridgeValidatorSet.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *BridgeValidatorSetCheckpointParams) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *BridgeValidatorSetCheckpointParams) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *BridgeValidatorSetCheckpointParams) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ValidatorSetHash) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ValidatorSetHash)
                copy(dAtA[i:], m.ValidatorSetHash)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.ValidatorSetHash)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if m.ValidatorPowerThreshold != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.ValidatorPowerThreshold))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if m.ValidatorTimestamp != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.ValidatorTimestamp))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *BridgeValidatorSetCheckpoint) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *BridgeValidatorSetCheckpoint) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *BridgeValidatorSetCheckpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ValidatorCheckpoint) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ValidatorCheckpoint)
                copy(dAtA[i:], m.ValidatorCheckpoint)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.ValidatorCheckpoint)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetValidatorCheckpointParamsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetValidatorCheckpointParamsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetValidatorCheckpointParamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Timestamp != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.Timestamp))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetValidatorCheckpointParamsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetValidatorCheckpointParamsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetValidatorCheckpointParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.PowerThreshold != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.PowerThreshold))
                i--
                dAtA[i] = 0x20
        }</span>
        <span class="cov0" title="0">if m.Timestamp != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.Timestamp))
                i--
                dAtA[i] = 0x18
        }</span>
        <span class="cov0" title="0">if len(m.ValsetHash) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ValsetHash)
                copy(dAtA[i:], m.ValsetHash)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.ValsetHash)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Checkpoint) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Checkpoint)
                copy(dAtA[i:], m.Checkpoint)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.Checkpoint)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetValidatorTimestampByIndexRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetValidatorTimestampByIndexRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetValidatorTimestampByIndexRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Index != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.Index))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetValidatorTimestampByIndexResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetValidatorTimestampByIndexResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetValidatorTimestampByIndexResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Timestamp != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.Timestamp))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetValsetSigsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetValsetSigsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetValsetSigsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Timestamp != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.Timestamp))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetValsetSigsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetValsetSigsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetValsetSigsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Signatures) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Signatures) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        i -= len(m.Signatures[iNdEx])
                        copy(dAtA[i:], m.Signatures[iNdEx])
                        i = encodeVarintQuery(dAtA, i, uint64(len(m.Signatures[iNdEx])))
                        i--
                        dAtA[i] = 0xa
                }</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetEvmAddressByValidatorAddressRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetEvmAddressByValidatorAddressRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetEvmAddressByValidatorAddressRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ValidatorAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ValidatorAddress)
                copy(dAtA[i:], m.ValidatorAddress)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.ValidatorAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetEvmAddressByValidatorAddressResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetEvmAddressByValidatorAddressResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetEvmAddressByValidatorAddressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.EvmAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.EvmAddress)
                copy(dAtA[i:], m.EvmAddress)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.EvmAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetValsetByTimestampRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetValsetByTimestampRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetValsetByTimestampRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Timestamp != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.Timestamp))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetValsetByTimestampResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetValsetByTimestampResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetValsetByTimestampResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.BridgeValidatorSet) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.BridgeValidatorSet) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.BridgeValidatorSet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetCurrentAggregateReportRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetCurrentAggregateReportRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetCurrentAggregateReportRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.QueryId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryId)
                copy(dAtA[i:], m.QueryId)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.QueryId)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetCurrentAggregateReportResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetCurrentAggregateReportResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetCurrentAggregateReportResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Timestamp != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.Timestamp))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if m.Aggregate != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Aggregate.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *Aggregate) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Aggregate) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Aggregate) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Height != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.Height))
                i--
                dAtA[i] = 0x50
        }</span>
        <span class="cov0" title="0">if m.AggregateReportIndex != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.AggregateReportIndex))
                i--
                dAtA[i] = 0x48
        }</span>
        <span class="cov0" title="0">if m.Nonce != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.Nonce))
                i--
                dAtA[i] = 0x40
        }</span>
        <span class="cov0" title="0">if m.Flagged </span><span class="cov0" title="0">{
                i--
                if m.Flagged </span><span class="cov0" title="0">{
                        dAtA[i] = 1
                }</span> else<span class="cov0" title="0"> {
                        dAtA[i] = 0
                }</span>
                <span class="cov0" title="0">i--
                dAtA[i] = 0x38</span>
        }
        <span class="cov0" title="0">if len(m.Reporters) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Reporters) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Reporters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x32</span>
                }
        }
        <span class="cov0" title="0">if m.StandardDeviation != 0 </span><span class="cov0" title="0">{
                i -= 8
                encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.StandardDeviation))))
                i--
                dAtA[i] = 0x29
        }</span>
        <span class="cov0" title="0">if m.ReporterPower != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.ReporterPower))
                i--
                dAtA[i] = 0x20
        }</span>
        <span class="cov0" title="0">if len(m.AggregateReporter) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.AggregateReporter)
                copy(dAtA[i:], m.AggregateReporter)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.AggregateReporter)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.AggregateValue) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.AggregateValue)
                copy(dAtA[i:], m.AggregateValue)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.AggregateValue)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.QueryId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryId)
                copy(dAtA[i:], m.QueryId)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.QueryId)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *AggregateReporter) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *AggregateReporter) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *AggregateReporter) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Power != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.Power))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.Reporter) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Reporter)
                copy(dAtA[i:], m.Reporter)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.Reporter)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetDataBeforeRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetDataBeforeRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetDataBeforeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Timestamp != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.Timestamp))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.QueryId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryId)
                copy(dAtA[i:], m.QueryId)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.QueryId)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetDataBeforeResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetDataBeforeResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetDataBeforeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Timestamp != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.Timestamp))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if m.Aggregate != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Aggregate.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetSnapshotsByReportRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetSnapshotsByReportRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetSnapshotsByReportRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Timestamp) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Timestamp)
                copy(dAtA[i:], m.Timestamp)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.Timestamp)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.QueryId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryId)
                copy(dAtA[i:], m.QueryId)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.QueryId)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetSnapshotsByReportResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetSnapshotsByReportResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetSnapshotsByReportResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Snapshots) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Snapshots) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        i -= len(m.Snapshots[iNdEx])
                        copy(dAtA[i:], m.Snapshots[iNdEx])
                        i = encodeVarintQuery(dAtA, i, uint64(len(m.Snapshots[iNdEx])))
                        i--
                        dAtA[i] = 0xa
                }</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetAttestationDataBySnapshotRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetAttestationDataBySnapshotRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetAttestationDataBySnapshotRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Snapshot) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Snapshot)
                copy(dAtA[i:], m.Snapshot)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.Snapshot)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetAttestationDataBySnapshotResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetAttestationDataBySnapshotResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetAttestationDataBySnapshotResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.NextReportTimestamp) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.NextReportTimestamp)
                copy(dAtA[i:], m.NextReportTimestamp)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.NextReportTimestamp)))
                i--
                dAtA[i] = 0x42
        }</span>
        <span class="cov0" title="0">if len(m.PreviousReportTimestamp) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.PreviousReportTimestamp)
                copy(dAtA[i:], m.PreviousReportTimestamp)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.PreviousReportTimestamp)))
                i--
                dAtA[i] = 0x3a
        }</span>
        <span class="cov0" title="0">if len(m.AttestationTimestamp) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.AttestationTimestamp)
                copy(dAtA[i:], m.AttestationTimestamp)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.AttestationTimestamp)))
                i--
                dAtA[i] = 0x32
        }</span>
        <span class="cov0" title="0">if len(m.Checkpoint) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Checkpoint)
                copy(dAtA[i:], m.Checkpoint)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.Checkpoint)))
                i--
                dAtA[i] = 0x2a
        }</span>
        <span class="cov0" title="0">if len(m.AggregatePower) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.AggregatePower)
                copy(dAtA[i:], m.AggregatePower)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.AggregatePower)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov0" title="0">if len(m.AggregateValue) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.AggregateValue)
                copy(dAtA[i:], m.AggregateValue)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.AggregateValue)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.Timestamp) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Timestamp)
                copy(dAtA[i:], m.Timestamp)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.Timestamp)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.QueryId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryId)
                copy(dAtA[i:], m.QueryId)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.QueryId)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetAttestationsBySnapshotRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetAttestationsBySnapshotRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetAttestationsBySnapshotRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Snapshot) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Snapshot)
                copy(dAtA[i:], m.Snapshot)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.Snapshot)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetAttestationsBySnapshotResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetAttestationsBySnapshotResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetAttestationsBySnapshotResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Attestations) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Attestations) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        i -= len(m.Attestations[iNdEx])
                        copy(dAtA[i:], m.Attestations[iNdEx])
                        i = encodeVarintQuery(dAtA, i, uint64(len(m.Attestations[iNdEx])))
                        i--
                        dAtA[i] = 0xa
                }</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovQuery(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *QueryParamsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *QueryParamsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Params.Size()
        n += 1 + l + sovQuery(uint64(l))
        return n</span>
}

func (m *QueryGetEvmValidatorsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *QueryGetEvmValidatorsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.BridgeValidatorSet) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.BridgeValidatorSet </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovQuery(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetValidatorCheckpointRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *QueryGetValidatorCheckpointResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.ValidatorCheckpoint)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *BridgeValidator) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.EthereumAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Power != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.Power))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *BridgeValidatorSet) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.BridgeValidatorSet) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.BridgeValidatorSet </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovQuery(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *BridgeValidatorSetParams) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.BridgeValidatorSet != nil </span><span class="cov0" title="0">{
                l = m.BridgeValidatorSet.Size()
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.ValidatorTimestamp != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.ValidatorTimestamp))
        }</span>
        <span class="cov0" title="0">if m.ValidatorPowerThreshold != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.ValidatorPowerThreshold))
        }</span>
        <span class="cov0" title="0">l = len(m.ValidatorSetHash)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.ValidatorCheckpoint)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *BridgeValidatorSetCheckpointParams) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.ValidatorTimestamp != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.ValidatorTimestamp))
        }</span>
        <span class="cov0" title="0">if m.ValidatorPowerThreshold != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.ValidatorPowerThreshold))
        }</span>
        <span class="cov0" title="0">l = len(m.ValidatorSetHash)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *BridgeValidatorSetCheckpoint) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.ValidatorCheckpoint)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetValidatorCheckpointParamsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Timestamp != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.Timestamp))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetValidatorCheckpointParamsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Checkpoint)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.ValsetHash)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Timestamp != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.Timestamp))
        }</span>
        <span class="cov0" title="0">if m.PowerThreshold != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.PowerThreshold))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetValidatorTimestampByIndexRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Index != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.Index))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetValidatorTimestampByIndexResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Timestamp != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.Timestamp))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetValsetSigsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Timestamp != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.Timestamp))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetValsetSigsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Signatures) &gt; 0 </span><span class="cov0" title="0">{
                for _, s := range m.Signatures </span><span class="cov0" title="0">{
                        l = len(s)
                        n += 1 + l + sovQuery(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetEvmAddressByValidatorAddressRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.ValidatorAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetEvmAddressByValidatorAddressResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.EvmAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetValsetByTimestampRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Timestamp != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.Timestamp))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetValsetByTimestampResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.BridgeValidatorSet) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.BridgeValidatorSet </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovQuery(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetCurrentAggregateReportRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.QueryId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetCurrentAggregateReportResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Aggregate != nil </span><span class="cov0" title="0">{
                l = m.Aggregate.Size()
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Timestamp != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.Timestamp))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *Aggregate) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.QueryId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.AggregateValue)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.AggregateReporter)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.ReporterPower != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.ReporterPower))
        }</span>
        <span class="cov0" title="0">if m.StandardDeviation != 0 </span><span class="cov0" title="0">{
                n += 9
        }</span>
        <span class="cov0" title="0">if len(m.Reporters) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Reporters </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovQuery(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">if m.Flagged </span><span class="cov0" title="0">{
                n += 2
        }</span>
        <span class="cov0" title="0">if m.Nonce != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.Nonce))
        }</span>
        <span class="cov0" title="0">if m.AggregateReportIndex != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.AggregateReportIndex))
        }</span>
        <span class="cov0" title="0">if m.Height != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.Height))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *AggregateReporter) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Reporter)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Power != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.Power))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetDataBeforeRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.QueryId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Timestamp != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.Timestamp))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetDataBeforeResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Aggregate != nil </span><span class="cov0" title="0">{
                l = m.Aggregate.Size()
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Timestamp != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.Timestamp))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetSnapshotsByReportRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.QueryId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Timestamp)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetSnapshotsByReportResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Snapshots) &gt; 0 </span><span class="cov0" title="0">{
                for _, s := range m.Snapshots </span><span class="cov0" title="0">{
                        l = len(s)
                        n += 1 + l + sovQuery(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetAttestationDataBySnapshotRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Snapshot)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetAttestationDataBySnapshotResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.QueryId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Timestamp)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.AggregateValue)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.AggregatePower)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Checkpoint)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.AttestationTimestamp)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.PreviousReportTimestamp)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.NextReportTimestamp)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetAttestationsBySnapshotRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Snapshot)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetAttestationsBySnapshotResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Attestations) &gt; 0 </span><span class="cov0" title="0">{
                for _, s := range m.Attestations </span><span class="cov0" title="0">{
                        l = len(s)
                        n += 1 + l + sovQuery(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func sovQuery(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozQuery(x uint64) (n int) <span class="cov0" title="0">{
        return sovQuery(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *QueryParamsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryParamsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetEvmValidatorsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetEvmValidatorsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetEvmValidatorsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetEvmValidatorsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetEvmValidatorsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetEvmValidatorsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field BridgeValidatorSet", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.BridgeValidatorSet = append(m.BridgeValidatorSet, &amp;BridgeValidator{})
                        if err := m.BridgeValidatorSet[len(m.BridgeValidatorSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetValidatorCheckpointRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetValidatorCheckpointRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetValidatorCheckpointRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetValidatorCheckpointResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetValidatorCheckpointResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetValidatorCheckpointResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ValidatorCheckpoint", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ValidatorCheckpoint = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *BridgeValidator) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: BridgeValidator: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: BridgeValidator: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field EthereumAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.EthereumAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Power = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Power |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *BridgeValidatorSet) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: BridgeValidatorSet: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: BridgeValidatorSet: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field BridgeValidatorSet", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.BridgeValidatorSet = append(m.BridgeValidatorSet, &amp;BridgeValidator{})
                        if err := m.BridgeValidatorSet[len(m.BridgeValidatorSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *BridgeValidatorSetParams) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: BridgeValidatorSetParams: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: BridgeValidatorSetParams: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field BridgeValidatorSet", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.BridgeValidatorSet == nil </span><span class="cov0" title="0">{
                                m.BridgeValidatorSet = &amp;BridgeValidatorSet{}
                        }</span>
                        <span class="cov0" title="0">if err := m.BridgeValidatorSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ValidatorTimestamp", wireType)
                        }</span>
                        <span class="cov0" title="0">m.ValidatorTimestamp = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.ValidatorTimestamp |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 3:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ValidatorPowerThreshold", wireType)
                        }</span>
                        <span class="cov0" title="0">m.ValidatorPowerThreshold = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.ValidatorPowerThreshold |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ValidatorSetHash", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ValidatorSetHash = append(m.ValidatorSetHash[:0], dAtA[iNdEx:postIndex]...)
                        if m.ValidatorSetHash == nil </span><span class="cov0" title="0">{
                                m.ValidatorSetHash = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 5:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ValidatorCheckpoint", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ValidatorCheckpoint = append(m.ValidatorCheckpoint[:0], dAtA[iNdEx:postIndex]...)
                        if m.ValidatorCheckpoint == nil </span><span class="cov0" title="0">{
                                m.ValidatorCheckpoint = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *BridgeValidatorSetCheckpointParams) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: BridgeValidatorSetCheckpointParams: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: BridgeValidatorSetCheckpointParams: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ValidatorTimestamp", wireType)
                        }</span>
                        <span class="cov0" title="0">m.ValidatorTimestamp = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.ValidatorTimestamp |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ValidatorPowerThreshold", wireType)
                        }</span>
                        <span class="cov0" title="0">m.ValidatorPowerThreshold = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.ValidatorPowerThreshold |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ValidatorSetHash", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ValidatorSetHash = append(m.ValidatorSetHash[:0], dAtA[iNdEx:postIndex]...)
                        if m.ValidatorSetHash == nil </span><span class="cov0" title="0">{
                                m.ValidatorSetHash = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *BridgeValidatorSetCheckpoint) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: BridgeValidatorSetCheckpoint: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: BridgeValidatorSetCheckpoint: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ValidatorCheckpoint", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ValidatorCheckpoint = append(m.ValidatorCheckpoint[:0], dAtA[iNdEx:postIndex]...)
                        if m.ValidatorCheckpoint == nil </span><span class="cov0" title="0">{
                                m.ValidatorCheckpoint = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetValidatorCheckpointParamsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetValidatorCheckpointParamsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetValidatorCheckpointParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Timestamp = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Timestamp |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetValidatorCheckpointParamsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetValidatorCheckpointParamsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetValidatorCheckpointParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Checkpoint = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ValsetHash", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ValsetHash = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Timestamp = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Timestamp |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 4:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PowerThreshold", wireType)
                        }</span>
                        <span class="cov0" title="0">m.PowerThreshold = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.PowerThreshold |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetValidatorTimestampByIndexRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetValidatorTimestampByIndexRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetValidatorTimestampByIndexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Index = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Index |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetValidatorTimestampByIndexResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetValidatorTimestampByIndexResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetValidatorTimestampByIndexResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Timestamp = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Timestamp |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetValsetSigsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetValsetSigsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetValsetSigsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Timestamp = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Timestamp |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetValsetSigsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetValsetSigsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetValsetSigsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Signatures = append(m.Signatures, string(dAtA[iNdEx:postIndex]))
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetEvmAddressByValidatorAddressRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetEvmAddressByValidatorAddressRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetEvmAddressByValidatorAddressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetEvmAddressByValidatorAddressResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetEvmAddressByValidatorAddressResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetEvmAddressByValidatorAddressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field EvmAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.EvmAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetValsetByTimestampRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetValsetByTimestampRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetValsetByTimestampRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Timestamp = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Timestamp |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetValsetByTimestampResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetValsetByTimestampResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetValsetByTimestampResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field BridgeValidatorSet", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.BridgeValidatorSet = append(m.BridgeValidatorSet, &amp;BridgeValidator{})
                        if err := m.BridgeValidatorSet[len(m.BridgeValidatorSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetCurrentAggregateReportRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetCurrentAggregateReportRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetCurrentAggregateReportRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetCurrentAggregateReportResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetCurrentAggregateReportResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetCurrentAggregateReportResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Aggregate", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Aggregate == nil </span><span class="cov0" title="0">{
                                m.Aggregate = &amp;Aggregate{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Aggregate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Timestamp = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Timestamp |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *Aggregate) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Aggregate: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Aggregate: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryId = append(m.QueryId[:0], dAtA[iNdEx:postIndex]...)
                        if m.QueryId == nil </span><span class="cov0" title="0">{
                                m.QueryId = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AggregateValue", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.AggregateValue = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AggregateReporter", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.AggregateReporter = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ReporterPower", wireType)
                        }</span>
                        <span class="cov0" title="0">m.ReporterPower = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.ReporterPower |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 5:<span class="cov0" title="0">
                        if wireType != 1 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field StandardDeviation", wireType)
                        }</span>
                        <span class="cov0" title="0">var v uint64
                        if (iNdEx + 8) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
                        iNdEx += 8
                        m.StandardDeviation = float64(math.Float64frombits(v))</span>
                case 6:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Reporters", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Reporters = append(m.Reporters, &amp;AggregateReporter{})
                        if err := m.Reporters[len(m.Reporters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 7:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Flagged", wireType)
                        }</span>
                        <span class="cov0" title="0">var v int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                v |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">m.Flagged = bool(v != 0)</span>
                case 8:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Nonce = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Nonce |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 9:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AggregateReportIndex", wireType)
                        }</span>
                        <span class="cov0" title="0">m.AggregateReportIndex = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.AggregateReportIndex |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 10:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Height = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Height |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *AggregateReporter) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: AggregateReporter: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: AggregateReporter: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Reporter = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Power = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Power |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetDataBeforeRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetDataBeforeRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetDataBeforeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryId = append(m.QueryId[:0], dAtA[iNdEx:postIndex]...)
                        if m.QueryId == nil </span><span class="cov0" title="0">{
                                m.QueryId = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Timestamp = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Timestamp |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetDataBeforeResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetDataBeforeResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetDataBeforeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Aggregate", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Aggregate == nil </span><span class="cov0" title="0">{
                                m.Aggregate = &amp;types.Aggregate{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Aggregate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Timestamp = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Timestamp |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetSnapshotsByReportRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetSnapshotsByReportRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetSnapshotsByReportRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Timestamp = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetSnapshotsByReportResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetSnapshotsByReportResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetSnapshotsByReportResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Snapshots", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Snapshots = append(m.Snapshots, string(dAtA[iNdEx:postIndex]))
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetAttestationDataBySnapshotRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetAttestationDataBySnapshotRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetAttestationDataBySnapshotRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Snapshot = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetAttestationDataBySnapshotResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetAttestationDataBySnapshotResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetAttestationDataBySnapshotResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Timestamp = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AggregateValue", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.AggregateValue = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AggregatePower", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.AggregatePower = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 5:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Checkpoint = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 6:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AttestationTimestamp", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.AttestationTimestamp = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 7:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PreviousReportTimestamp", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.PreviousReportTimestamp = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 8:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field NextReportTimestamp", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.NextReportTimestamp = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetAttestationsBySnapshotRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetAttestationsBySnapshotRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetAttestationsBySnapshotRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Snapshot = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetAttestationsBySnapshotResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetAttestationsBySnapshotResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetAttestationsBySnapshotResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Attestations", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Attestations = append(m.Attestations, string(dAtA[iNdEx:postIndex]))
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipQuery(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupQuery
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthQuery
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file37" style="display: none">// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: layer/bridge/query.proto

/*
Package types is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package types

import (
        "context"
        "io"
        "net/http"

        "github.com/golang/protobuf/descriptor"
        "github.com/golang/protobuf/proto"
        "github.com/grpc-ecosystem/grpc-gateway/runtime"
        "github.com/grpc-ecosystem/grpc-gateway/utilities"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/grpclog"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// Suppress "imported and not used" errors
var _ codes.Code
var _ io.Reader
var _ status.Status
var _ = runtime.String
var _ = utilities.NewDoubleArray
var _ = descriptor.ForMessage
var _ = metadata.Join

func request_Query_Params_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryParamsRequest
        var metadata runtime.ServerMetadata

        msg, err := client.Params(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err

}</span>

func local_request_Query_Params_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryParamsRequest
        var metadata runtime.ServerMetadata

        msg, err := server.Params(ctx, &amp;protoReq)
        return msg, metadata, err

}</span>

func request_Query_GetEvmValidators_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetEvmValidatorsRequest
        var metadata runtime.ServerMetadata

        msg, err := client.GetEvmValidators(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err

}</span>

func local_request_Query_GetEvmValidators_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetEvmValidatorsRequest
        var metadata runtime.ServerMetadata

        msg, err := server.GetEvmValidators(ctx, &amp;protoReq)
        return msg, metadata, err

}</span>

func request_Query_GetValidatorCheckpoint_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetValidatorCheckpointRequest
        var metadata runtime.ServerMetadata

        msg, err := client.GetValidatorCheckpoint(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err

}</span>

func local_request_Query_GetValidatorCheckpoint_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetValidatorCheckpointRequest
        var metadata runtime.ServerMetadata

        msg, err := server.GetValidatorCheckpoint(ctx, &amp;protoReq)
        return msg, metadata, err

}</span>

func request_Query_GetValidatorCheckpointParams_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetValidatorCheckpointParamsRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["timestamp"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "timestamp")
        }</span>

        <span class="cov0" title="0">protoReq.Timestamp, err = runtime.Int64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "timestamp", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.GetValidatorCheckpointParams(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_GetValidatorCheckpointParams_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetValidatorCheckpointParamsRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["timestamp"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "timestamp")
        }</span>

        <span class="cov0" title="0">protoReq.Timestamp, err = runtime.Int64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "timestamp", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.GetValidatorCheckpointParams(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_GetValidatorTimestampByIndex_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetValidatorTimestampByIndexRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["index"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "index")
        }</span>

        <span class="cov0" title="0">protoReq.Index, err = runtime.Int64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "index", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.GetValidatorTimestampByIndex(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_GetValidatorTimestampByIndex_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetValidatorTimestampByIndexRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["index"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "index")
        }</span>

        <span class="cov0" title="0">protoReq.Index, err = runtime.Int64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "index", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.GetValidatorTimestampByIndex(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_GetValsetSigs_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetValsetSigsRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["timestamp"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "timestamp")
        }</span>

        <span class="cov0" title="0">protoReq.Timestamp, err = runtime.Int64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "timestamp", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.GetValsetSigs(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_GetValsetSigs_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetValsetSigsRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["timestamp"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "timestamp")
        }</span>

        <span class="cov0" title="0">protoReq.Timestamp, err = runtime.Int64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "timestamp", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.GetValsetSigs(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_GetEvmAddressByValidatorAddress_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetEvmAddressByValidatorAddressRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["validatorAddress"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "validatorAddress")
        }</span>

        <span class="cov0" title="0">protoReq.ValidatorAddress, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "validatorAddress", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.GetEvmAddressByValidatorAddress(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_GetEvmAddressByValidatorAddress_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetEvmAddressByValidatorAddressRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["validatorAddress"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "validatorAddress")
        }</span>

        <span class="cov0" title="0">protoReq.ValidatorAddress, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "validatorAddress", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.GetEvmAddressByValidatorAddress(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_GetValsetByTimestamp_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetValsetByTimestampRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["timestamp"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "timestamp")
        }</span>

        <span class="cov0" title="0">protoReq.Timestamp, err = runtime.Int64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "timestamp", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.GetValsetByTimestamp(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_GetValsetByTimestamp_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetValsetByTimestampRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["timestamp"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "timestamp")
        }</span>

        <span class="cov0" title="0">protoReq.Timestamp, err = runtime.Int64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "timestamp", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.GetValsetByTimestamp(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_GetCurrentAggregateReport_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetCurrentAggregateReportRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["query_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "query_id")
        }</span>

        <span class="cov0" title="0">protoReq.QueryId, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "query_id", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.GetCurrentAggregateReport(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_GetCurrentAggregateReport_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetCurrentAggregateReportRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["query_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "query_id")
        }</span>

        <span class="cov0" title="0">protoReq.QueryId, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "query_id", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.GetCurrentAggregateReport(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_GetDataBefore_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetDataBeforeRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["query_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "query_id")
        }</span>

        <span class="cov0" title="0">protoReq.QueryId, err = runtime.Bytes(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "query_id", err)
        }</span>

        <span class="cov0" title="0">val, ok = pathParams["timestamp"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "timestamp")
        }</span>

        <span class="cov0" title="0">protoReq.Timestamp, err = runtime.Int64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "timestamp", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.GetDataBefore(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_GetDataBefore_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetDataBeforeRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["query_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "query_id")
        }</span>

        <span class="cov0" title="0">protoReq.QueryId, err = runtime.Bytes(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "query_id", err)
        }</span>

        <span class="cov0" title="0">val, ok = pathParams["timestamp"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "timestamp")
        }</span>

        <span class="cov0" title="0">protoReq.Timestamp, err = runtime.Int64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "timestamp", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.GetDataBefore(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_GetSnapshotsByReport_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetSnapshotsByReportRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["queryId"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "queryId")
        }</span>

        <span class="cov0" title="0">protoReq.QueryId, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "queryId", err)
        }</span>

        <span class="cov0" title="0">val, ok = pathParams["timestamp"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "timestamp")
        }</span>

        <span class="cov0" title="0">protoReq.Timestamp, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "timestamp", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.GetSnapshotsByReport(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_GetSnapshotsByReport_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetSnapshotsByReportRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["queryId"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "queryId")
        }</span>

        <span class="cov0" title="0">protoReq.QueryId, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "queryId", err)
        }</span>

        <span class="cov0" title="0">val, ok = pathParams["timestamp"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "timestamp")
        }</span>

        <span class="cov0" title="0">protoReq.Timestamp, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "timestamp", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.GetSnapshotsByReport(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_GetAttestationDataBySnapshot_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetAttestationDataBySnapshotRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["snapshot"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "snapshot")
        }</span>

        <span class="cov0" title="0">protoReq.Snapshot, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "snapshot", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.GetAttestationDataBySnapshot(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_GetAttestationDataBySnapshot_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetAttestationDataBySnapshotRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["snapshot"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "snapshot")
        }</span>

        <span class="cov0" title="0">protoReq.Snapshot, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "snapshot", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.GetAttestationDataBySnapshot(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_GetAttestationsBySnapshot_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetAttestationsBySnapshotRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["snapshot"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "snapshot")
        }</span>

        <span class="cov0" title="0">protoReq.Snapshot, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "snapshot", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.GetAttestationsBySnapshot(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_GetAttestationsBySnapshot_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetAttestationsBySnapshotRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["snapshot"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "snapshot")
        }</span>

        <span class="cov0" title="0">protoReq.Snapshot, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "snapshot", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.GetAttestationsBySnapshot(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

// RegisterQueryHandlerServer registers the http handlers for service Query to "mux".
// UnaryRPC     :call QueryServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterQueryHandlerFromEndpoint instead.
func RegisterQueryHandlerServer(ctx context.Context, mux *runtime.ServeMux, server QueryServer) error <span class="cov0" title="0">{

        mux.Handle("GET", pattern_Query_Params_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_Params_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_Params_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetEvmValidators_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_GetEvmValidators_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetEvmValidators_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetValidatorCheckpoint_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_GetValidatorCheckpoint_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetValidatorCheckpoint_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetValidatorCheckpointParams_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_GetValidatorCheckpointParams_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetValidatorCheckpointParams_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetValidatorTimestampByIndex_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_GetValidatorTimestampByIndex_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetValidatorTimestampByIndex_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetValsetSigs_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_GetValsetSigs_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetValsetSigs_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetEvmAddressByValidatorAddress_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_GetEvmAddressByValidatorAddress_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetEvmAddressByValidatorAddress_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetValsetByTimestamp_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_GetValsetByTimestamp_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetValsetByTimestamp_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetCurrentAggregateReport_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_GetCurrentAggregateReport_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetCurrentAggregateReport_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetDataBefore_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_GetDataBefore_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetDataBefore_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetSnapshotsByReport_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_GetSnapshotsByReport_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetSnapshotsByReport_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetAttestationDataBySnapshot_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_GetAttestationDataBySnapshot_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetAttestationDataBySnapshot_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetAttestationsBySnapshot_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_GetAttestationsBySnapshot_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetAttestationsBySnapshot_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

// RegisterQueryHandlerFromEndpoint is same as RegisterQueryHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterQueryHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) <span class="cov0" title="0">{
        conn, err := grpc.Dial(endpoint, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                }()
        }()

        <span class="cov0" title="0">return RegisterQueryHandler(ctx, mux, conn)</span>
}

// RegisterQueryHandler registers the http handlers for service Query to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterQueryHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error <span class="cov0" title="0">{
        return RegisterQueryHandlerClient(ctx, mux, NewQueryClient(conn))
}</span>

// RegisterQueryHandlerClient registers the http handlers for service Query
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "QueryClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "QueryClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "QueryClient" to call the correct interceptors.
func RegisterQueryHandlerClient(ctx context.Context, mux *runtime.ServeMux, client QueryClient) error <span class="cov0" title="0">{

        mux.Handle("GET", pattern_Query_Params_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_Params_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_Params_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetEvmValidators_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_GetEvmValidators_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetEvmValidators_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetValidatorCheckpoint_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_GetValidatorCheckpoint_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetValidatorCheckpoint_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetValidatorCheckpointParams_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_GetValidatorCheckpointParams_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetValidatorCheckpointParams_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetValidatorTimestampByIndex_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_GetValidatorTimestampByIndex_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetValidatorTimestampByIndex_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetValsetSigs_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_GetValsetSigs_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetValsetSigs_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetEvmAddressByValidatorAddress_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_GetEvmAddressByValidatorAddress_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetEvmAddressByValidatorAddress_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetValsetByTimestamp_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_GetValsetByTimestamp_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetValsetByTimestamp_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetCurrentAggregateReport_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_GetCurrentAggregateReport_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetCurrentAggregateReport_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetDataBefore_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_GetDataBefore_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetDataBefore_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetSnapshotsByReport_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_GetSnapshotsByReport_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetSnapshotsByReport_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetAttestationDataBySnapshot_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_GetAttestationDataBySnapshot_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetAttestationDataBySnapshot_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetAttestationsBySnapshot_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_GetAttestationsBySnapshot_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetAttestationsBySnapshot_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

var (
        pattern_Query_Params_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"layer", "bridge", "params"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_GetEvmValidators_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"layer", "bridge", "get_evm_validators"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_GetValidatorCheckpoint_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"layer", "bridge", "get_validator_checkpoint"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_GetValidatorCheckpointParams_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"layer", "bridge", "get_validator_checkpoint_params", "timestamp"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_GetValidatorTimestampByIndex_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"layer", "bridge", "get_validator_timestamp_by_index", "index"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_GetValsetSigs_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"layer", "bridge", "get_valset_sigs", "timestamp"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_GetEvmAddressByValidatorAddress_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"layer", "bridge", "get_evm_address_by_validator_address", "validatorAddress"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_GetValsetByTimestamp_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"layer", "bridge", "get_valset_by_timestamp", "timestamp"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_GetCurrentAggregateReport_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"layer", "bridge", "get_current_aggregate_report", "query_id"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_GetDataBefore_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 1, 0, 4, 1, 5, 4}, []string{"layer", "bridge", "get_data_before", "query_id", "timestamp"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_GetSnapshotsByReport_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 1, 0, 4, 1, 5, 4}, []string{"layer", "bridge", "get_snapshots_by_report", "queryId", "timestamp"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_GetAttestationDataBySnapshot_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"layer", "bridge", "get_attestation_data_by_snapshot", "snapshot"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_GetAttestationsBySnapshot_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"layer", "bridge", "get_attestations_by_snapshot", "snapshot"}, "", runtime.AssumeColonVerbOpt(false)))
)

var (
        forward_Query_Params_0 = runtime.ForwardResponseMessage

        forward_Query_GetEvmValidators_0 = runtime.ForwardResponseMessage

        forward_Query_GetValidatorCheckpoint_0 = runtime.ForwardResponseMessage

        forward_Query_GetValidatorCheckpointParams_0 = runtime.ForwardResponseMessage

        forward_Query_GetValidatorTimestampByIndex_0 = runtime.ForwardResponseMessage

        forward_Query_GetValsetSigs_0 = runtime.ForwardResponseMessage

        forward_Query_GetEvmAddressByValidatorAddress_0 = runtime.ForwardResponseMessage

        forward_Query_GetValsetByTimestamp_0 = runtime.ForwardResponseMessage

        forward_Query_GetCurrentAggregateReport_0 = runtime.ForwardResponseMessage

        forward_Query_GetDataBefore_0 = runtime.ForwardResponseMessage

        forward_Query_GetSnapshotsByReport_0 = runtime.ForwardResponseMessage

        forward_Query_GetAttestationDataBySnapshot_0 = runtime.ForwardResponseMessage

        forward_Query_GetAttestationsBySnapshot_0 = runtime.ForwardResponseMessage
)
</pre>
		
		<pre class="file" id="file38" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/bridge/tx.proto

package types

import (
        context "context"
        fmt "fmt"
        _ "github.com/cosmos/cosmos-sdk/types/msgservice"
        grpc1 "github.com/cosmos/gogoproto/grpc"
        proto "github.com/cosmos/gogoproto/proto"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MsgRequestAttestations struct {
        Creator   string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
        QueryId   string `protobuf:"bytes,2,opt,name=queryId,proto3" json:"queryId,omitempty"`
        Timestamp string `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *MsgRequestAttestations) Reset()         <span class="cov0" title="0">{ *m = MsgRequestAttestations{} }</span>
func (m *MsgRequestAttestations) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgRequestAttestations) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgRequestAttestations) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_cb4091a52ebadfca, []int{0}
}</span>
func (m *MsgRequestAttestations) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgRequestAttestations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgRequestAttestations.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgRequestAttestations) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgRequestAttestations.Merge(m, src)
}</span>
func (m *MsgRequestAttestations) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgRequestAttestations) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgRequestAttestations.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgRequestAttestations proto.InternalMessageInfo

func (m *MsgRequestAttestations) GetCreator() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Creator
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgRequestAttestations) GetQueryId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgRequestAttestations) GetTimestamp() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Timestamp
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type MsgRequestAttestationsResponse struct {
}

func (m *MsgRequestAttestationsResponse) Reset()         <span class="cov0" title="0">{ *m = MsgRequestAttestationsResponse{} }</span>
func (m *MsgRequestAttestationsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgRequestAttestationsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgRequestAttestationsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_cb4091a52ebadfca, []int{1}
}</span>
func (m *MsgRequestAttestationsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgRequestAttestationsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgRequestAttestationsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgRequestAttestationsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgRequestAttestationsResponse.Merge(m, src)
}</span>
func (m *MsgRequestAttestationsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgRequestAttestationsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgRequestAttestationsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgRequestAttestationsResponse proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*MsgRequestAttestations)(nil), "layer.bridge.MsgRequestAttestations")
        proto.RegisterType((*MsgRequestAttestationsResponse)(nil), "layer.bridge.MsgRequestAttestationsResponse")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/bridge/tx.proto", fileDescriptor_cb4091a52ebadfca) }</span>

var fileDescriptor_cb4091a52ebadfca = []byte{
        // 266 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0xcd, 0x49, 0xac, 0x4c,
        0x2d, 0xd2, 0x4f, 0x2a, 0xca, 0x4c, 0x49, 0x4f, 0xd5, 0x2f, 0xa9, 0xd0, 0x2b, 0x28, 0xca, 0x2f,
        0xc9, 0x17, 0xe2, 0x01, 0x0b, 0xeb, 0x41, 0x84, 0xa5, 0xc4, 0x93, 0xf3, 0x8b, 0x73, 0xf3, 0x8b,
        0xf5, 0x73, 0x8b, 0xd3, 0xf5, 0xcb, 0x0c, 0x41, 0x14, 0x44, 0x99, 0x52, 0x05, 0x97, 0x98, 0x6f,
        0x71, 0x7a, 0x50, 0x6a, 0x61, 0x69, 0x6a, 0x71, 0x89, 0x63, 0x49, 0x49, 0x6a, 0x71, 0x49, 0x62,
        0x49, 0x66, 0x7e, 0x5e, 0xb1, 0x90, 0x04, 0x17, 0x7b, 0x72, 0x51, 0x6a, 0x62, 0x49, 0x7e, 0x91,
        0x04, 0xa3, 0x02, 0xa3, 0x06, 0x67, 0x10, 0x8c, 0x0b, 0x92, 0x29, 0x2c, 0x4d, 0x2d, 0xaa, 0xf4,
        0x4c, 0x91, 0x60, 0x82, 0xc8, 0x40, 0xb9, 0x42, 0x32, 0x5c, 0x9c, 0x25, 0x99, 0xb9, 0x20, 0x33,
        0x72, 0x0b, 0x24, 0x98, 0xc1, 0x72, 0x08, 0x01, 0x2b, 0x9e, 0xa6, 0xe7, 0x1b, 0xb4, 0x60, 0xa6,
        0x28, 0x29, 0x70, 0xc9, 0x61, 0xb7, 0x39, 0x28, 0xb5, 0xb8, 0x20, 0x3f, 0xaf, 0x38, 0xd5, 0xa8,
        0x80, 0x8b, 0xd9, 0xb7, 0x38, 0x5d, 0x28, 0x93, 0x4b, 0x18, 0x9b, 0xfb, 0x54, 0xf4, 0x90, 0x7d,
        0xa8, 0x87, 0xdd, 0x2c, 0x29, 0x1d, 0x62, 0x54, 0xc1, 0x6c, 0x74, 0x72, 0x3e, 0xf1, 0x48, 0x8e,
        0xf1, 0xc2, 0x23, 0x39, 0xc6, 0x07, 0x8f, 0xe4, 0x18, 0x27, 0x3c, 0x96, 0x63, 0xb8, 0xf0, 0x58,
        0x8e, 0xe1, 0xc6, 0x63, 0x39, 0x86, 0x28, 0xcd, 0xf4, 0xcc, 0x92, 0x8c, 0xd2, 0x24, 0xbd, 0xe4,
        0xfc, 0x5c, 0xfd, 0x92, 0xd4, 0x9c, 0x9c, 0xfc, 0x22, 0xdd, 0xcc, 0x7c, 0x7d, 0x48, 0xd0, 0x57,
        0xc0, 0x03, 0xbf, 0xb2, 0x20, 0xb5, 0x38, 0x89, 0x0d, 0x1c, 0xb2, 0xc6, 0x80, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xed, 0x91, 0xbe, 0xa8, 0x99, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
        RequestAttestations(ctx context.Context, in *MsgRequestAttestations, opts ...grpc.CallOption) (*MsgRequestAttestationsResponse, error)
}

type msgClient struct {
        cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient <span class="cov0" title="0">{
        return &amp;msgClient{cc}
}</span>

func (c *msgClient) RequestAttestations(ctx context.Context, in *MsgRequestAttestations, opts ...grpc.CallOption) (*MsgRequestAttestationsResponse, error) <span class="cov0" title="0">{
        out := new(MsgRequestAttestationsResponse)
        err := c.cc.Invoke(ctx, "/layer.bridge.Msg/RequestAttestations", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
        RequestAttestations(context.Context, *MsgRequestAttestations) (*MsgRequestAttestationsResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) RequestAttestations(ctx context.Context, req *MsgRequestAttestations) (*MsgRequestAttestationsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RequestAttestations not implemented")
}</span>

func RegisterMsgServer(s grpc1.Server, srv MsgServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;_Msg_serviceDesc, srv)
}</span>

func _Msg_RequestAttestations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgRequestAttestations)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).RequestAttestations(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.bridge.Msg/RequestAttestations",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).RequestAttestations(ctx, req.(*MsgRequestAttestations))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _Msg_serviceDesc = grpc.ServiceDesc{
        ServiceName: "layer.bridge.Msg",
        HandlerType: (*MsgServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "RequestAttestations",
                        Handler:    _Msg_RequestAttestations_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "layer/bridge/tx.proto",
}

func (m *MsgRequestAttestations) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgRequestAttestations) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgRequestAttestations) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Timestamp) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Timestamp)
                copy(dAtA[i:], m.Timestamp)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Timestamp)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.QueryId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryId)
                copy(dAtA[i:], m.QueryId)
                i = encodeVarintTx(dAtA, i, uint64(len(m.QueryId)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Creator) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Creator)
                copy(dAtA[i:], m.Creator)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgRequestAttestationsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgRequestAttestationsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgRequestAttestationsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func encodeVarintTx(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovTx(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *MsgRequestAttestations) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Creator)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.QueryId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Timestamp)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgRequestAttestationsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func sovTx(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozTx(x uint64) (n int) <span class="cov0" title="0">{
        return sovTx(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *MsgRequestAttestations) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRequestAttestations: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRequestAttestations: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Creator = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryId = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Timestamp = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgRequestAttestationsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRequestAttestationsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRequestAttestationsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipTx(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupTx
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthTx
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file39" style="display: none">package types

import (
        "github.com/gogo/protobuf/proto"
)

// ValidatorCheckpoint wraps a [32]byte to be used with the codec
type ValidatorCheckpoint struct {
        Checkpoint []byte `protobuf:"bytes,1,opt,name=checkpoint,proto3,casttype=[32]byte"`
}

// Ensure ValidatorCheckpoint implements proto.Message
var _ proto.Message = &amp;ValidatorCheckpoint{}

// ProtoMessage is a no-op method to satisfy the proto.Message interface
func (*ValidatorCheckpoint) ProtoMessage() {<span class="cov0" title="0">}</span>

// Reset is a no-op method to satisfy the proto.Message interface
func (*ValidatorCheckpoint) Reset() {<span class="cov0" title="0">}</span>

// String returns a string representation, satisfying the proto.Message interface
func (m *ValidatorCheckpoint) String() string <span class="cov0" title="0">{
        return proto.CompactTextString(m)
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package types

import (
        "github.com/gogo/protobuf/proto"
)

// ValidatorCheckpointParams holds the signatures of validators.
// Each validator's signatures are stored in a slice of bytes.
type ValidatorCheckpointParams struct {
        Checkpoint     []byte `protobuf:"bytes,1,opt,name=checkpoint,proto3"`
        ValsetHash     []byte `protobuf:"bytes,2,opt,name=valset_hash,proto3"`
        Timestamp      int64  `protobuf:"varint,3,opt,name=timestamp,proto3"`
        PowerThreshold int64  `protobuf:"varint,4,opt,name=power_threshold,proto3"`
}

// Ensure ValidatorCheckpointParams implements proto.Message
var _ proto.Message = &amp;ValidatorCheckpointParams{}

// ProtoMessage is a no-op method to satisfy the proto.Message interface
func (*ValidatorCheckpointParams) ProtoMessage() {<span class="cov0" title="0">}</span>

// Reset is a no-op method to satisfy the proto.Message interface
func (*ValidatorCheckpointParams) Reset() {<span class="cov0" title="0">}</span>

// String returns a string representation, satisfying the proto.Message interface
func (m *ValidatorCheckpointParams) String() string <span class="cov0" title="0">{
        return proto.CompactTextString(m)
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package dispute

import (
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/dispute/keeper"
        "github.com/tellor-io/layer/x/dispute/types"
)

// InitGenesis initializes the module's state from a provided genesis state.
func InitGenesis(ctx sdk.Context, k keeper.Keeper, genState types.GenesisState) <span class="cov8" title="1">{
        // this line is used by starport scaffolding # genesis/module/init
        k.SetParams(ctx, genState.Params)
}</span>

// ExportGenesis returns the module's exported genesis
func ExportGenesis(ctx sdk.Context, k keeper.Keeper) *types.GenesisState <span class="cov8" title="1">{
        genesis := types.DefaultGenesis()
        genesis.Params = k.GetParams(ctx)

        // this line is used by starport scaffolding # genesis/module/export

        return genesis
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package keeper

import (
        "cosmossdk.io/math"
        sdk "github.com/cosmos/cosmos-sdk/types"
        layer "github.com/tellor-io/layer/types"
        "github.com/tellor-io/layer/x/dispute/types"
)

// tally votes
func (k Keeper) Tally(ctx sdk.Context, ids []uint64) error <span class="cov0" title="0">{
        for _, id := range ids </span><span class="cov0" title="0">{
                if err := k.TallyVote(ctx, id); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Execute the transfer of fee after the vote on a dispute is complete
func (k Keeper) ExecuteVote(ctx sdk.Context, id uint64) error <span class="cov0" title="0">{
        dispute, err := k.GetDisputeById(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">var voters []string
        for _, id := range dispute.PrevDisputeIds </span><span class="cov0" title="0">{
                v, err := k.GetVote(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">voters = append(voters, v.Voters...)</span>
        }
        <span class="cov0" title="0">vote, err := k.GetVote(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if vote.Executed || dispute.DisputeStatus != types.Resolved </span><span class="cov0" title="0">{
                ctx.Logger().Info("can't execute vote, reason either vote has already executed: %v, or dispute not resolved: %v", vote.Executed, dispute.DisputeStatus)
                return nil
        }</span>
        // amount of dispute fee to return to fee payers or give to reporter
        <span class="cov0" title="0">disputeFeeMinusBurn := dispute.SlashAmount.Sub(dispute.BurnAmount)
        // the burnAmount starts at %5 of disputeFee, half of which is burned and the other half is distributed to the voters
        halfBurnAmount := dispute.BurnAmount.QuoRaw(2)
        voterReward := halfBurnAmount
        if len(voters) == 0 </span><span class="cov0" title="0">{
                // if no voters, burn the entire burnAmount
                halfBurnAmount = dispute.BurnAmount
                // non voters get nothing
                voterReward = math.ZeroInt()
        }</span>
        <span class="cov0" title="0">switch vote.VoteResult </span>{
        case types.VoteResult_INVALID, types.VoteResult_NO_QUORUM_MAJORITY_INVALID:<span class="cov0" title="0">
                // distribute the voterRewardunt equally among the voters and transfer it to their accounts
                burnRemainder, err := k.RewardVoters(ctx, voters, voterReward)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // burn half the burnAmount
                <span class="cov0" title="0">if err := k.bankKeeper.BurnCoins(ctx, types.ModuleName, sdk.NewCoins(sdk.NewCoin(layer.BondDenom, halfBurnAmount.Add(burnRemainder)))); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // refund the remaining dispute fee to the fee payers according to their payment method
                <span class="cov0" title="0">if err := k.RefundDisputeFee(ctx, dispute.FeePayers, disputeFeeMinusBurn); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // stake the slashed tokens back into the bonded pool for the reporter
                <span class="cov0" title="0">if err := k.ReturnSlashedTokens(ctx, dispute); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">vote.Executed = true
                if err := k.SetVote(ctx, id, vote); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case types.VoteResult_SUPPORT, types.VoteResult_NO_QUORUM_MAJORITY_SUPPORT:<span class="cov0" title="0">
                burnRemainder, err := k.RewardVoters(ctx, voters, voterReward)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // burn half the burnAmount
                <span class="cov0" title="0">if err := k.bankKeeper.BurnCoins(ctx, types.ModuleName, sdk.NewCoins(sdk.NewCoin(layer.BondDenom, halfBurnAmount.Add(burnRemainder)))); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // refund the remaining dispute fee to the fee payers according to their payment method
                <span class="cov0" title="0">if err := k.RefundDisputeFee(ctx, dispute.FeePayers, disputeFeeMinusBurn); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // divide the reporters bond equally amongst the dispute fee payers and add it to the bonded pool
                <span class="cov0" title="0">if err := k.RewardReporterBondToFeePayers(ctx, dispute.FeePayers, dispute.SlashAmount); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">vote.Executed = true
                if err := k.SetVote(ctx, id, vote); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case types.VoteResult_AGAINST, types.VoteResult_NO_QUORUM_MAJORITY_AGAINST:<span class="cov0" title="0">
                burnRemainder, err := k.RewardVoters(ctx, voters, voterReward)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // burn half the burnAmount
                <span class="cov0" title="0">if err := k.bankKeeper.BurnCoins(ctx, types.ModuleName, sdk.NewCoins(sdk.NewCoin(layer.BondDenom, halfBurnAmount.Add(burnRemainder)))); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // refund the reporters bond to the reporter plus the remaining disputeFee; goes to bonded pool
                <span class="cov0" title="0">dispute.SlashAmount = dispute.SlashAmount.Add(disputeFeeMinusBurn)
                if err := k.ReturnSlashedTokens(ctx, dispute); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">vote.Executed = true
                if err := k.SetVote(ctx, id, vote); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (k Keeper) ExecuteVotes(ctx sdk.Context, ids []uint64) error <span class="cov0" title="0">{
        for _, id := range ids </span><span class="cov0" title="0">{
                err := k.ExecuteVote(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// set disputes to resolved if adding rounds has been exhausted
// check if disputes can be removed due to expiration prior to commencing vote
func (k Keeper) CheckPrevoteDisputesForExpiration(ctx sdk.Context) ([]uint64, error) <span class="cov0" title="0">{
        openDisputes, err := k.GetOpenDisputeIds(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var expiredDisputes []uint64 // disputes that failed to begin vote (ie fee unpaid in full)
        var activeDisputes []uint64

        for _, disputeId := range openDisputes.Ids </span><span class="cov0" title="0">{
                // get dispute by id
                dispute, err := k.GetDisputeById(ctx, disputeId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if ctx.BlockTime().After(dispute.DisputeEndTime) &amp;&amp; dispute.DisputeStatus == types.Prevote </span><span class="cov0" title="0">{
                        // append to expired list
                        expiredDisputes = append(expiredDisputes, disputeId)
                }</span> else<span class="cov0" title="0"> {
                        // append to active list if not expired
                        activeDisputes = append(activeDisputes, disputeId)
                }</span>
        }
        // update active disputes list
        <span class="cov0" title="0">openDisputes.Ids = activeDisputes
        err = k.SetOpenDisputeIds(ctx, openDisputes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, disputeId := range expiredDisputes </span><span class="cov0" title="0">{
                // set dispute status to expired
                err := k.SetDisputeStatus(ctx, disputeId, types.Failed)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        // return active list
        <span class="cov0" title="0">return activeDisputes, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package keeper

import (
        "context"
        "crypto/sha256"
        "encoding/binary"
        "fmt"
        gomath "math"
        "math/big"
        "time"

        "cosmossdk.io/math"

        sdk "github.com/cosmos/cosmos-sdk/types"
        layertypes "github.com/tellor-io/layer/types"
        "github.com/tellor-io/layer/x/dispute/types"
        oracletypes "github.com/tellor-io/layer/x/oracle/types"
)

// Get dispute by dispute id
func (k Keeper) GetDisputeById(ctx sdk.Context, id uint64) (*types.Dispute, error) <span class="cov8" title="1">{
        store := k.disputeStore(ctx)
        bz := store.Get(types.DisputeIdBytes(id))
        if bz == nil </span><span class="cov0" title="0">{
                return nil, types.ErrDisputeDoesNotExist.Wrapf("no dispute found with id %d", id)
        }</span>
        <span class="cov8" title="1">var dispute types.Dispute
        err := k.cdc.Unmarshal(bz, &amp;dispute)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;dispute, nil</span>
}

// Get dispute by reporter key
func (k Keeper) GetDisputeByReporter(ctx sdk.Context, r oracletypes.MicroReport, c types.DisputeCategory) *types.Dispute <span class="cov8" title="1">{
        store := k.disputeStore(ctx)
        key := []byte(k.ReporterKey(ctx, r, c))
        bz := store.Get(key)
        if bz == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">var dispute types.Dispute
        k.cdc.MustUnmarshal(bz, &amp;dispute)
        return &amp;dispute</span>
}

// Get the dispute count from the store
func (k Keeper) GetDisputeCount(ctx sdk.Context) uint64 <span class="cov8" title="1">{
        store := k.disputeStore(ctx)
        byteKey := types.KeyPrefix(types.DisputeCountKey)
        bz := store.Get(byteKey)
        // Count doesn't exist: no disputes yet
        if bz == nil </span><span class="cov8" title="1">{
                return 1
        }</span>
        <span class="cov0" title="0">return binary.BigEndian.Uint64(bz)</span>
}

// Get open dispute ids from the store
func (k Keeper) GetOpenDisputeIds(ctx sdk.Context) (types.OpenDisputes, error) <span class="cov8" title="1">{
        store := k.disputeStore(ctx)
        bz := store.Get(types.OpenDisputeIdsKeyPrefix())
        if bz == nil </span><span class="cov8" title="1">{
                return types.OpenDisputes{}, nil
        }</span>
        <span class="cov8" title="1">var ids types.OpenDisputes
        err := k.cdc.Unmarshal(bz, &amp;ids)
        if err != nil </span><span class="cov0" title="0">{
                return types.OpenDisputes{}, err
        }</span>
        <span class="cov8" title="1">return ids, nil</span>
}

// Generate hash id
func (k Keeper) HashId(ctx sdk.Context, r oracletypes.MicroReport, c types.DisputeCategory) [32]byte <span class="cov8" title="1">{
        params := types.DisputeParams{
                Report:   &amp;r,
                Category: c,
        }
        return sha256.Sum256(k.cdc.MustMarshal(&amp;params))
}</span>

// Make a reporter key by combining reporter address and a hash of dispute params
func (k Keeper) ReporterKey(ctx sdk.Context, r oracletypes.MicroReport, c types.DisputeCategory) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%x", r.Reporter, k.HashId(ctx, r, c))
}</span>

// Update the dispute count in the store
func (k Keeper) SetDisputeCount(ctx sdk.Context, count uint64) <span class="cov8" title="1">{
        store := k.disputeStore(ctx)
        byteKey := types.KeyPrefix(types.DisputeCountKey)
        bz := make([]byte, 8)
        binary.BigEndian.PutUint64(bz, count)
        store.Set(byteKey, bz)
}</span>

// Set dispute in the store by dispute id
func (k Keeper) SetDisputeById(ctx sdk.Context, id uint64, dispute types.Dispute) error <span class="cov8" title="1">{
        store := k.disputeStore(ctx)
        bz, err := k.cdc.Marshal(&amp;dispute)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">store.Set(types.DisputeIdBytes(id), bz)
        return nil</span>
}

// Set dispute by reporter
func (k Keeper) SetDisputeByReporter(ctx sdk.Context, dispute types.Dispute) error <span class="cov8" title="1">{
        store := k.disputeStore(ctx)
        bz, err := k.cdc.Marshal(&amp;dispute)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">key := []byte(k.ReporterKey(ctx, dispute.ReportEvidence, dispute.DisputeCategory))
        store.Set(key, bz)
        return nil</span>
}

// Set new dispute
func (k Keeper) SetNewDispute(ctx sdk.Context, msg types.MsgProposeDispute) error <span class="cov8" title="1">{
        disputeId := k.GetDisputeCount(ctx)
        hashId := k.HashId(ctx, *msg.Report, msg.DisputeCategory)
        // slash amount
        disputeFee, err := k.GetDisputeFee(ctx, msg.Report.Reporter, msg.DisputeCategory)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">feeList := make([]types.PayerInfo, 0)

        if msg.Fee.Amount.GT(disputeFee) </span><span class="cov0" title="0">{
                msg.Fee.Amount = disputeFee
        }</span>
        <span class="cov8" title="1">fivePercent := disputeFee.MulRaw(1).QuoRaw(20)
        dispute := types.Dispute{
                HashId:            hashId[:],
                DisputeId:         disputeId,
                DisputeCategory:   msg.DisputeCategory,
                DisputeStatus:     types.Prevote,
                DisputeStartTime:  ctx.BlockTime(),
                DisputeEndTime:    ctx.BlockTime().Add(ONE_DAY), // one day to fully pay fee
                DisputeStartBlock: ctx.BlockHeight(),
                DisputeRound:      1,
                SlashAmount:       disputeFee,
                // burn amount is calculated as 5% of dispute fee
                BurnAmount:     fivePercent,
                DisputeFee:     disputeFee.Sub(fivePercent),
                ReportEvidence: *msg.Report,
                FeePayers: append(feeList, types.PayerInfo{
                        PayerAddress: msg.Creator,
                        Amount:       msg.Fee.Amount,
                        FromBond:     msg.PayFromBond,
                        BlockNumber:  ctx.BlockHeight(),
                }),
                FeeTotal:       msg.Fee.Amount,
                PrevDisputeIds: []uint64{disputeId},
        }
        // Pay the dispute fee
        if err := k.PayDisputeFee(ctx, msg.Creator, msg.Fee, msg.PayFromBond); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // if the paid fee is equal to the slash amount, then slash validator and jail
        <span class="cov8" title="1">if dispute.FeeTotal.Equal(dispute.SlashAmount) </span><span class="cov8" title="1">{
                if err := k.SlashAndJailReporter(ctx, dispute.ReportEvidence, dispute.DisputeCategory); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // extend dispute end time by 3 days, 2 for voting and 1 to allow for more rounds
                <span class="cov8" title="1">dispute.DisputeEndTime = ctx.BlockTime().Add(THREE_DAYS)
                dispute.DisputeStatus = types.Voting
                if err := k.SetStartVote(ctx, dispute.DisputeId); err != nil </span><span class="cov0" title="0">{ // starting voting immediately
                        return err
                }</span>
        }

        <span class="cov8" title="1">return k.SetDispute(ctx, dispute)</span>
}

// Slash and jail reporter
func (k Keeper) SlashAndJailReporter(ctx sdk.Context, report oracletypes.MicroReport, category types.DisputeCategory) error <span class="cov8" title="1">{
        reporterAddr := sdk.MustAccAddressFromBech32(report.Reporter)

        slashFactor, jailDuration, err := k.GetSlashPercentageAndJailDuration(category)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">amount := math.NewInt(report.Power).Mul(layertypes.PowerReduction)
        slashAmount := math.LegacyNewDecFromInt(amount).Mul(slashFactor)
        err = k.reporterKeeper.EscrowReporterStake(ctx, reporterAddr, report.Power, report.BlockNumber, slashAmount.TruncateInt())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return k.jailReporter(ctx, reporterAddr, jailDuration)</span>
}

func (k Keeper) jailReporter(ctx context.Context, repAddr sdk.AccAddress, jailDuration int64) error <span class="cov8" title="1">{
        // noop for major duration, reporter is removed from store so no need to jail
        if jailDuration == gomath.MaxInt64 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return k.reporterKeeper.JailReporter(ctx, repAddr, jailDuration)</span>
}

// Store open dispute ids in the store
func (k Keeper) SetOpenDisputeIds(ctx sdk.Context, ids types.OpenDisputes) error <span class="cov8" title="1">{
        store := k.disputeStore(ctx)
        bz, err := k.cdc.Marshal(&amp;ids)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">store.Set(types.OpenDisputeIdsKeyPrefix(), bz)
        return nil</span>
}

// Get percentage of slash amount based on category
func (k Keeper) GetSlashPercentageAndJailDuration(category types.DisputeCategory) (math.LegacyDec, int64, error) <span class="cov8" title="1">{
        switch category </span>{
        case types.Warning:<span class="cov8" title="1">
                return math.LegacyNewDecWithPrec(1, 2), 0, nil</span> // 1%
        case types.Minor:<span class="cov0" title="0">
                return math.LegacyNewDecWithPrec(5, 2), 600, nil</span> // 5%
        case types.Major:<span class="cov0" title="0">
                return math.LegacyNewDecWithPrec(1, 0), gomath.MaxInt64, nil</span> // 100%
        default:<span class="cov0" title="0">
                return math.LegacyDec{}, 0, types.ErrInvalidDisputeCategory</span>
        }
}

// Get dispute fee
func (k Keeper) GetDisputeFee(ctx sdk.Context, repAddr string, category types.DisputeCategory) (math.Int, error) <span class="cov8" title="1">{
        reporterAddr := sdk.MustAccAddressFromBech32(repAddr)
        reporter, err := k.reporterKeeper.Reporter(ctx, reporterAddr)
        if err != nil </span><span class="cov0" title="0">{
                return math.Int{}, err
        }</span>

        <span class="cov8" title="1">stake := reporter.TotalTokens
        switch category </span>{
        case types.Warning:<span class="cov8" title="1">
                // calculate 1 percent of bond
                return stake.MulRaw(1).QuoRaw(100), nil</span>
        case types.Minor:<span class="cov0" title="0">
                // calculate 5 percent of bond
                return stake.MulRaw(5).QuoRaw(100), nil</span>
        case types.Major:<span class="cov0" title="0">
                // calculate 100 percent of bond
                return stake, nil</span>
        default:<span class="cov0" title="0">
                return math.Int{}, types.ErrInvalidDisputeCategory</span>
        }
}

// Update existing dispute when conditions are met
func (k Keeper) AddDisputeRound(ctx sdk.Context, dispute types.Dispute, msg types.MsgProposeDispute) error <span class="cov0" title="0">{
        if dispute.DisputeStatus != types.Unresolved </span><span class="cov0" title="0">{
                return fmt.Errorf("can't start a new round for this dispute %d; dispute status %s", dispute.DisputeId, dispute.DisputeStatus)
        }</span>
        // if dispute is not unresovled and dispute end time is before current block time then we can't update it
        <span class="cov0" title="0">if dispute.DisputeEndTime.Before(ctx.BlockTime()) </span><span class="cov0" title="0">{
                return fmt.Errorf("this dispute is expired, can't start new round %d", dispute.DisputeId)
        }</span>

        <span class="cov0" title="0">fee := func(fivePercent math.Int, round int64) math.Int </span><span class="cov0" title="0">{
                base := new(big.Int).Exp(big.NewInt(2), big.NewInt(round), nil)
                return fivePercent.Mul(math.NewIntFromBigInt(base))
        }</span>
        <span class="cov0" title="0">fivePercent := dispute.SlashAmount.MulRaw(1).QuoRaw(20)
        roundFee := fee(fivePercent, int64(dispute.DisputeRound))
        if roundFee.GT(dispute.SlashAmount) </span><span class="cov0" title="0">{
                roundFee = dispute.SlashAmount
        }</span>

        <span class="cov0" title="0">if msg.Fee.Amount.LT(roundFee) </span><span class="cov0" title="0">{
                return fmt.Errorf("fee amount is less than amount required")
        }</span> else<span class="cov0" title="0"> {
                msg.Fee.Amount = roundFee
        }</span>

        // Pay the dispute fee
        <span class="cov0" title="0">if err := k.PayDisputeFee(ctx, msg.Creator, msg.Fee, msg.PayFromBond); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">dispute.BurnAmount = dispute.BurnAmount.Add(roundFee)
        dispute.FeeTotal = dispute.FeeTotal.Add(msg.Fee.Amount)
        disputeId := k.GetDisputeCount(ctx)
        dispute.DisputeId = disputeId
        dispute.DisputeStatus = types.Voting // starting voting immediately
        dispute.DisputeStartTime = ctx.BlockTime()
        // add 3 days to block time
        dispute.DisputeEndTime = ctx.BlockTime().Add(THREE_DAYS)
        dispute.DisputeStartBlock = ctx.BlockHeight()
        dispute.DisputeRound++
        // from previous dispute id from open disputes
        err := k.removeId(ctx, dispute.PrevDisputeIds[len(dispute.PrevDisputeIds)-1])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">dispute.PrevDisputeIds = append(dispute.PrevDisputeIds, disputeId)

        err = k.SetDispute(ctx, dispute)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = k.SetStartVote(ctx, dispute.DisputeId) // starting voting immediately
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// remove dispute id from opendisputes after adding a new round
func (k Keeper) removeId(ctx sdk.Context, disputeId uint64) error <span class="cov0" title="0">{
        openDisputes, err := k.GetOpenDisputeIds(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for i, id := range openDisputes.Ids </span><span class="cov0" title="0">{
                if id == disputeId </span><span class="cov0" title="0">{
                        openDisputes.Ids[i] = openDisputes.Ids[len(openDisputes.Ids)-1]
                        openDisputes.Ids = openDisputes.Ids[:len(openDisputes.Ids)-1]
                        err = k.SetOpenDisputeIds(ctx, openDisputes)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// Add time to dispute end time
func (k Keeper) AddTimeToDisputeEndTime(ctx sdk.Context, id uint64, timeToAdd time.Duration) error <span class="cov0" title="0">{
        dispute, err := k.GetDisputeById(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">dispute.DisputeEndTime = dispute.DisputeEndTime.Add(timeToAdd)
        err = k.SetDisputeById(ctx, dispute.DisputeId, *dispute)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return k.SetDisputeByReporter(ctx, *dispute)</span>
}

// Append dispute id to open dispute ids
func (k Keeper) AppendDisputeIdToOpenDisputeIds(ctx sdk.Context, disputeId uint64) error <span class="cov8" title="1">{
        openDisputes, err := k.GetOpenDisputeIds(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">openDisputes.Ids = append(openDisputes.Ids, disputeId)
        err = k.SetOpenDisputeIds(ctx, openDisputes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Set DISPUTE
func (k Keeper) SetDispute(ctx sdk.Context, dispute types.Dispute) error <span class="cov8" title="1">{
        if err := k.AppendDisputeIdToOpenDisputeIds(ctx, dispute.DisputeId); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := k.SetDisputeByReporter(ctx, dispute); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := k.SetDisputeById(ctx, dispute.DisputeId, dispute); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">k.SetDisputeCount(ctx, dispute.DisputeId+1)
        return nil</span>
}

// Set dispute status by dispute id
func (k Keeper) SetDisputeStatus(ctx sdk.Context, id uint64, status types.DisputeStatus) error <span class="cov0" title="0">{
        dispute, err := k.GetDisputeById(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">dispute.DisputeStatus = status
        err = k.SetDisputeById(ctx, id, *dispute)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return k.SetDisputeByReporter(ctx, *dispute)</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package keeper

import (
        "fmt"

        "cosmossdk.io/math"
        sdk "github.com/cosmos/cosmos-sdk/types"
        stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
        layertypes "github.com/tellor-io/layer/types"
        "github.com/tellor-io/layer/x/dispute/types"
)

// Pay fee from account
func (k Keeper) PayFromAccount(ctx sdk.Context, addr sdk.AccAddress, fee sdk.Coin) error <span class="cov8" title="1">{
        if !k.bankKeeper.HasBalance(ctx, addr, fee) </span><span class="cov0" title="0">{
                return types.INSUFFICIENT_BALANCE
        }</span>
        <span class="cov8" title="1">if err := k.bankKeeper.SendCoinsFromAccountToModule(ctx, addr, types.ModuleName, sdk.NewCoins(fee)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("fee payment failed: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Pay fee from validator's bond can only be called by the validator itself
func (k Keeper) PayFromBond(ctx sdk.Context, reporterAddr sdk.AccAddress, fee sdk.Coin) error <span class="cov8" title="1">{
        return k.reporterKeeper.FeefromReporterStake(ctx, reporterAddr, fee.Amount)
}</span>

// Pay dispute fee
func (k Keeper) PayDisputeFee(ctx sdk.Context, sender string, fee sdk.Coin, fromBond bool) error <span class="cov8" title="1">{
        proposer := sdk.MustAccAddressFromBech32(sender)
        if fromBond </span><span class="cov0" title="0">{
                // pay fee from given validator
                err := k.PayFromBond(ctx, proposer, fee)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                err := k.PayFromAccount(ctx, proposer, fee)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// return slashed tokens when reporter either wins dispute or dispute is invalid
func (k Keeper) ReturnSlashedTokens(ctx sdk.Context, dispute *types.Dispute) error <span class="cov0" title="0">{

        err := k.reporterKeeper.ReturnSlashedTokens(ctx, dispute.ReportEvidence.Reporter, dispute.ReportEvidence.BlockNumber, dispute.SlashAmount)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">coins := sdk.NewCoins(sdk.NewCoin(layertypes.BondDenom, dispute.SlashAmount))
        return k.bankKeeper.SendCoinsFromModuleToModule(ctx, types.ModuleName, stakingtypes.BondedPoolName, coins)</span>
}

func (k Keeper) ReturnFeetoStake(ctx sdk.Context, repAddr string, height int64, remainingAmt math.Int) error <span class="cov0" title="0">{

        err := k.reporterKeeper.ReturnSlashedTokens(ctx, repAddr, height, remainingAmt)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">coins := sdk.NewCoins(sdk.NewCoin(layertypes.BondDenom, remainingAmt))
        return k.bankKeeper.SendCoinsFromModuleToModule(ctx, types.ModuleName, stakingtypes.BondedPoolName, coins)</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package keeper

import (
        "cosmossdk.io/math"
        sdk "github.com/cosmos/cosmos-sdk/types"
        banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
        stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
        layer "github.com/tellor-io/layer/types"
        "github.com/tellor-io/layer/x/dispute/types"
)

func (k Keeper) RefundDisputeFee(ctx sdk.Context, feePayers []types.PayerInfo, remainingAmt math.Int) error <span class="cov0" title="0">{
        var outputs []banktypes.Output

        moduleAddress := k.accountKeeper.GetModuleAddress(types.ModuleName)
        initialTotalAmount := math.ZeroInt()

        for _, recipient := range feePayers </span><span class="cov0" title="0">{
                initialTotalAmount = initialTotalAmount.Add(recipient.Amount)
        }</span>

        <span class="cov0" title="0">accInputTotal := math.ZeroInt()
        // Calculate total amount and prepare outputs
        for _, recipient := range feePayers </span><span class="cov0" title="0">{
                amt := math.LegacyNewDecFromInt(recipient.Amount).Quo(math.LegacyNewDecFromInt(initialTotalAmount))
                amt = amt.MulInt(remainingAmt)

                coins := sdk.NewCoins(sdk.NewCoin(layer.BondDenom, amt.TruncateInt()))
                if !recipient.FromBond </span><span class="cov0" title="0">{
                        accInputTotal = accInputTotal.Add(amt.TruncateInt())
                        outputs = append(outputs, banktypes.NewOutput(sdk.MustAccAddressFromBech32(recipient.PayerAddress), coins))
                }</span> else<span class="cov0" title="0"> {
                        if err := k.ReturnFeetoStake(ctx, recipient.PayerAddress, recipient.BlockNumber, amt.TruncateInt()); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

        }
        // Prepare input
        <span class="cov0" title="0">inputs := banktypes.NewInput(moduleAddress, sdk.NewCoins(sdk.NewCoin(layer.BondDenom, accInputTotal)))

        // Perform the InputOutputCoins operation
        return k.bankKeeper.InputOutputCoins(ctx, inputs, outputs)</span>
}

func (k Keeper) RewardReporterBondToFeePayers(ctx sdk.Context, feePayers []types.PayerInfo, reporterBond math.Int) error <span class="cov0" title="0">{
        totalFeesPaid := math.ZeroInt()
        for _, reporter := range feePayers </span><span class="cov0" title="0">{
                totalFeesPaid = totalFeesPaid.Add(reporter.Amount)
        }</span>
        <span class="cov0" title="0">for _, reporter := range feePayers </span><span class="cov0" title="0">{
                amt := reporter.Amount.Quo(totalFeesPaid).Mul(reporterBond)
                if reporter.FromBond </span><span class="cov0" title="0">{
                        if err := k.reporterKeeper.ReturnSlashedTokens(ctx, reporter.PayerAddress, reporter.BlockNumber, amt); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        if err := k.reporterKeeper.AddAmountToStake(ctx, reporter.PayerAddress, amt); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return k.bankKeeper.SendCoinsFromModuleToModule(ctx, types.ModuleName, stakingtypes.BondedPoolName, sdk.NewCoins(sdk.NewCoin(layer.BondDenom, reporterBond)))</span>
}
func (k Keeper) RewardVoters(ctx sdk.Context, voters []string, totalAmount math.Int) (math.Int, error) <span class="cov0" title="0">{
        if totalAmount.IsZero() </span><span class="cov0" title="0">{
                return totalAmount, nil
        }</span>
        <span class="cov0" title="0">tokenDistribution, burnedRemainder := k.CalculateVoterShare(ctx, voters, totalAmount)
        totalAmount = totalAmount.Sub(burnedRemainder)
        var outputs []banktypes.Output
        for voter, share := range tokenDistribution </span><span class="cov0" title="0">{
                if share.IsZero() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">reward := sdk.NewCoins(sdk.NewCoin(layer.BondDenom, share))
                outputs = append(outputs, banktypes.NewOutput(sdk.MustAccAddressFromBech32(voter), reward))</span>
        }
        <span class="cov0" title="0">moduleAddress := k.accountKeeper.GetModuleAddress(types.ModuleName)
        inputs := banktypes.NewInput(moduleAddress, sdk.NewCoins(sdk.NewCoin(layer.BondDenom, totalAmount)))
        return burnedRemainder, k.bankKeeper.InputOutputCoins(ctx, inputs, outputs)</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package keeper

import (
        "fmt"
        "time"

        "cosmossdk.io/log"
        "cosmossdk.io/store/prefix"
        storetypes "cosmossdk.io/store/types"
        "github.com/cosmos/cosmos-sdk/codec"
        sdk "github.com/cosmos/cosmos-sdk/types"
        paramtypes "github.com/cosmos/cosmos-sdk/x/params/types"

        "github.com/tellor-io/layer/x/dispute/types"
)

const (
        ONE_DAY    = 24 * time.Hour
        TWO_DAYS   = 2 * 24 * time.Hour
        THREE_DAYS = 3 * 24 * time.Hour
)

type (
        Keeper struct {
                cdc        codec.BinaryCodec
                storeKey   storetypes.StoreKey
                memKey     storetypes.StoreKey
                paramstore paramtypes.Subspace

                accountKeeper  types.AccountKeeper
                bankKeeper     types.BankKeeper
                oracleKeeper   types.OracleKeeper
                reporterKeeper types.ReporterKeeper
        }
)

func NewKeeper(
        cdc codec.BinaryCodec,
        storeKey,
        memKey storetypes.StoreKey,
        ps paramtypes.Subspace,

        accountKeeper types.AccountKeeper,
        bankKeeper types.BankKeeper,
        oracleKeeper types.OracleKeeper,
        reporterKeeper types.ReporterKeeper,
) Keeper <span class="cov8" title="1">{
        // set KeyTable if it has not already been set
        if !ps.HasKeyTable() </span><span class="cov8" title="1">{
                ps = ps.WithKeyTable(types.ParamKeyTable())
        }</span>

        <span class="cov8" title="1">return Keeper{
                cdc:        cdc,
                storeKey:   storeKey,
                memKey:     memKey,
                paramstore: ps,

                accountKeeper:  accountKeeper,
                bankKeeper:     bankKeeper,
                oracleKeeper:   oracleKeeper,
                reporterKeeper: reporterKeeper,
        }</span>
}

func (k Keeper) Logger(ctx sdk.Context) log.Logger <span class="cov0" title="0">{
        return ctx.Logger().With("module", fmt.Sprintf("x/%s", types.ModuleName))
}</span>

// Get dispute store
func (k Keeper) disputeStore(ctx sdk.Context) prefix.Store <span class="cov8" title="1">{
        return prefix.NewStore(ctx.KVStore(k.storeKey), types.DisputesKeyPrefix())
}</span>

// Get vote store
func (k Keeper) voteStore(ctx sdk.Context) prefix.Store <span class="cov8" title="1">{
        return prefix.NewStore(ctx.KVStore(k.storeKey), types.VotesKeyPrefix())
}</span>

// Get voter power store
func (k Keeper) voterPowerStore(ctx sdk.Context) prefix.Store <span class="cov8" title="1">{
        return prefix.NewStore(ctx.KVStore(k.storeKey), types.VoterPowerKeyPrefix())
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package keeper

import (
        "github.com/tellor-io/layer/x/dispute/types"
)

type msgServer struct {
        Keeper
}

// NewMsgServerImpl returns an implementation of the MsgServer interface
// for the provided Keeper.
func NewMsgServerImpl(keeper Keeper) types.MsgServer <span class="cov8" title="1">{
        return &amp;msgServer{Keeper: keeper}
}</span>

var _ types.MsgServer = msgServer{}
</pre>
		
		<pre class="file" id="file48" style="display: none">package keeper

import (
        "context"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/dispute/types"
)

func (k msgServer) AddFeeToDispute(goCtx context.Context,
        msg *types.MsgAddFeeToDispute,
) (*types.MsgAddFeeToDisputeResponse, error) <span class="cov0" title="0">{
        ctx := sdk.UnwrapSDKContext(goCtx)

        dispute, err := k.GetDisputeById(ctx, msg.DisputeId)
        if dispute == nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // check if time to add fee has expired
        <span class="cov0" title="0">if ctx.BlockTime().After(dispute.DisputeEndTime) </span><span class="cov0" title="0">{
                return nil, types.ErrDisputeTimeExpired
        }</span>
        // check if fee has been already met
        <span class="cov0" title="0">if dispute.FeeTotal.GTE(dispute.SlashAmount) </span><span class="cov0" title="0">{
                return nil, types.ErrDisputeFeeAlreadyMet
        }</span>
        // Pay fee
        <span class="cov0" title="0">if err := k.Keeper.PayDisputeFee(ctx, msg.Creator, msg.Amount, msg.PayFromBond); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Don't take payment more than slash amount
        <span class="cov0" title="0">fee := dispute.SlashAmount.Sub(dispute.FeeTotal)
        if msg.Amount.Amount.GT(fee) </span><span class="cov0" title="0">{
                msg.Amount.Amount = fee
        }</span>
        <span class="cov0" title="0">dispute.FeePayers = append(dispute.FeePayers, types.PayerInfo{
                PayerAddress: msg.Creator,
                Amount:       msg.Amount.Amount,
                FromBond:     msg.PayFromBond,
                BlockNumber:  ctx.BlockHeight(),
        })
        dispute.FeeTotal = dispute.FeeTotal.Add(msg.Amount.Amount)
        if dispute.FeeTotal.Equal(dispute.SlashAmount) </span><span class="cov0" title="0">{
                if err := k.Keeper.SlashAndJailReporter(ctx, dispute.ReportEvidence, dispute.DisputeCategory); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // begin voting immediately
                <span class="cov0" title="0">dispute.DisputeEndTime = ctx.BlockTime().Add(THREE_DAYS)
                dispute.DisputeStatus = types.Voting
                if err := k.Keeper.SetStartVote(ctx, dispute.DisputeId); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">if err := k.Keeper.SetDisputeById(ctx, dispute.DisputeId, *dispute); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := k.Keeper.SetDisputeByReporter(ctx, *dispute); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;types.MsgAddFeeToDisputeResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package keeper

import (
        "context"

        sdk "github.com/cosmos/cosmos-sdk/types"
        layer "github.com/tellor-io/layer/types"
        "github.com/tellor-io/layer/x/dispute/types"
)

func (k msgServer) ProposeDispute(goCtx context.Context, msg *types.MsgProposeDispute) (*types.MsgProposeDisputeResponse, error) <span class="cov8" title="1">{
        ctx := sdk.UnwrapSDKContext(goCtx)

        if msg.Fee.Denom != layer.BondDenom </span><span class="cov0" title="0">{
                return nil, types.ErrInvalidFeeDenom.Wrapf("wrong fee denom: %s, expected: %s", msg.Fee.Denom, layer.BondDenom)
        }</span>

        <span class="cov8" title="1">if msg.Fee.Amount.LT(layer.OnePercent) </span><span class="cov0" title="0">{
                return nil, types.ErrMinimumTRBrequired.Wrapf("fee %s doesn't meet minimum fee required", msg.Fee.Amount)
        }</span>
        <span class="cov8" title="1">dispute := k.GetDisputeByReporter(ctx, *msg.Report, msg.DisputeCategory)

        if dispute == nil </span><span class="cov8" title="1">{
                // Set New Dispute
                if err := k.Keeper.SetNewDispute(ctx, *msg); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                // Add round to Existing Dispute
                if err := k.Keeper.AddDisputeRound(ctx, *dispute, *msg); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return &amp;types.MsgProposeDisputeResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package keeper

import (
        "context"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/dispute/types"
)

func (k msgServer) Vote(goCtx context.Context, msg *types.MsgVote) (*types.MsgVoteResponse, error) <span class="cov8" title="1">{
        ctx := sdk.UnwrapSDKContext(goCtx)

        dispute, err := k.Keeper.GetDisputeById(ctx, msg.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if dispute.DisputeStatus != types.Voting </span><span class="cov0" title="0">{
                return nil, types.ErrDisputeNotInVotingState
        }</span>

        // Get vote by disputeId
        <span class="cov8" title="1">vote, err := k.Keeper.GetVote(ctx, msg.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if vote.VoteStart.IsZero() </span><span class="cov0" title="0">{
                return nil, types.ErrVoteDoesNotExist
        }</span>

        // Check if voter has already voted
        <span class="cov8" title="1">voter, err := k.Keeper.GetVoterVote(ctx, msg.Voter, msg.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if voter.Voter != "" </span><span class="cov8" title="1">{
                return nil, types.ErrVoterHasAlreadyVoted
        }</span>

        // Assert again voting hasn't ended
        <span class="cov8" title="1">if vote.VoteEnd.Before(ctx.BlockTime()) </span><span class="cov0" title="0">{
                return nil, types.ErrVotingPeriodEnded
        }</span>

        <span class="cov8" title="1">err = k.Keeper.SetTally(ctx, msg.Id, msg.Vote, msg.Voter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = k.Keeper.SetVoterVote(ctx, msg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = k.Keeper.AppendVoters(ctx, msg.Id, msg.Voter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;types.MsgVoteResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package keeper

import (
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/dispute/types"
)

// GetParams get all parameters as types.Params
func (k Keeper) GetParams(ctx sdk.Context) types.Params <span class="cov8" title="1">{
        return types.NewParams()
}</span>

// SetParams set the params
func (k Keeper) SetParams(ctx sdk.Context, params types.Params) <span class="cov8" title="1">{
        k.paramstore.SetParamSet(ctx, &amp;params)
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package keeper

import (
        "context"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/dispute/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Keeper) Params(goCtx context.Context, req *types.QueryParamsRequest) (*types.QueryParamsResponse, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>
        <span class="cov8" title="1">ctx := sdk.UnwrapSDKContext(goCtx)

        return &amp;types.QueryParamsResponse{Params: k.GetParams(ctx)}, nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package keeper

import (
        "errors"
        "fmt"
        "math/big"

        "cosmossdk.io/math"
        sdk "github.com/cosmos/cosmos-sdk/types"
        layer "github.com/tellor-io/layer/types"
        layertypes "github.com/tellor-io/layer/types"
        "github.com/tellor-io/layer/x/dispute/types"
        reptypes "github.com/tellor-io/layer/x/reporter/types"
)

// Add invalid vote type and return all fees to the paying parties
func (k Keeper) TallyVote(ctx sdk.Context, id uint64) error <span class="cov0" title="0">{
        dispute, err := k.GetDisputeById(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">tally, err := k.GetTally(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">vote, err := k.GetVote(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">tokenHolderVoteSum := tally.ForVotes.TokenHolders.Add(tally.AgainstVotes.TokenHolders).Add(tally.Invalid.TokenHolders)
        validatorVoteSum := tally.ForVotes.Validators.Add(tally.AgainstVotes.Validators).Add(tally.Invalid.Validators)
        userVoteSum := tally.ForVotes.Users.Add(tally.AgainstVotes.Users).Add(tally.Invalid.Users)
        teamVoteSum := tally.ForVotes.Team.Add(tally.AgainstVotes.Team).Add(tally.Invalid.Team)

        // Prevent zero-division
        if tokenHolderVoteSum.IsZero() </span><span class="cov0" title="0">{
                tokenHolderVoteSum = math.NewInt(1)
        }</span>
        <span class="cov0" title="0">if validatorVoteSum.IsZero() </span><span class="cov0" title="0">{
                validatorVoteSum = math.NewInt(1)
        }</span>
        <span class="cov0" title="0">if userVoteSum.IsZero() </span><span class="cov0" title="0">{
                userVoteSum = math.NewInt(1)
        }</span>
        <span class="cov0" title="0">if teamVoteSum.IsZero() </span><span class="cov0" title="0">{
                teamVoteSum = math.NewInt(1)
        }</span>

        // Convert to Dec for precision
        <span class="cov0" title="0">tokenHolderVoteSumDec := math.LegacyNewDecFromInt(tokenHolderVoteSum)
        validatorVoteSumDec := math.LegacyNewDecFromInt(validatorVoteSum)
        userVoteSumDec := math.LegacyNewDecFromInt(userVoteSum)
        teamVoteSumDec := math.LegacyNewDecFromInt(teamVoteSum)

        // Normalize the votes for each group
        forTokenHolders := math.LegacyNewDecFromInt(tally.ForVotes.TokenHolders).Quo(tokenHolderVoteSumDec)
        forValidators := math.LegacyNewDecFromInt(tally.ForVotes.Validators).Quo(validatorVoteSumDec)
        forUsers := math.LegacyNewDecFromInt(tally.ForVotes.Users).Quo(userVoteSumDec)
        forTeam := math.LegacyNewDecFromInt(tally.ForVotes.Team).Quo(teamVoteSumDec)

        againstTokenHolders := math.LegacyNewDecFromInt(tally.AgainstVotes.TokenHolders).Quo(tokenHolderVoteSumDec)
        againstValidators := math.LegacyNewDecFromInt(tally.AgainstVotes.Validators).Quo(validatorVoteSumDec)
        againstUsers := math.LegacyNewDecFromInt(tally.AgainstVotes.Users).Quo(userVoteSumDec)
        againstTeam := math.LegacyNewDecFromInt(tally.AgainstVotes.Team).Quo(teamVoteSumDec)

        invalidTokenHolders := math.LegacyNewDecFromInt(tally.Invalid.TokenHolders).Quo(tokenHolderVoteSumDec)
        invalidValidators := math.LegacyNewDecFromInt(tally.Invalid.Validators).Quo(validatorVoteSumDec)
        invalidUsers := math.LegacyNewDecFromInt(tally.Invalid.Users).Quo(userVoteSumDec)
        invalidTeam := math.LegacyNewDecFromInt(tally.Invalid.Team).Quo(teamVoteSumDec)

        // Sum the normalized votes and divide by number of groups to scale between 0 and 1
        numGroups := math.LegacyNewDec(4)
        scaledSupport := (forTokenHolders.Add(forValidators).Add(forUsers).Add(forTeam)).Quo(numGroups)
        scaledAgainst := (againstTokenHolders.Add(againstValidators).Add(againstUsers).Add(againstTeam)).Quo(numGroups)
        scaledInvalid := (invalidTokenHolders.Add(invalidValidators).Add(invalidUsers).Add(invalidTeam)).Quo(numGroups)

        tokenHolderRatio := ratio(k.GetTotalSupply(ctx), tokenHolderVoteSum)
        totalPower, err := k.GetTotalReporterPower(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">validatorRatio := ratio(totalPower, validatorVoteSum)
        totalTips, _ := k.GetTotalTips(ctx) // TODO: handle err
        userRatio := ratio(totalTips, userVoteSum)
        teamRatio := ratio(math.NewInt(1), teamVoteSum)
        totalRatio := tokenHolderRatio.Add(validatorRatio).Add(userRatio).Add(teamRatio)

        if vote.VoteResult == types.VoteResult_NO_TALLY </span><span class="cov0" title="0">{
                // quorum reached case
                if totalRatio.GTE(math.LegacyNewDec(51)) </span><span class="cov0" title="0">{
                        fmt.Println("quorum reached")
                        switch </span>{
                        case scaledSupport.GT(scaledAgainst) &amp;&amp; scaledSupport.GT(scaledInvalid):<span class="cov0" title="0">
                                if err := k.SetDisputeStatus(ctx, id, types.Resolved); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if err := k.SetVoteResult(ctx, id, types.VoteResult_SUPPORT); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        case scaledAgainst.GT(scaledSupport) &amp;&amp; scaledAgainst.GT(scaledInvalid):<span class="cov0" title="0">
                                if err := k.SetDisputeStatus(ctx, id, types.Resolved); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if err := k.SetVoteResult(ctx, id, types.VoteResult_AGAINST); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        case scaledInvalid.GT(scaledSupport) &amp;&amp; scaledInvalid.GT(scaledAgainst):<span class="cov0" title="0">
                                if err := k.SetDisputeStatus(ctx, id, types.Resolved); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if err := k.SetVoteResult(ctx, id, types.VoteResult_INVALID); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        default:<span class="cov0" title="0"></span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }
                // quorum not reached case
                <span class="cov0" title="0">if vote.VoteEnd.Before(ctx.BlockTime()) </span><span class="cov0" title="0">{
                        disputeStatus := types.Unresolved
                        // check if rounds have been exhausted or dispute has expired in order to disperse funds
                        if dispute.DisputeEndTime.Before(ctx.BlockTime()) </span><span class="cov0" title="0">{
                                disputeStatus = types.Resolved
                        }</span>
                        <span class="cov0" title="0">switch </span>{
                        case scaledSupport.GT(scaledAgainst) &amp;&amp; scaledSupport.GT(scaledInvalid):<span class="cov0" title="0">
                                if err := k.SetDisputeStatus(ctx, id, disputeStatus); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if err := k.SetVoteResult(ctx, id, types.VoteResult_NO_QUORUM_MAJORITY_SUPPORT); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        case scaledAgainst.GT(scaledSupport) &amp;&amp; scaledAgainst.GT(scaledInvalid):<span class="cov0" title="0">
                                if err := k.SetDisputeStatus(ctx, id, disputeStatus); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if err := k.SetVoteResult(ctx, id, types.VoteResult_NO_QUORUM_MAJORITY_AGAINST); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        case scaledInvalid.GT(scaledSupport) &amp;&amp; scaledInvalid.GT(scaledAgainst):<span class="cov0" title="0">
                                if err := k.SetDisputeStatus(ctx, id, disputeStatus); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if err := k.SetVoteResult(ctx, id, types.VoteResult_NO_QUORUM_MAJORITY_INVALID); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        case len(vote.Voters) == 0:<span class="cov0" title="0">
                                if err := k.SetDisputeStatus(ctx, id, disputeStatus); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if err := k.SetVoteResult(ctx, id, types.VoteResult_NO_QUORUM_MAJORITY_INVALID); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        default:<span class="cov0" title="0">
                                return errors.New("no quorum majority")</span> // TODO: log only?
                        }
                        <span class="cov0" title="0">return nil</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (k Keeper) GetTally(ctx sdk.Context, id uint64) (*types.Tally, error) <span class="cov8" title="1">{
        store := k.voteStore(ctx)
        tallyBytes := store.Get(types.TallyKeyPrefix(id))
        var tallies types.Tally
        if err := k.cdc.Unmarshal(tallyBytes, &amp;tallies); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // for some reason the proto files don't initialize the tallies when nullable = false
        <span class="cov8" title="1">if tallies.ForVotes == nil </span><span class="cov8" title="1">{
                tallies.ForVotes = k.initVoterClasses()
                tallies.AgainstVotes = k.initVoterClasses()
                tallies.Invalid = k.initVoterClasses()
        }</span>

        <span class="cov8" title="1">return &amp;tallies, nil</span>
}

// Set tally numbers
func (k Keeper) SetTally(ctx sdk.Context, id uint64, voteFor types.VoteEnum, voter string) error <span class="cov8" title="1">{
        tallies, err := k.GetTally(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">valP, err := k.GetReporterPower(ctx, voter)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tkHol, err := k.GetAccountBalance(ctx, voter)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">usrTps, err := k.GetUserTips(ctx, voter)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">team := k.IsTeamAddress(ctx, voter)

        voterPower := math.ZeroInt()
        tp, err := k.GetTotalReporterPower(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">voterPower = voterPower.Add(calculateVotingPower(valP, tp))
        voterPower = voterPower.Add(calculateVotingPower(tkHol, k.GetTotalSupply(ctx)))

        totalTips, err := k.GetTotalTips(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">voterPower = voterPower.Add(calculateVotingPower(usrTps, totalTips))
        voterPower = voterPower.Add(calculateVotingPower(team, math.NewInt(1)))

        switch voteFor </span>{
        case types.VoteEnum_VOTE_SUPPORT:<span class="cov8" title="1">
                tallies.ForVotes.Validators = tallies.ForVotes.Validators.Add(valP)
                tallies.ForVotes.TokenHolders = tallies.ForVotes.TokenHolders.Add(tkHol)
                tallies.ForVotes.Users = tallies.ForVotes.Users.Add(usrTps)
                tallies.ForVotes.Team = tallies.ForVotes.Team.Add(team)</span>
        case types.VoteEnum_VOTE_AGAINST:<span class="cov0" title="0">
                tallies.AgainstVotes.Validators = tallies.AgainstVotes.Validators.Add(valP)
                tallies.AgainstVotes.TokenHolders = tallies.AgainstVotes.TokenHolders.Add(tkHol)
                tallies.AgainstVotes.Users = tallies.AgainstVotes.Users.Add(usrTps)
                tallies.AgainstVotes.Team = tallies.AgainstVotes.Team.Add(team)</span>
        case types.VoteEnum_VOTE_INVALID:<span class="cov0" title="0">
                tallies.Invalid.Validators = tallies.Invalid.Validators.Add(valP)
                tallies.Invalid.TokenHolders = tallies.Invalid.TokenHolders.Add(tkHol)
                tallies.Invalid.Users = tallies.Invalid.Users.Add(usrTps)
                tallies.Invalid.Team = tallies.Invalid.Team.Add(team)</span>
        default:<span class="cov0" title="0">
                return errors.New("invalid vote type")</span>
        }

        <span class="cov8" title="1">k.SetVoterTally(ctx, id, tallies)
        k.SetVoterPower(ctx, sdk.MustAccAddressFromBech32(voter), voterPower)
        return nil</span>
}

func (k Keeper) GetReporterPower(ctx sdk.Context, voter string) (math.Int, error) <span class="cov8" title="1">{
        reporterAddr, err := sdk.AccAddressFromBech32(voter)
        if err != nil </span><span class="cov0" title="0">{
                return math.Int{}, err
        }</span>
        <span class="cov8" title="1">reporter, err := k.reporterKeeper.Reporter(ctx, reporterAddr)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, reptypes.ErrReporterDoesNotExist) </span><span class="cov0" title="0">{
                        return math.ZeroInt(), nil
                }</span>
                <span class="cov0" title="0">return math.Int{}, err</span>
        }
        <span class="cov8" title="1">return reporter.TotalTokens.Quo(layertypes.PowerReduction), nil</span>
}

func (k Keeper) GetAccountBalance(ctx sdk.Context, voter string) (math.Int, error) <span class="cov8" title="1">{
        addr, err := sdk.AccAddressFromBech32(voter)
        if err != nil </span><span class="cov0" title="0">{
                return math.Int{}, err
        }</span>
        <span class="cov8" title="1">bal := k.bankKeeper.GetBalance(ctx, addr, layer.BondDenom)
        return bal.Amount, nil</span>
}

func (k Keeper) GetUserTips(ctx sdk.Context, voter string) (math.Int, error) <span class="cov8" title="1">{
        voterAddr, err := sdk.AccAddressFromBech32(voter)
        if err != nil </span><span class="cov0" title="0">{
                return math.Int{}, err
        }</span>
        <span class="cov8" title="1">userTips, err := k.oracleKeeper.GetUserTips(ctx, voterAddr)
        if err != nil </span><span class="cov0" title="0">{
                return math.Int{}, err
        }</span>
        <span class="cov8" title="1">return userTips.Total, nil</span>
}

func (k Keeper) IsTeamAddress(ctx sdk.Context, voter string) math.Int <span class="cov8" title="1">{
        if voter != types.TeamAddress </span><span class="cov8" title="1">{
                return math.ZeroInt()
        }</span>
        <span class="cov0" title="0">return math.NewInt(1)</span>
}

// Get total trb supply
func (k Keeper) GetTotalSupply(ctx sdk.Context) math.Int <span class="cov8" title="1">{
        return k.bankKeeper.GetSupply(ctx, layer.BondDenom).Amount
}</span>

// Get total reporter power
func (k Keeper) GetTotalReporterPower(ctx sdk.Context) (math.Int, error) <span class="cov8" title="1">{
        tp, err := k.reporterKeeper.TotalReporterPower(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return math.Int{}, err
        }</span>
        <span class="cov8" title="1">return tp, nil</span>
}

// Get total number of tips
func (k Keeper) GetTotalTips(ctx sdk.Context) (math.Int, error) <span class="cov8" title="1">{
        return k.oracleKeeper.GetTotalTips(ctx)
}</span>

func (k Keeper) SetVoterTally(ctx sdk.Context, id uint64, tally *types.Tally) <span class="cov8" title="1">{
        voteStore := k.voteStore(ctx)
        voteStore.Set(types.TallyKeyPrefix(id), k.cdc.MustMarshal(tally))
}</span>

func (k Keeper) SetVoterPower(ctx sdk.Context, voter sdk.AccAddress, vp math.Int) <span class="cov8" title="1">{
        store := k.voterPowerStore(ctx)
        store.Set(voter, vp.BigInt().Bytes())
}</span>

func (k Keeper) GetVoterPower(ctx sdk.Context, voter sdk.AccAddress) math.Int <span class="cov0" title="0">{
        store := k.voterPowerStore(ctx)
        vpBytes := store.Get(voter)
        if vpBytes == nil </span><span class="cov0" title="0">{
                return math.ZeroInt()
        }</span>
        <span class="cov0" title="0">return math.NewIntFromBigInt(new(big.Int).SetBytes(vpBytes))</span>
}

func ratio(total, part math.Int) math.LegacyDec <span class="cov0" title="0">{
        if total.IsZero() </span><span class="cov0" title="0">{
                return math.LegacyZeroDec()
        }</span>
        <span class="cov0" title="0">total = total.MulRaw(4)
        ratio := math.LegacyNewDecFromInt(part).Quo(math.LegacyNewDecFromInt(total))
        return ratio.MulInt64(100)</span>
}

func calculateVotingPower(n, d math.Int) math.Int <span class="cov8" title="1">{
        if n.IsZero() || d.IsZero() </span><span class="cov8" title="1">{
                return math.ZeroInt()
        }</span>
        <span class="cov8" title="1">scalingFactor := math.NewInt(1_000_000)
        return n.Mul(scalingFactor).Quo(d).MulRaw(25_000_000).Quo(scalingFactor)</span>
}

func (k Keeper) CalculateVoterShare(ctx sdk.Context, voters []string, totalTokens math.Int) (map[string]math.Int, math.Int) <span class="cov0" title="0">{
        // remove duplicates from voters list
        seen := make(map[string]bool)
        var uniqueVoters []string
        for _, voter := range voters </span><span class="cov0" title="0">{
                if !seen[voter] </span><span class="cov0" title="0">{
                        seen[voter] = true
                        uniqueVoters = append(uniqueVoters, voter)
                }</span>
        }
        <span class="cov0" title="0">totalPower := math.ZeroInt()
        powers := make(map[string]math.Int)
        for _, voter := range uniqueVoters </span><span class="cov0" title="0">{
                voterShare := k.GetVoterPower(ctx, sdk.MustAccAddressFromBech32(voter))
                totalPower = totalPower.Add(voterShare)
                powers[voter] = voterShare
        }</span>

        // Calculate and allocate tokens based on each person's share of the total power
        <span class="cov0" title="0">tokenDistribution := make(map[string]math.Int)
        scalingFactor := layertypes.PowerReduction
        totalShare := math.ZeroInt()
        for voter, power := range powers </span><span class="cov0" title="0">{
                share := power.Mul(scalingFactor).Quo(totalPower)
                tokens := share.Mul(totalTokens).Quo(scalingFactor)
                tokenDistribution[voter] = tokens
                totalShare = totalShare.Add(tokens)
        }</span>
        <span class="cov0" title="0">burnedRemainder := math.ZeroInt()
        if totalTokens.GT(totalShare) </span><span class="cov0" title="0">{
                burnedRemainder = totalTokens.Sub(totalShare)
        }</span>

        <span class="cov0" title="0">return tokenDistribution, burnedRemainder</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package keeper

import (
        "cosmossdk.io/math"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/dispute/types"
)

// Get vote by dispute id
func (k Keeper) GetVote(ctx sdk.Context, id uint64) (*types.Vote, error) <span class="cov8" title="1">{
        store := k.voteStore(ctx)
        voteBytes := store.Get(types.DisputeIdBytes(id))
        var vote types.Vote
        if err := k.cdc.Unmarshal(voteBytes, &amp;vote); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;vote, nil</span>
}

// Get a voter's vote by voter &amp; dispute id
func (k Keeper) GetVoterVote(ctx sdk.Context, voter string, id uint64) (*types.MsgVote, error) <span class="cov8" title="1">{
        store := k.voteStore(ctx)
        voteBytes := store.Get(types.VoterKeyPrefix(voter, id))
        var vote types.MsgVote
        if err := k.cdc.Unmarshal(voteBytes, &amp;vote); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;vote, nil</span>
}

// Set vote by voter
func (k Keeper) SetVoterVote(ctx sdk.Context, msg *types.MsgVote) error <span class="cov8" title="1">{
        store := k.voteStore(ctx)
        voterKey := types.VoterKeyPrefix(msg.Voter, msg.Id)
        bz, err := k.cdc.Marshal(msg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">store.Set(voterKey, bz)
        return nil</span>
}

// Append voters to vote struct
func (k Keeper) AppendVoters(ctx sdk.Context, id uint64, voter string) error <span class="cov8" title="1">{
        vote, err := k.GetVote(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">vote.Voters = append(vote.Voters, voter)

        return k.SetVote(ctx, id, vote)</span>
}

func (k Keeper) initVoterClasses() *types.VoterClasses <span class="cov8" title="1">{
        return &amp;types.VoterClasses{
                Validators:   math.ZeroInt(),
                TokenHolders: math.ZeroInt(),
                Users:        math.ZeroInt(),
                Team:         math.ZeroInt(),
        }
}</span>

func (k Keeper) SetVote(ctx sdk.Context, id uint64, vote *types.Vote) error <span class="cov8" title="1">{
        store := k.voteStore(ctx)
        bz, err := k.cdc.Marshal(vote)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">store.Set(types.DisputeIdBytes(id), bz)
        return nil</span>
}

// Set vote results
func (k Keeper) SetVoteResult(ctx sdk.Context, id uint64, result types.VoteResult) error <span class="cov0" title="0">{
        vote, err := k.GetVote(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">vote.VoteResult = result
        vote.VoteEnd = ctx.BlockTime()

        return k.SetVote(ctx, id, vote)</span>
}

// Set vote start info for a dispute
func (k Keeper) SetStartVote(ctx sdk.Context, id uint64) error <span class="cov8" title="1">{
        store := k.voteStore(ctx)
        vote := types.Vote{
                Id:        id,
                VoteStart: ctx.BlockTime(),
                VoteEnd:   ctx.BlockTime().Add(TWO_DAYS),
        }
        bz, err := k.cdc.Marshal(&amp;vote)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">store.Set(types.DisputeIdBytes(id), bz)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package dispute

import (
        "context"
        "encoding/json"
        "fmt"

        // this line is used by starport scaffolding # 1
        "cosmossdk.io/core/appmodule"
        "cosmossdk.io/depinject"
        storetypes "cosmossdk.io/store/types"
        paramtypes "github.com/cosmos/cosmos-sdk/x/params/types"
        "github.com/grpc-ecosystem/grpc-gateway/runtime"
        "github.com/spf13/cobra"

        abci "github.com/cometbft/cometbft/abci/types"

        "github.com/cosmos/cosmos-sdk/client"
        "github.com/cosmos/cosmos-sdk/codec"
        cdctypes "github.com/cosmos/cosmos-sdk/codec/types"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/module"
        disputemodulev1 "github.com/tellor-io/layer/api/layer/dispute/module"
        "github.com/tellor-io/layer/x/dispute/client/cli"
        "github.com/tellor-io/layer/x/dispute/keeper"
        "github.com/tellor-io/layer/x/dispute/types"
)

var (
        _ module.AppModule      = AppModule{}
        _ module.AppModuleBasic = AppModuleBasic{}
)

// ----------------------------------------------------------------------------
// AppModuleBasic
// ----------------------------------------------------------------------------

// AppModuleBasic implements the AppModuleBasic interface that defines the independent methods a Cosmos SDK module needs to implement.
type AppModuleBasic struct {
        cdc codec.BinaryCodec
}

// IsOnePerModuleType implements the depinject.OnePerModuleType interface.
func (AppModuleBasic) IsOnePerModuleType() {<span class="cov0" title="0">}</span>

// IsAppModule implements the appmodule.AppModule interface.
func (AppModuleBasic) IsAppModule() {<span class="cov0" title="0">}</span>

func NewAppModuleBasic(cdc codec.BinaryCodec) AppModuleBasic <span class="cov0" title="0">{
        return AppModuleBasic{cdc: cdc}
}</span>

// Name returns the name of the module as a string
func (AppModuleBasic) Name() string <span class="cov0" title="0">{
        return types.ModuleName
}</span>

// RegisterLegacyAminoCodec registers the amino codec for the module, which is used to marshal and unmarshal structs to/from []byte in order to persist them in the module's KVStore
func (AppModuleBasic) RegisterLegacyAminoCodec(cdc *codec.LegacyAmino) <span class="cov0" title="0">{
        types.RegisterCodec(cdc)
}</span>

// RegisterInterfaces registers a module's interface types and their concrete implementations as proto.Message
func (a AppModuleBasic) RegisterInterfaces(reg cdctypes.InterfaceRegistry) <span class="cov0" title="0">{
        types.RegisterInterfaces(reg)
}</span>

// DefaultGenesis returns a default GenesisState for the module, marshalled to json.RawMessage. The default GenesisState need to be defined by the module developer and is primarily used for testing
func (AppModuleBasic) DefaultGenesis(cdc codec.JSONCodec) json.RawMessage <span class="cov0" title="0">{
        return cdc.MustMarshalJSON(types.DefaultGenesis())
}</span>

// ValidateGenesis used to validate the GenesisState, given in its json.RawMessage form
func (AppModuleBasic) ValidateGenesis(cdc codec.JSONCodec, config client.TxEncodingConfig, bz json.RawMessage) error <span class="cov0" title="0">{
        var genState types.GenesisState
        if err := cdc.UnmarshalJSON(bz, &amp;genState); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal %s genesis state: %w", types.ModuleName, err)
        }</span>
        <span class="cov0" title="0">return genState.Validate()</span>
}

// RegisterGRPCGatewayRoutes registers the gRPC Gateway routes for the module
func (AppModuleBasic) RegisterGRPCGatewayRoutes(clientCtx client.Context, mux *runtime.ServeMux) <span class="cov0" title="0">{
        types.RegisterQueryHandlerClient(context.Background(), mux, types.NewQueryClient(clientCtx))
}</span>

// GetTxCmd returns the root Tx command for the module. The subcommands of this root command are used by end-users to generate new transactions containing messages defined in the module
func (a AppModuleBasic) GetTxCmd() *cobra.Command <span class="cov0" title="0">{
        return cli.GetTxCmd()
}</span>

// GetQueryCmd returns the root query command for the module. The subcommands of this root command are used by end-users to generate new queries to the subset of the state defined by the module
func (AppModuleBasic) GetQueryCmd() *cobra.Command <span class="cov0" title="0">{
        return cli.GetQueryCmd(types.StoreKey)
}</span>

// ----------------------------------------------------------------------------
// AppModule
// ----------------------------------------------------------------------------

// AppModule implements the AppModule interface that defines the inter-dependent methods that modules need to implement
type AppModule struct {
        AppModuleBasic

        keeper        keeper.Keeper
        accountKeeper types.AccountKeeper
        bankKeeper    types.BankKeeper
}

func NewAppModule(
        cdc codec.Codec,
        keeper keeper.Keeper,
        accountKeeper types.AccountKeeper,
        bankKeeper types.BankKeeper,
) AppModule <span class="cov0" title="0">{
        return AppModule{
                AppModuleBasic: NewAppModuleBasic(cdc),
                keeper:         keeper,
                accountKeeper:  accountKeeper,
                bankKeeper:     bankKeeper,
        }
}</span>

// RegisterServices registers a gRPC query service to respond to the module-specific gRPC queries
func (am AppModule) RegisterServices(cfg module.Configurator) <span class="cov0" title="0">{
        types.RegisterMsgServer(cfg.MsgServer(), keeper.NewMsgServerImpl(am.keeper))
        types.RegisterQueryServer(cfg.QueryServer(), am.keeper)
}</span>

// RegisterInvariants registers the invariants of the module. If an invariant deviates from its predicted value, the InvariantRegistry triggers appropriate logic (most often the chain will be halted)
func (am AppModule) RegisterInvariants(_ sdk.InvariantRegistry) {<span class="cov0" title="0">}</span>

// InitGenesis performs the module's genesis initialization. It returns no validator updates.
func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, gs json.RawMessage) []abci.ValidatorUpdate <span class="cov0" title="0">{
        var genState types.GenesisState
        // Initialize global index to index in genesis state
        cdc.MustUnmarshalJSON(gs, &amp;genState)

        InitGenesis(ctx, am.keeper, genState)

        return []abci.ValidatorUpdate{}
}</span>

// ExportGenesis returns the module's exported genesis state as raw JSON bytes.
func (am AppModule) ExportGenesis(ctx sdk.Context, cdc codec.JSONCodec) json.RawMessage <span class="cov0" title="0">{
        genState := ExportGenesis(ctx, am.keeper)
        return cdc.MustMarshalJSON(genState)
}</span>

// ConsensusVersion is a sequence number for state-breaking change of the module. It should be incremented on each consensus-breaking change introduced by the module. To avoid wrong/empty versions, the initial version should be set to 1
func (AppModule) ConsensusVersion() uint64 <span class="cov0" title="0">{ return 1 }</span>

// BeginBlock contains the logic that is automatically triggered at the beginning of each block
func (am AppModule) BeginBlock(ctx context.Context) error <span class="cov0" title="0">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)
        ids, err := am.keeper.CheckPrevoteDisputesForExpiration(sdkCtx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = am.keeper.Tally(sdkCtx, ids)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return am.keeper.ExecuteVotes(sdkCtx, ids)</span>
}

// ----------------------------------------------------------------------------
// App Wiring Setup
// ----------------------------------------------------------------------------

func init() <span class="cov8" title="1">{
        appmodule.Register(&amp;disputemodulev1.Module{},
                appmodule.Provide(ProvideModule))
}</span>

type DisputeInputs struct {
        depinject.In

        KvStoreKey  *storetypes.KVStoreKey
        MemStoreKey *storetypes.MemoryStoreKey
        Cdc         codec.Codec
        Config      *disputemodulev1.Module

        AccountKeeper  types.AccountKeeper
        BankKeeper     types.BankKeeper
        OracleKeeper   types.OracleKeeper
        ReporterKeeper types.ReporterKeeper
}

type DisputeOutputs struct {
        depinject.Out

        DisputeKeeper keeper.Keeper
        Module        appmodule.AppModule
}

func ProvideModule(in DisputeInputs) DisputeOutputs <span class="cov0" title="0">{
        k := keeper.NewKeeper(
                in.Cdc,
                in.KvStoreKey,
                in.MemStoreKey,
                paramtypes.Subspace{},
                in.AccountKeeper,
                in.BankKeeper,
                in.OracleKeeper,
                in.ReporterKeeper,
        )
        m := NewAppModule(
                in.Cdc,
                k,
                in.AccountKeeper,
                in.BankKeeper,
        )

        return DisputeOutputs{DisputeKeeper: k, Module: m}
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package dispute

import (
        "math/rand"

        "github.com/cosmos/cosmos-sdk/baseapp"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/module"
        simtypes "github.com/cosmos/cosmos-sdk/types/simulation"
        "github.com/cosmos/cosmos-sdk/x/simulation"
        "github.com/tellor-io/layer/testutil/sample"
        disputesimulation "github.com/tellor-io/layer/x/dispute/simulation"
        "github.com/tellor-io/layer/x/dispute/types"
)

// avoid unused import issue
var (
        _ = sample.AccAddress
        _ = disputesimulation.FindAccount
        _ = simulation.MsgEntryKind
        _ = baseapp.Paramspace
        _ = rand.Rand{}
)

const (
        opWeightMsgProposeDispute = "op_weight_msg_propose_dispute"
        // TODO: Determine the simulation weight value
        defaultWeightMsgProposeDispute int = 100

        opWeightMsgAddFeeToDispute = "op_weight_msg_add_fee_to_dispute"
        // TODO: Determine the simulation weight value
        defaultWeightMsgAddFeeToDispute int = 100

        opWeightMsgVote = "op_weight_msg_vote"
        // TODO: Determine the simulation weight value
        defaultWeightMsgVote int = 100

        // this line is used by starport scaffolding # simapp/module/const
)

// GenerateGenesisState creates a randomized GenState of the module.
func (AppModule) GenerateGenesisState(simState *module.SimulationState) <span class="cov0" title="0">{
        accs := make([]string, len(simState.Accounts))
        for i, acc := range simState.Accounts </span><span class="cov0" title="0">{
                accs[i] = acc.Address.String()
        }</span>
        <span class="cov0" title="0">disputeGenesis := types.GenesisState{
                Params: types.DefaultParams(),
                // this line is used by starport scaffolding # simapp/module/genesisState
        }
        simState.GenState[types.ModuleName] = simState.Cdc.MustMarshalJSON(&amp;disputeGenesis)</span>
}

// RegisterStoreDecoder registers a decoder.
func (am AppModule) RegisterStoreDecoder(_ simtypes.StoreDecoderRegistry) {<span class="cov0" title="0">}</span>

// ProposalContents doesn't return any content functions for governance proposals.
func (AppModule) ProposalContents(_ module.SimulationState) []simtypes.WeightedProposalContent <span class="cov0" title="0">{
        return nil
}</span>

// WeightedOperations returns the all the gov module operations with their respective weights.
func (am AppModule) WeightedOperations(simState module.SimulationState) []simtypes.WeightedOperation <span class="cov0" title="0">{
        operations := make([]simtypes.WeightedOperation, 0)

        var weightMsgProposeDispute int
        simState.AppParams.GetOrGenerate(opWeightMsgProposeDispute, &amp;weightMsgProposeDispute, nil,
                func(_ *rand.Rand) </span><span class="cov0" title="0">{
                        weightMsgProposeDispute = defaultWeightMsgProposeDispute
                }</span>,
        )
        <span class="cov0" title="0">operations = append(operations, simulation.NewWeightedOperation(
                weightMsgProposeDispute,
                disputesimulation.SimulateMsgProposeDispute(am.accountKeeper, am.bankKeeper, am.keeper),
        ))

        var weightMsgAddFeeToDispute int
        simState.AppParams.GetOrGenerate(opWeightMsgAddFeeToDispute, &amp;weightMsgAddFeeToDispute, nil,
                func(_ *rand.Rand) </span><span class="cov0" title="0">{
                        weightMsgAddFeeToDispute = defaultWeightMsgAddFeeToDispute
                }</span>,
        )
        <span class="cov0" title="0">operations = append(operations, simulation.NewWeightedOperation(
                weightMsgAddFeeToDispute,
                disputesimulation.SimulateMsgAddFeeToDispute(am.accountKeeper, am.bankKeeper, am.keeper),
        ))

        var weightMsgVote int
        simState.AppParams.GetOrGenerate(opWeightMsgVote, &amp;weightMsgVote, nil,
                func(_ *rand.Rand) </span><span class="cov0" title="0">{
                        weightMsgVote = defaultWeightMsgVote
                }</span>,
        )
        <span class="cov0" title="0">operations = append(operations, simulation.NewWeightedOperation(
                weightMsgVote,
                disputesimulation.SimulateMsgVote(am.accountKeeper, am.bankKeeper, am.keeper),
        ))

        // this line is used by starport scaffolding # simapp/module/operation

        return operations</span>
}

// ProposalMsgs returns msgs used for governance proposals for simulations.
func (am AppModule) ProposalMsgs(simState module.SimulationState) []simtypes.WeightedProposalMsg <span class="cov0" title="0">{
        return []simtypes.WeightedProposalMsg{
                simulation.NewWeightedProposalMsg(
                        opWeightMsgProposeDispute,
                        defaultWeightMsgProposeDispute,
                        func(r *rand.Rand, ctx sdk.Context, accs []simtypes.Account) sdk.Msg </span><span class="cov0" title="0">{
                                disputesimulation.SimulateMsgProposeDispute(am.accountKeeper, am.bankKeeper, am.keeper)
                                return nil
                        }</span>,
                ),
                simulation.NewWeightedProposalMsg(
                        opWeightMsgAddFeeToDispute,
                        defaultWeightMsgAddFeeToDispute,
                        func(r *rand.Rand, ctx sdk.Context, accs []simtypes.Account) sdk.Msg <span class="cov0" title="0">{
                                disputesimulation.SimulateMsgAddFeeToDispute(am.accountKeeper, am.bankKeeper, am.keeper)
                                return nil
                        }</span>,
                ),
                simulation.NewWeightedProposalMsg(
                        opWeightMsgVote,
                        defaultWeightMsgVote,
                        func(r *rand.Rand, ctx sdk.Context, accs []simtypes.Account) sdk.Msg <span class="cov0" title="0">{
                                disputesimulation.SimulateMsgVote(am.accountKeeper, am.bankKeeper, am.keeper)
                                return nil
                        }</span>,
                ),
                // this line is used by starport scaffolding # simapp/module/OpMsg
        }
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package types

import (
        "github.com/cosmos/cosmos-sdk/codec"
        cdctypes "github.com/cosmos/cosmos-sdk/codec/types"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/msgservice"
)

func RegisterCodec(cdc *codec.LegacyAmino) <span class="cov0" title="0">{
        cdc.RegisterConcrete(&amp;MsgProposeDispute{}, "dispute/ProposeDispute", nil)
        cdc.RegisterConcrete(&amp;MsgAddFeeToDispute{}, "dispute/AddFeeToDispute", nil)
        cdc.RegisterConcrete(&amp;MsgVote{}, "dispute/Vote", nil)
        // this line is used by starport scaffolding # 2
}</span>

func RegisterInterfaces(registry cdctypes.InterfaceRegistry) <span class="cov0" title="0">{
        registry.RegisterImplementations((*sdk.Msg)(nil),
                &amp;MsgProposeDispute{},
        )
        registry.RegisterImplementations((*sdk.Msg)(nil),
                &amp;MsgAddFeeToDispute{},
        )
        registry.RegisterImplementations((*sdk.Msg)(nil),
                &amp;MsgVote{},
        )
        // this line is used by starport scaffolding # 3

        msgservice.RegisterMsgServiceDesc(registry, &amp;_Msg_serviceDesc)
}</span>

var (
        Amino     = codec.NewLegacyAmino()
        ModuleCdc = codec.NewProtoCodec(cdctypes.NewInterfaceRegistry())
)
</pre>
		
		<pre class="file" id="file58" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/dispute/dispute.proto

package types

import (
        cosmossdk_io_math "cosmossdk.io/math"
        fmt "fmt"
        _ "github.com/cosmos/cosmos-proto"
        _ "github.com/cosmos/cosmos-sdk/types"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
        types "github.com/tellor-io/layer/x/oracle/types"
        _ "google.golang.org/protobuf/types/known/timestamppb"
        io "io"
        math "math"
        math_bits "math/bits"
        time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// DisputeCategory defines the severity of a dispute.
type DisputeCategory int32

const (
        // UNSPECIFIED defines an invalid dispute category.
        Unspecified DisputeCategory = 0
        // WARNING defines a 1 percent slashing.
        Warning DisputeCategory = 1
        // MINOR defines a 5 percent slashing.
        Minor DisputeCategory = 2
        // MAJOR defines a 100 percent slashing.
        Major DisputeCategory = 3
)

var DisputeCategory_name = map[int32]string{
        0: "DISPUTE_CATEGORY_UNSPECIFIED",
        1: "DISPUTE_CATEGORY_WARNING",
        2: "DISPUTE_CATEGORY_MINOR",
        3: "DISPUTE_CATEGORY_MAJOR",
}

var DisputeCategory_value = map[string]int32{
        "DISPUTE_CATEGORY_UNSPECIFIED": 0,
        "DISPUTE_CATEGORY_WARNING":     1,
        "DISPUTE_CATEGORY_MINOR":       2,
        "DISPUTE_CATEGORY_MAJOR":       3,
}

func (x DisputeCategory) String() string <span class="cov0" title="0">{
        return proto.EnumName(DisputeCategory_name, int32(x))
}</span>

func (DisputeCategory) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_2a5d4b70d69c78b5, []int{0}
}</span>

// DisputeStatus defines the status of a dispute.
type DisputeStatus int32

const (
        // PREVOTE defines a dispute that hasn't started voting (ie in funding).
        Prevote DisputeStatus = 0
        // VOTING defines a dispute that has been funded and is in voting.
        Voting DisputeStatus = 1
        // RESOLVED defines a dispute that has completed voting and reached quroum
        Resolved DisputeStatus = 2
        // UNRESOLVED defines a dispute that has completed voting and but hasn't reached quroum
        Unresolved DisputeStatus = 3
        // FAILED defines a dispute that failed to pay the dispute fee to start vote.
        Failed DisputeStatus = 4
)

var DisputeStatus_name = map[int32]string{
        0: "DISPUTE_STATUS_PREVOTE",
        1: "DISPUTE_STATUS_VOTING",
        2: "DISPUTE_STATUS_RESOLVED",
        3: "DISPUTE_STATUS_UNRESOLVED",
        4: "DISPUTE_STATUS_FAILED",
}

var DisputeStatus_value = map[string]int32{
        "DISPUTE_STATUS_PREVOTE":    0,
        "DISPUTE_STATUS_VOTING":     1,
        "DISPUTE_STATUS_RESOLVED":   2,
        "DISPUTE_STATUS_UNRESOLVED": 3,
        "DISPUTE_STATUS_FAILED":     4,
}

func (x DisputeStatus) String() string <span class="cov0" title="0">{
        return proto.EnumName(DisputeStatus_name, int32(x))
}</span>

func (DisputeStatus) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_2a5d4b70d69c78b5, []int{1}
}</span>

// Dispute defines a dispute.
type Dispute struct {
        // unique dispute hash identifier
        HashId []byte `protobuf:"bytes,1,opt,name=hash_id,json=hashId,proto3" json:"hash_id,omitempty"`
        // current dispute id
        DisputeId uint64 `protobuf:"varint,2,opt,name=dispute_id,json=disputeId,proto3" json:"dispute_id,omitempty"`
        // dispute severity level
        DisputeCategory DisputeCategory `protobuf:"varint,3,opt,name=dispute_category,json=disputeCategory,proto3,enum=layer.dispute.DisputeCategory" json:"dispute_category,omitempty"`
        // cost to start dispute
        DisputeFee cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=dispute_fee,json=disputeFee,proto3,customtype=cosmossdk.io/math.Int" json:"dispute_fee"`
        // current dispute status
        DisputeStatus DisputeStatus `protobuf:"varint,5,opt,name=dispute_status,json=disputeStatus,proto3,enum=layer.dispute.DisputeStatus" json:"dispute_status,omitempty"`
        // start time of the dispute that begins after dispute fee is fully paid
        DisputeStartTime time.Time `protobuf:"bytes,6,opt,name=dispute_start_time,json=disputeStartTime,proto3,stdtime" json:"dispute_start_time"`
        // end time that the dispute stop taking votes and creating new rounds
        DisputeEndTime time.Time `protobuf:"bytes,7,opt,name=dispute_end_time,json=disputeEndTime,proto3,stdtime" json:"dispute_end_time"`
        // height of the block that started the dispute
        DisputeStartBlock int64 `protobuf:"varint,8,opt,name=dispute_start_block,json=disputeStartBlock,proto3" json:"dispute_start_block,omitempty"`
        // current dispute round
        DisputeRound uint64 `protobuf:"varint,9,opt,name=dispute_round,json=disputeRound,proto3" json:"dispute_round,omitempty"`
        // reporter's slashed amount
        SlashAmount cosmossdk_io_math.Int `protobuf:"bytes,10,opt,name=slash_amount,json=slashAmount,proto3,customtype=cosmossdk.io/math.Int" json:"slash_amount"`
        // burn amount that will be divided in half and paid to voters and the other half burned
        BurnAmount cosmossdk_io_math.Int `protobuf:"bytes,11,opt,name=burn_amount,json=burnAmount,proto3,customtype=cosmossdk.io/math.Int" json:"burn_amount"`
        // single report evidence
        ReportEvidence types.MicroReport `protobuf:"bytes,12,opt,name=report_evidence,json=reportEvidence,proto3" json:"report_evidence"`
        // fee payers that were involved in paying the dispute fee in order to start the dispute
        FeePayers []PayerInfo `protobuf:"bytes,13,rep,name=fee_payers,json=feePayers,proto3" json:"fee_payers"`
        // total fee paid tracked to know if dispute fee is fully paid to start dispute
        FeeTotal cosmossdk_io_math.Int `protobuf:"bytes,14,opt,name=fee_total,json=feeTotal,proto3,customtype=cosmossdk.io/math.Int" json:"fee_total"`
        // list of dispute ids that preceded before this current round began
        PrevDisputeIds []uint64 `protobuf:"varint,15,rep,packed,name=prev_dispute_ids,json=prevDisputeIds,proto3" json:"prev_dispute_ids,omitempty"`
}

func (m *Dispute) Reset()         <span class="cov0" title="0">{ *m = Dispute{} }</span>
func (m *Dispute) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Dispute) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Dispute) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_2a5d4b70d69c78b5, []int{0}
}</span>
func (m *Dispute) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Dispute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Dispute.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Dispute) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Dispute.Merge(m, src)
}</span>
func (m *Dispute) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Dispute) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Dispute.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Dispute proto.InternalMessageInfo

func (m *Dispute) GetHashId() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.HashId
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Dispute) GetDisputeId() uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DisputeId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Dispute) GetDisputeCategory() DisputeCategory <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DisputeCategory
        }</span>
        <span class="cov0" title="0">return Unspecified</span>
}

func (m *Dispute) GetDisputeStatus() DisputeStatus <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DisputeStatus
        }</span>
        <span class="cov0" title="0">return Prevote</span>
}

func (m *Dispute) GetDisputeStartTime() time.Time <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DisputeStartTime
        }</span>
        <span class="cov0" title="0">return time.Time{}</span>
}

func (m *Dispute) GetDisputeEndTime() time.Time <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DisputeEndTime
        }</span>
        <span class="cov0" title="0">return time.Time{}</span>
}

func (m *Dispute) GetDisputeStartBlock() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DisputeStartBlock
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Dispute) GetDisputeRound() uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DisputeRound
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Dispute) GetReportEvidence() types.MicroReport <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ReportEvidence
        }</span>
        <span class="cov0" title="0">return types.MicroReport{}</span>
}

func (m *Dispute) GetFeePayers() []PayerInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.FeePayers
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Dispute) GetPrevDisputeIds() []uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PrevDisputeIds
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// PayerInfo defines the payer info of a dispute
// fee payer's info that was involved in paying the dispute fee in order to start the dispute
type PayerInfo struct {
        // fee payer's Account address
        PayerAddress string `protobuf:"bytes,1,opt,name=payer_address,json=payerAddress,proto3" json:"payer_address,omitempty"`
        // amount paid
        Amount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
        // source of funds either from bond or free floating funds
        FromBond bool `protobuf:"varint,3,opt,name=from_bond,json=fromBond,proto3" json:"from_bond,omitempty"`
        // block number when this specific fee was paid
        // keeping track of this in case the bond was used
        // in order to reward the reporters' delegators in the future
        BlockNumber int64 `protobuf:"varint,4,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
}

func (m *PayerInfo) Reset()         <span class="cov0" title="0">{ *m = PayerInfo{} }</span>
func (m *PayerInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*PayerInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*PayerInfo) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_2a5d4b70d69c78b5, []int{1}
}</span>
func (m *PayerInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *PayerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_PayerInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *PayerInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_PayerInfo.Merge(m, src)
}</span>
func (m *PayerInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *PayerInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_PayerInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_PayerInfo proto.InternalMessageInfo

func (m *PayerInfo) GetPayerAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PayerAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *PayerInfo) GetFromBond() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.FromBond
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *PayerInfo) GetBlockNumber() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BlockNumber
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterEnum("layer.dispute.DisputeCategory", DisputeCategory_name, DisputeCategory_value)
        proto.RegisterEnum("layer.dispute.DisputeStatus", DisputeStatus_name, DisputeStatus_value)
        proto.RegisterType((*Dispute)(nil), "layer.dispute.Dispute")
        proto.RegisterType((*PayerInfo)(nil), "layer.dispute.PayerInfo")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/dispute/dispute.proto", fileDescriptor_2a5d4b70d69c78b5) }</span>

var fileDescriptor_2a5d4b70d69c78b5 = []byte{
        // 959 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0xcb, 0x6e, 0xdb, 0x46,
        0x14, 0x15, 0x2d, 0xc5, 0x96, 0x46, 0x2f, 0x76, 0x9a, 0x34, 0xb4, 0x92, 0xca, 0x6c, 0x8a, 0xa0,
        0x8a, 0x0b, 0x93, 0xb0, 0xbb, 0xce, 0x42, 0x0f, 0x3a, 0x61, 0x61, 0x4b, 0xc2, 0x48, 0x72, 0xd0,
        0x6e, 0x08, 0x4a, 0x1c, 0xc9, 0x6c, 0x28, 0x8e, 0x30, 0x1c, 0x09, 0xf5, 0x1f, 0x14, 0x5a, 0xe5,
        0x07, 0xb4, 0xea, 0x27, 0x34, 0x7f, 0xd0, 0x4d, 0x76, 0x0d, 0xb2, 0x2a, 0xba, 0x48, 0x0b, 0x1b,
        0xe8, 0x77, 0x14, 0x33, 0x43, 0xfa, 0x21, 0x67, 0xe3, 0xae, 0xa4, 0x7b, 0xee, 0xb9, 0x67, 0xce,
        0xcc, 0xbd, 0x33, 0x04, 0x8f, 0x02, 0xf7, 0x0c, 0x53, 0xd3, 0xf3, 0xa3, 0xd9, 0x9c, 0xe1, 0xe4,
        0xd7, 0x98, 0x51, 0xc2, 0x08, 0x2c, 0x8a, 0xa4, 0x11, 0x83, 0x95, 0xea, 0x88, 0x44, 0x53, 0x12,
        0x99, 0x43, 0x37, 0xc2, 0xe6, 0x62, 0x7f, 0x88, 0x99, 0xbb, 0x6f, 0x8e, 0x88, 0x1f, 0x4a, 0x7a,
        0x65, 0x5b, 0xe6, 0x1d, 0x11, 0x99, 0x32, 0x88, 0x53, 0xf7, 0x27, 0x64, 0x42, 0x24, 0xce, 0xff,
        0xc5, 0xe8, 0xce, 0x84, 0x90, 0x49, 0x80, 0x4d, 0x11, 0x0d, 0xe7, 0x63, 0x93, 0xf9, 0x53, 0x1c,
        0x31, 0x77, 0x3a, 0x4b, 0x08, 0xd2, 0x1d, 0xa1, 0xee, 0x28, 0xc0, 0xe6, 0xd4, 0x1f, 0x51, 0xe2,
        0x50, 0x3c, 0x23, 0x94, 0x49, 0xc2, 0x93, 0xdf, 0xb6, 0xc0, 0x56, 0x4b, 0xda, 0x83, 0x0f, 0xc1,
        0xd6, 0xa9, 0x1b, 0x9d, 0x3a, 0xbe, 0xa7, 0x29, 0xba, 0x52, 0x2b, 0xa0, 0x4d, 0x1e, 0xda, 0x1e,
        0xfc, 0x12, 0x80, 0x78, 0x0b, 0x3c, 0xb7, 0xa1, 0x2b, 0xb5, 0x0c, 0xca, 0xc5, 0x88, 0xed, 0x41,
        0x1b, 0xa8, 0x49, 0x7a, 0xe4, 0x32, 0x3c, 0x21, 0xf4, 0x4c, 0x4b, 0xeb, 0x4a, 0xad, 0x74, 0x50,
        0x35, 0x6e, 0x1c, 0x80, 0x11, 0xaf, 0xd4, 0x8c, 0x59, 0xa8, 0xec, 0xdd, 0x04, 0xe0, 0x11, 0xc8,
        0x27, 0x52, 0x63, 0x8c, 0xb5, 0x8c, 0xae, 0xd4, 0x72, 0x8d, 0x6f, 0xdf, 0x7d, 0xdc, 0x49, 0xfd,
        0xf5, 0x71, 0xe7, 0x81, 0x3c, 0x91, 0xc8, 0x7b, 0x6d, 0xf8, 0xc4, 0x9c, 0xba, 0xec, 0xd4, 0xb0,
        0x43, 0xf6, 0xe1, 0xed, 0x1e, 0x88, 0x8f, 0xca, 0x0e, 0x19, 0x4a, 0x9c, 0x1e, 0x62, 0x0c, 0x9b,
        0xa0, 0x94, 0xa8, 0x45, 0xcc, 0x65, 0xf3, 0x48, 0xbb, 0x27, 0x6c, 0x3d, 0xfe, 0xb4, 0xad, 0x9e,
        0xe0, 0xa0, 0xa2, 0x77, 0x3d, 0x84, 0x08, 0xc0, 0x6b, 0x22, 0x94, 0x39, 0xfc, 0x8c, 0xb5, 0x4d,
        0x5d, 0xa9, 0xe5, 0x0f, 0x2a, 0x86, 0x6c, 0x80, 0x91, 0x34, 0xc0, 0xe8, 0x27, 0x0d, 0x68, 0x64,
        0xb9, 0xeb, 0x37, 0x7f, 0xef, 0x28, 0x48, 0xbd, 0x12, 0xa4, 0x8c, 0x13, 0x60, 0xfb, 0xea, 0xc4,
        0x70, 0xe8, 0x49, 0xc5, 0xad, 0x3b, 0x28, 0x26, 0xdb, 0xb2, 0x42, 0x4f, 0xe8, 0x19, 0xe0, 0xf3,
        0x9b, 0x1e, 0x87, 0x01, 0x19, 0xbd, 0xd6, 0xb2, 0xba, 0x52, 0x4b, 0xa3, 0xcf, 0xae, 0x2f, 0xdf,
        0xe0, 0x09, 0xf8, 0x35, 0x48, 0x36, 0xe9, 0x50, 0x32, 0x0f, 0x3d, 0x2d, 0x27, 0x7a, 0x5a, 0x88,
        0x41, 0xc4, 0x31, 0xd8, 0x06, 0x85, 0x28, 0xe0, 0xf3, 0xe0, 0x4e, 0xc9, 0x3c, 0x64, 0x1a, 0xb8,
        0x7b, 0x33, 0xf2, 0x42, 0xa0, 0x2e, 0xea, 0x79, 0x6f, 0x87, 0x73, 0x1a, 0x26, 0x72, 0xf9, 0xff,
        0xd1, 0x5b, 0x5e, 0x1f, 0xab, 0xbd, 0x04, 0x65, 0x39, 0xc8, 0x0e, 0x5e, 0xf8, 0x1e, 0x0e, 0x47,
        0x58, 0x2b, 0x88, 0x13, 0xdc, 0x8e, 0x9b, 0x2b, 0x67, 0xde, 0x38, 0xe6, 0x33, 0x8f, 0x04, 0xb3,
        0x91, 0xe1, 0x8b, 0xa1, 0x92, 0xac, 0xb3, 0xe2, 0x32, 0xf8, 0x1c, 0x80, 0x31, 0xc6, 0xce, 0x8c,
        0x57, 0x45, 0x5a, 0x51, 0x4f, 0xd7, 0xf2, 0x07, 0xda, 0xda, 0x84, 0x74, 0x79, 0x64, 0x87, 0x63,
        0x12, 0x6b, 0xe4, 0xc6, 0x18, 0x0b, 0x2c, 0x82, 0x2f, 0x01, 0x0f, 0x1c, 0x46, 0x98, 0x1b, 0x68,
        0xa5, 0xbb, 0x6f, 0x2a, 0x3b, 0xc6, 0xb8, 0xcf, 0x8b, 0x61, 0x0d, 0xa8, 0x33, 0x8a, 0x17, 0xce,
        0xd5, 0x5d, 0x8b, 0xb4, 0xb2, 0x9e, 0xae, 0x65, 0x50, 0x89, 0xe3, 0xad, 0xe4, 0xc2, 0x45, 0x4f,
        0xfe, 0x50, 0x40, 0xee, 0xd2, 0x12, 0x7c, 0x0e, 0x8a, 0xc2, 0xbc, 0xe3, 0x7a, 0x1e, 0xc5, 0x51,
        0x24, 0x6e, 0x6f, 0xae, 0xa1, 0x7d, 0x78, 0xbb, 0x77, 0x3f, 0x5e, 0xa8, 0x2e, 0x33, 0x3d, 0x46,
        0xfd, 0x70, 0x82, 0x0a, 0x82, 0x1e, 0x63, 0xb0, 0x09, 0x36, 0xe3, 0x96, 0x6c, 0xdc, 0xdd, 0x7d,
        0x5c, 0x0a, 0x1f, 0x81, 0xdc, 0x98, 0x92, 0xa9, 0x33, 0x24, 0xa1, 0x27, 0x2e, 0x7f, 0x16, 0x65,
        0x39, 0xd0, 0x20, 0xa1, 0x07, 0xbf, 0x02, 0x05, 0x31, 0x90, 0x4e, 0x38, 0x9f, 0x0e, 0x31, 0x15,
        0xd7, 0x3a, 0x8d, 0xf2, 0x02, 0x6b, 0x0b, 0x68, 0xf7, 0x77, 0x05, 0x94, 0xd7, 0x5e, 0x07, 0xb8,
        0x0f, 0x1e, 0xb7, 0xec, 0x5e, 0x77, 0xd0, 0xb7, 0x9c, 0x66, 0xbd, 0x6f, 0xbd, 0xe8, 0xa0, 0x1f,
        0x9c, 0x41, 0xbb, 0xd7, 0xb5, 0x9a, 0xf6, 0xa1, 0x6d, 0xb5, 0xd4, 0x54, 0xa5, 0xbc, 0x5c, 0xe9,
        0xf9, 0x41, 0x18, 0xcd, 0xf0, 0xc8, 0x1f, 0xfb, 0xd8, 0x83, 0xcf, 0x80, 0x76, 0xab, 0xe4, 0x55,
        0x1d, 0xb5, 0xed, 0xf6, 0x0b, 0x55, 0xa9, 0xe4, 0x97, 0x2b, 0x7d, 0xeb, 0x95, 0x4b, 0x43, 0x3f,
        0x9c, 0xc0, 0xa7, 0xe0, 0x8b, 0x5b, 0xd4, 0x63, 0xbb, 0xdd, 0x41, 0xea, 0x46, 0x25, 0xb7, 0x5c,
        0xe9, 0xf7, 0x8e, 0xfd, 0x90, 0xd0, 0x4f, 0xd3, 0xea, 0xdf, 0x77, 0x90, 0x9a, 0x8e, 0x69, 0xee,
        0x4f, 0x84, 0x56, 0x32, 0xbf, 0xfc, 0x5a, 0x4d, 0xed, 0xfe, 0xab, 0x80, 0xe2, 0x8d, 0xc7, 0x04,
        0x7e, 0x73, 0x55, 0xde, 0xeb, 0xd7, 0xfb, 0x83, 0x9e, 0xd3, 0x45, 0xd6, 0x49, 0xa7, 0x6f, 0xa9,
        0x29, 0x69, 0xa7, 0x4b, 0xf1, 0x82, 0x30, 0x0c, 0x9f, 0x82, 0x07, 0x6b, 0xc4, 0x93, 0x4e, 0x5f,
        0xda, 0x06, 0xcb, 0x95, 0xbe, 0x79, 0x42, 0x18, 0x77, 0xfd, 0x0c, 0x3c, 0x5c, 0xa3, 0x21, 0xab,
        0xd7, 0x39, 0x3a, 0xb1, 0x5a, 0xea, 0x46, 0xa5, 0xb0, 0x5c, 0xe9, 0x59, 0x84, 0x23, 0x12, 0x2c,
        0xb0, 0x07, 0xf7, 0xc0, 0xf6, 0x1a, 0x75, 0xd0, 0xbe, 0x24, 0xa7, 0x2b, 0xa5, 0xe5, 0x4a, 0x07,
        0x83, 0x90, 0x26, 0xf4, 0xdb, 0x06, 0x0e, 0xeb, 0xf6, 0x91, 0xd5, 0x52, 0x33, 0xd2, 0xc0, 0xa1,
        0xeb, 0x07, 0xd8, 0x93, 0x1b, 0x6d, 0xb4, 0xde, 0x9d, 0x57, 0x95, 0xf7, 0xe7, 0x55, 0xe5, 0x9f,
        0xf3, 0xaa, 0xf2, 0xe6, 0xa2, 0x9a, 0x7a, 0x7f, 0x51, 0x4d, 0xfd, 0x79, 0x51, 0x4d, 0xfd, 0xb8,
        0x3b, 0xf1, 0xd9, 0xe9, 0x7c, 0x68, 0x8c, 0xc8, 0xd4, 0x64, 0x38, 0x08, 0x08, 0xdd, 0xf3, 0x89,
        0x29, 0x3f, 0x43, 0x3f, 0x5f, 0x7e, 0x26, 0xd9, 0xd9, 0x0c, 0x47, 0xc3, 0x4d, 0xf1, 0xc8, 0x7d,
        0xf7, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x97, 0xa9, 0x87, 0xa4, 0x44, 0x07, 0x00, 0x00,
}

func (m *Dispute) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Dispute) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Dispute) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.PrevDisputeIds) &gt; 0 </span><span class="cov0" title="0">{
                dAtA2 := make([]byte, len(m.PrevDisputeIds)*10)
                var j1 int
                for _, num := range m.PrevDisputeIds </span><span class="cov0" title="0">{
                        for num &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                                dAtA2[j1] = uint8(uint64(num)&amp;0x7f | 0x80)
                                num &gt;&gt;= 7
                                j1++
                        }</span>
                        <span class="cov0" title="0">dAtA2[j1] = uint8(num)
                        j1++</span>
                }
                <span class="cov0" title="0">i -= j1
                copy(dAtA[i:], dAtA2[:j1])
                i = encodeVarintDispute(dAtA, i, uint64(j1))
                i--
                dAtA[i] = 0x7a</span>
        }
        <span class="cov0" title="0">{
                size := m.FeeTotal.Size()
                i -= size
                if _, err := m.FeeTotal.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintDispute(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x72
        if len(m.FeePayers) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.FeePayers) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.FeePayers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintDispute(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x6a</span>
                }
        }
        <span class="cov0" title="0">{
                size, err := m.ReportEvidence.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintDispute(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x62
        </span><span class="cov0" title="0">{
                size := m.BurnAmount.Size()
                i -= size
                if _, err := m.BurnAmount.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintDispute(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x5a
        </span><span class="cov0" title="0">{
                size := m.SlashAmount.Size()
                i -= size
                if _, err := m.SlashAmount.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintDispute(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x52
        if m.DisputeRound != 0 </span><span class="cov0" title="0">{
                i = encodeVarintDispute(dAtA, i, uint64(m.DisputeRound))
                i--
                dAtA[i] = 0x48
        }</span>
        <span class="cov0" title="0">if m.DisputeStartBlock != 0 </span><span class="cov0" title="0">{
                i = encodeVarintDispute(dAtA, i, uint64(m.DisputeStartBlock))
                i--
                dAtA[i] = 0x40
        }</span>
        <span class="cov0" title="0">n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.DisputeEndTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.DisputeEndTime):])
        if err4 != nil </span><span class="cov0" title="0">{
                return 0, err4
        }</span>
        <span class="cov0" title="0">i -= n4
        i = encodeVarintDispute(dAtA, i, uint64(n4))
        i--
        dAtA[i] = 0x3a
        n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.DisputeStartTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.DisputeStartTime):])
        if err5 != nil </span><span class="cov0" title="0">{
                return 0, err5
        }</span>
        <span class="cov0" title="0">i -= n5
        i = encodeVarintDispute(dAtA, i, uint64(n5))
        i--
        dAtA[i] = 0x32
        if m.DisputeStatus != 0 </span><span class="cov0" title="0">{
                i = encodeVarintDispute(dAtA, i, uint64(m.DisputeStatus))
                i--
                dAtA[i] = 0x28
        }</span>
        <span class="cov0" title="0">{
                size := m.DisputeFee.Size()
                i -= size
                if _, err := m.DisputeFee.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintDispute(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x22
        if m.DisputeCategory != 0 </span><span class="cov0" title="0">{
                i = encodeVarintDispute(dAtA, i, uint64(m.DisputeCategory))
                i--
                dAtA[i] = 0x18
        }</span>
        <span class="cov0" title="0">if m.DisputeId != 0 </span><span class="cov0" title="0">{
                i = encodeVarintDispute(dAtA, i, uint64(m.DisputeId))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.HashId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.HashId)
                copy(dAtA[i:], m.HashId)
                i = encodeVarintDispute(dAtA, i, uint64(len(m.HashId)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *PayerInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *PayerInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *PayerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.BlockNumber != 0 </span><span class="cov0" title="0">{
                i = encodeVarintDispute(dAtA, i, uint64(m.BlockNumber))
                i--
                dAtA[i] = 0x20
        }</span>
        <span class="cov0" title="0">if m.FromBond </span><span class="cov0" title="0">{
                i--
                if m.FromBond </span><span class="cov0" title="0">{
                        dAtA[i] = 1
                }</span> else<span class="cov0" title="0"> {
                        dAtA[i] = 0
                }</span>
                <span class="cov0" title="0">i--
                dAtA[i] = 0x18</span>
        }
        <span class="cov0" title="0">{
                size := m.Amount.Size()
                i -= size
                if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintDispute(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x12
        if len(m.PayerAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.PayerAddress)
                copy(dAtA[i:], m.PayerAddress)
                i = encodeVarintDispute(dAtA, i, uint64(len(m.PayerAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintDispute(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovDispute(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Dispute) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.HashId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovDispute(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.DisputeId != 0 </span><span class="cov0" title="0">{
                n += 1 + sovDispute(uint64(m.DisputeId))
        }</span>
        <span class="cov0" title="0">if m.DisputeCategory != 0 </span><span class="cov0" title="0">{
                n += 1 + sovDispute(uint64(m.DisputeCategory))
        }</span>
        <span class="cov0" title="0">l = m.DisputeFee.Size()
        n += 1 + l + sovDispute(uint64(l))
        if m.DisputeStatus != 0 </span><span class="cov0" title="0">{
                n += 1 + sovDispute(uint64(m.DisputeStatus))
        }</span>
        <span class="cov0" title="0">l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.DisputeStartTime)
        n += 1 + l + sovDispute(uint64(l))
        l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.DisputeEndTime)
        n += 1 + l + sovDispute(uint64(l))
        if m.DisputeStartBlock != 0 </span><span class="cov0" title="0">{
                n += 1 + sovDispute(uint64(m.DisputeStartBlock))
        }</span>
        <span class="cov0" title="0">if m.DisputeRound != 0 </span><span class="cov0" title="0">{
                n += 1 + sovDispute(uint64(m.DisputeRound))
        }</span>
        <span class="cov0" title="0">l = m.SlashAmount.Size()
        n += 1 + l + sovDispute(uint64(l))
        l = m.BurnAmount.Size()
        n += 1 + l + sovDispute(uint64(l))
        l = m.ReportEvidence.Size()
        n += 1 + l + sovDispute(uint64(l))
        if len(m.FeePayers) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.FeePayers </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovDispute(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">l = m.FeeTotal.Size()
        n += 1 + l + sovDispute(uint64(l))
        if len(m.PrevDisputeIds) &gt; 0 </span><span class="cov0" title="0">{
                l = 0
                for _, e := range m.PrevDisputeIds </span><span class="cov0" title="0">{
                        l += sovDispute(uint64(e))
                }</span>
                <span class="cov0" title="0">n += 1 + sovDispute(uint64(l)) + l</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *PayerInfo) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.PayerAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovDispute(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Amount.Size()
        n += 1 + l + sovDispute(uint64(l))
        if m.FromBond </span><span class="cov0" title="0">{
                n += 2
        }</span>
        <span class="cov0" title="0">if m.BlockNumber != 0 </span><span class="cov0" title="0">{
                n += 1 + sovDispute(uint64(m.BlockNumber))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovDispute(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozDispute(x uint64) (n int) <span class="cov0" title="0">{
        return sovDispute(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Dispute) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowDispute
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Dispute: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Dispute: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field HashId", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDispute
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.HashId = append(m.HashId[:0], dAtA[iNdEx:postIndex]...)
                        if m.HashId == nil </span><span class="cov0" title="0">{
                                m.HashId = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DisputeId", wireType)
                        }</span>
                        <span class="cov0" title="0">m.DisputeId = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDispute
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.DisputeId |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 3:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DisputeCategory", wireType)
                        }</span>
                        <span class="cov0" title="0">m.DisputeCategory = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDispute
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.DisputeCategory |= DisputeCategory(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DisputeFee", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDispute
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.DisputeFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 5:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DisputeStatus", wireType)
                        }</span>
                        <span class="cov0" title="0">m.DisputeStatus = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDispute
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.DisputeStatus |= DisputeStatus(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 6:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DisputeStartTime", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDispute
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&amp;m.DisputeStartTime, dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 7:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DisputeEndTime", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDispute
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&amp;m.DisputeEndTime, dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 8:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DisputeStartBlock", wireType)
                        }</span>
                        <span class="cov0" title="0">m.DisputeStartBlock = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDispute
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.DisputeStartBlock |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 9:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DisputeRound", wireType)
                        }</span>
                        <span class="cov0" title="0">m.DisputeRound = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDispute
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.DisputeRound |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 10:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SlashAmount", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDispute
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.SlashAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 11:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field BurnAmount", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDispute
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.BurnAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 12:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ReportEvidence", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDispute
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.ReportEvidence.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 13:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field FeePayers", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDispute
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.FeePayers = append(m.FeePayers, PayerInfo{})
                        if err := m.FeePayers[len(m.FeePayers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 14:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field FeeTotal", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDispute
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.FeeTotal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 15:<span class="cov0" title="0">
                        if wireType == 0 </span><span class="cov0" title="0">{
                                var v uint64
                                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                                return ErrIntOverflowDispute
                                        }</span>
                                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                                return io.ErrUnexpectedEOF
                                        }</span>
                                        <span class="cov0" title="0">b := dAtA[iNdEx]
                                        iNdEx++
                                        v |= uint64(b&amp;0x7F) &lt;&lt; shift
                                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">m.PrevDisputeIds = append(m.PrevDisputeIds, v)</span>
                        } else<span class="cov0" title="0"> if wireType == 2 </span><span class="cov0" title="0">{
                                var packedLen int
                                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                                return ErrIntOverflowDispute
                                        }</span>
                                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                                return io.ErrUnexpectedEOF
                                        }</span>
                                        <span class="cov0" title="0">b := dAtA[iNdEx]
                                        iNdEx++
                                        packedLen |= int(b&amp;0x7F) &lt;&lt; shift
                                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if packedLen &lt; 0 </span><span class="cov0" title="0">{
                                        return ErrInvalidLengthDispute
                                }</span>
                                <span class="cov0" title="0">postIndex := iNdEx + packedLen
                                if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                        return ErrInvalidLengthDispute
                                }</span>
                                <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">var elementCount int
                                var count int
                                for _, integer := range dAtA[iNdEx:postIndex] </span><span class="cov0" title="0">{
                                        if integer &lt; 128 </span><span class="cov0" title="0">{
                                                count++
                                        }</span>
                                }
                                <span class="cov0" title="0">elementCount = count
                                if elementCount != 0 &amp;&amp; len(m.PrevDisputeIds) == 0 </span><span class="cov0" title="0">{
                                        m.PrevDisputeIds = make([]uint64, 0, elementCount)
                                }</span>
                                <span class="cov0" title="0">for iNdEx &lt; postIndex </span><span class="cov0" title="0">{
                                        var v uint64
                                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                                        return ErrIntOverflowDispute
                                                }</span>
                                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                                        return io.ErrUnexpectedEOF
                                                }</span>
                                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                                iNdEx++
                                                v |= uint64(b&amp;0x7F) &lt;&lt; shift
                                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                                        break</span>
                                                }
                                        }
                                        <span class="cov0" title="0">m.PrevDisputeIds = append(m.PrevDisputeIds, v)</span>
                                }
                        } else<span class="cov0" title="0"> {
                                return fmt.Errorf("proto: wrong wireType = %d for field PrevDisputeIds", wireType)
                        }</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipDispute(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *PayerInfo) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowDispute
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: PayerInfo: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: PayerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PayerAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDispute
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.PayerAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDispute
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field FromBond", wireType)
                        }</span>
                        <span class="cov0" title="0">var v int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDispute
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                v |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">m.FromBond = bool(v != 0)</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
                        }</span>
                        <span class="cov0" title="0">m.BlockNumber = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDispute
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.BlockNumber |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipDispute(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipDispute(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowDispute
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowDispute
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowDispute
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthDispute
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupDispute
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthDispute
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthDispute        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowDispute          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupDispute = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file59" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/dispute/dispute_params.proto

package types

import (
        fmt "fmt"
        proto "github.com/cosmos/gogoproto/proto"
        types "github.com/tellor-io/layer/x/oracle/types"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type DisputeParams struct {
        Report   *types.MicroReport `protobuf:"bytes,1,opt,name=report,proto3" json:"report,omitempty"`
        Category DisputeCategory    `protobuf:"varint,2,opt,name=category,proto3,enum=layer.dispute.DisputeCategory" json:"category,omitempty"`
}

func (m *DisputeParams) Reset()         <span class="cov0" title="0">{ *m = DisputeParams{} }</span>
func (m *DisputeParams) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DisputeParams) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*DisputeParams) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_2b782315e5e42770, []int{0}
}</span>
func (m *DisputeParams) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *DisputeParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_DisputeParams.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *DisputeParams) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_DisputeParams.Merge(m, src)
}</span>
func (m *DisputeParams) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *DisputeParams) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_DisputeParams.DiscardUnknown(m)
}</span>

var xxx_messageInfo_DisputeParams proto.InternalMessageInfo

func (m *DisputeParams) GetReport() *types.MicroReport <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Report
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *DisputeParams) GetCategory() DisputeCategory <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Category
        }</span>
        <span class="cov0" title="0">return Unspecified</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*DisputeParams)(nil), "layer.dispute.DisputeParams")
}</span>

func init() <span class="cov8" title="1">{
        proto.RegisterFile("layer/dispute/dispute_params.proto", fileDescriptor_2b782315e5e42770)
}</span>

var fileDescriptor_2b782315e5e42770 = []byte{
        // 230 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x52, 0xca, 0x49, 0xac, 0x4c,
        0x2d, 0xd2, 0x4f, 0xc9, 0x2c, 0x2e, 0x28, 0x2d, 0x49, 0x85, 0xd1, 0xf1, 0x05, 0x89, 0x45, 0x89,
        0xb9, 0xc5, 0x7a, 0x05, 0x45, 0xf9, 0x25, 0xf9, 0x42, 0xbc, 0x60, 0x35, 0x7a, 0x50, 0x39, 0x29,
        0x69, 0xac, 0x5a, 0x20, 0x6a, 0xa5, 0xe4, 0x21, 0x92, 0xf9, 0x45, 0x89, 0xc9, 0x39, 0xa9, 0xfa,
        0xb9, 0x99, 0xc9, 0x45, 0xf9, 0xf1, 0x45, 0xa9, 0x05, 0xf9, 0x45, 0x25, 0x10, 0x05, 0x4a, 0x75,
        0x5c, 0xbc, 0x2e, 0x10, 0x1d, 0x01, 0x60, 0x3b, 0x84, 0x0c, 0xb9, 0xd8, 0x20, 0x0a, 0x24, 0x18,
        0x15, 0x18, 0x35, 0xb8, 0x8d, 0x24, 0xf5, 0x20, 0xd6, 0x41, 0x8c, 0xd0, 0xf3, 0x05, 0x19, 0x11,
        0x04, 0x56, 0x10, 0x04, 0x55, 0x28, 0x64, 0xc5, 0xc5, 0x91, 0x9c, 0x58, 0x92, 0x9a, 0x9e, 0x5f,
        0x54, 0x29, 0xc1, 0xa4, 0xc0, 0xa8, 0xc1, 0x67, 0x24, 0xa7, 0x87, 0xe2, 0x46, 0x3d, 0xa8, 0x15,
        0xce, 0x50, 0x55, 0x41, 0x70, 0xf5, 0x4e, 0x2e, 0x27, 0x1e, 0xc9, 0x31, 0x5e, 0x78, 0x24, 0xc7,
        0xf8, 0xe0, 0x91, 0x1c, 0xe3, 0x84, 0xc7, 0x72, 0x0c, 0x17, 0x1e, 0xcb, 0x31, 0xdc, 0x78, 0x2c,
        0xc7, 0x10, 0xa5, 0x95, 0x9e, 0x59, 0x92, 0x51, 0x9a, 0xa4, 0x97, 0x9c, 0x9f, 0xab, 0x5f, 0x92,
        0x9a, 0x93, 0x93, 0x5f, 0xa4, 0x9b, 0x99, 0xaf, 0x0f, 0xf1, 0x4f, 0x05, 0xdc, 0xbb, 0x25, 0x95,
        0x05, 0xa9, 0xc5, 0x49, 0x6c, 0x60, 0xcf, 0x18, 0x03, 0x02, 0x00, 0x00, 0xff, 0xff, 0x31, 0x01,
        0xdf, 0x13, 0x3f, 0x01, 0x00, 0x00,
}

func (m *DisputeParams) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *DisputeParams) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *DisputeParams) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Category != 0 </span><span class="cov0" title="0">{
                i = encodeVarintDisputeParams(dAtA, i, uint64(m.Category))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if m.Report != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Report.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintDisputeParams(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintDisputeParams(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovDisputeParams(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *DisputeParams) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Report != nil </span><span class="cov0" title="0">{
                l = m.Report.Size()
                n += 1 + l + sovDisputeParams(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Category != 0 </span><span class="cov0" title="0">{
                n += 1 + sovDisputeParams(uint64(m.Category))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovDisputeParams(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozDisputeParams(x uint64) (n int) <span class="cov0" title="0">{
        return sovDisputeParams(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *DisputeParams) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowDisputeParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: DisputeParams: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: DisputeParams: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Report", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDisputeParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDisputeParams
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDisputeParams
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Report == nil </span><span class="cov0" title="0">{
                                m.Report = &amp;types.MicroReport{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Report.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Category = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDisputeParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Category |= DisputeCategory(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipDisputeParams(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDisputeParams
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipDisputeParams(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowDisputeParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowDisputeParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowDisputeParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthDisputeParams
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupDisputeParams
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthDisputeParams
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthDisputeParams        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowDisputeParams          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupDisputeParams = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file60" style="display: none">package types

// this line is used by starport scaffolding # genesis/types/import

// DefaultIndex is the default global index
const DefaultIndex uint64 = 1

// DefaultGenesis returns the default genesis state
func DefaultGenesis() *GenesisState <span class="cov8" title="1">{
        return &amp;GenesisState{
                // this line is used by starport scaffolding # genesis/types/default
                Params: DefaultParams(),
        }
}</span>

// Validate performs basic genesis state validation returning an error upon any
// failure.
func (gs GenesisState) Validate() error <span class="cov8" title="1">{
        // this line is used by starport scaffolding # genesis/types/validate

        return gs.Params.Validate()
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/dispute/genesis.proto

package types

import (
        fmt "fmt"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GenesisState defines the dispute module's genesis state.
type GenesisState struct {
        Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
}

func (m *GenesisState) Reset()         <span class="cov0" title="0">{ *m = GenesisState{} }</span>
func (m *GenesisState) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GenesisState) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GenesisState) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_8abee26cd752ac91, []int{0}
}</span>
func (m *GenesisState) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *GenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_GenesisState.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *GenesisState) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GenesisState.Merge(m, src)
}</span>
func (m *GenesisState) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *GenesisState) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GenesisState.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GenesisState proto.InternalMessageInfo

func (m *GenesisState) GetParams() Params <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Params
        }</span>
        <span class="cov0" title="0">return Params{}</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*GenesisState)(nil), "layer.dispute.GenesisState")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/dispute/genesis.proto", fileDescriptor_8abee26cd752ac91) }</span>

var fileDescriptor_8abee26cd752ac91 = []byte{
        // 192 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0xce, 0x49, 0xac, 0x4c,
        0x2d, 0xd2, 0x4f, 0xc9, 0x2c, 0x2e, 0x28, 0x2d, 0x49, 0xd5, 0x4f, 0x4f, 0xcd, 0x4b, 0x2d, 0xce,
        0x2c, 0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x05, 0x4b, 0xea, 0x41, 0x25, 0xa5, 0x44,
        0xd2, 0xf3, 0xd3, 0xf3, 0xc1, 0x32, 0xfa, 0x20, 0x16, 0x44, 0x91, 0x94, 0x14, 0xaa, 0x09, 0x05,
        0x89, 0x45, 0x89, 0xb9, 0x50, 0x03, 0x94, 0x9c, 0xb9, 0x78, 0xdc, 0x21, 0x26, 0x06, 0x97, 0x24,
        0x96, 0xa4, 0x0a, 0x19, 0x73, 0xb1, 0x41, 0xe4, 0x25, 0x18, 0x15, 0x18, 0x35, 0xb8, 0x8d, 0x44,
        0xf5, 0x50, 0x6c, 0xd0, 0x0b, 0x00, 0x4b, 0x3a, 0xb1, 0x9c, 0xb8, 0x27, 0xcf, 0x10, 0x04, 0x55,
        0xea, 0xe4, 0x72, 0xe2, 0x91, 0x1c, 0xe3, 0x85, 0x47, 0x72, 0x8c, 0x0f, 0x1e, 0xc9, 0x31, 0x4e,
        0x78, 0x2c, 0xc7, 0x70, 0xe1, 0xb1, 0x1c, 0xc3, 0x8d, 0xc7, 0x72, 0x0c, 0x51, 0x5a, 0xe9, 0x99,
        0x25, 0x19, 0xa5, 0x49, 0x7a, 0xc9, 0xf9, 0xb9, 0xfa, 0x25, 0xa9, 0x39, 0x39, 0xf9, 0x45, 0xba,
        0x99, 0xf9, 0xfa, 0x10, 0xf7, 0x54, 0xc0, 0x5d, 0x54, 0x52, 0x59, 0x90, 0x5a, 0x9c, 0xc4, 0x06,
        0x76, 0x91, 0x31, 0x20, 0x00, 0x00, 0xff, 0xff, 0x99, 0x5d, 0x95, 0xc2, 0xf1, 0x00, 0x00, 0x00,
}

func (m *GenesisState) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *GenesisState) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *GenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintGenesis(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func encodeVarintGenesis(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovGenesis(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *GenesisState) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Params.Size()
        n += 1 + l + sovGenesis(uint64(l))
        return n</span>
}

func sovGenesis(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozGenesis(x uint64) (n int) <span class="cov0" title="0">{
        return sovGenesis(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *GenesisState) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowGenesis
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipGenesis(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipGenesis(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowGenesis
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupGenesis
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthGenesis
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthGenesis        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowGenesis          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupGenesis = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file62" style="display: none">package types

import (
        "encoding/binary"
        "fmt"
)

const (
        // ModuleName defines the module name
        ModuleName = "dispute"

        // StoreKey defines the primary module store key
        StoreKey = ModuleName

        // RouterKey defines the module's message routing key
        RouterKey = ModuleName

        // MemStoreKey defines the in-memory store key
        MemStoreKey = "mem_dispute"

        // DisputesKey defines the disputes key
        DisputesKey = "disputes"

        // DisputeCountKey defines the dispute count key
        DisputeCountKey = "dispute-count"

        // OpenDisputeIdsKey defines the open dispute ids key
        OpenDisputeIdsKey = "open-dispute-ids"

        // VotesKey defines the votes key
        VotesKey = "votes"

        // Voter Power key
        VoterPowerKey = "voter-power"
)

func KeyPrefix(p string) []byte <span class="cov0" title="0">{
        return []byte(p)
}</span>

func DisputesKeyPrefix() []byte <span class="cov0" title="0">{
        return KeyPrefix(DisputesKey)
}</span>

func DisputeIdBytes(id uint64) []byte <span class="cov0" title="0">{
        bz := make([]byte, 8)
        binary.BigEndian.PutUint64(bz, id)
        return bz
}</span>

func OpenDisputeIdsKeyPrefix() []byte <span class="cov0" title="0">{
        return KeyPrefix(OpenDisputeIdsKey)
}</span>

func VotesKeyPrefix() []byte <span class="cov0" title="0">{
        return KeyPrefix(VotesKey)
}</span>

func VoterKeyPrefix(voter string, id uint64) []byte <span class="cov0" title="0">{
        return KeyPrefix(fmt.Sprintf("%s:%d", voter, id))
}</span>

func TallyKeyPrefix(id uint64) []byte <span class="cov0" title="0">{
        return KeyPrefix(fmt.Sprintf("%s:%d", "VoteTally", id))
}</span>

func VoterPowerKeyPrefix() []byte <span class="cov0" title="0">{
        return KeyPrefix(VoterPowerKey)
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package types

import (
        errorsmod "cosmossdk.io/errors"
        sdk "github.com/cosmos/cosmos-sdk/types"
        sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
)

const TypeMsgAddFeeToDispute = "add_fee_to_dispute"

var _ sdk.Msg = &amp;MsgAddFeeToDispute{}

func NewMsgAddFeeToDispute(creator string, disputeId uint64, amount sdk.Coin, payFromBond bool) *MsgAddFeeToDispute <span class="cov0" title="0">{
        return &amp;MsgAddFeeToDispute{
                Creator:     creator,
                DisputeId:   disputeId,
                Amount:      amount,
                PayFromBond: payFromBond,
        }
}</span>

func (msg *MsgAddFeeToDispute) Route() string <span class="cov0" title="0">{
        return RouterKey
}</span>

func (msg *MsgAddFeeToDispute) Type() string <span class="cov0" title="0">{
        return TypeMsgAddFeeToDispute
}</span>

func (msg *MsgAddFeeToDispute) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        creator, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return []sdk.AccAddress{creator}</span>
}

func (msg *MsgAddFeeToDispute) GetSignBytes() []byte <span class="cov0" title="0">{
        bz := ModuleCdc.MustMarshalJSON(msg)
        return sdk.MustSortJSON(bz)
}</span>

func (msg *MsgAddFeeToDispute) ValidateBasic() error <span class="cov8" title="1">{
        _, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov8" title="1">{
                return errorsmod.Wrapf(sdkerrors.ErrInvalidAddress, "invalid creator address (%s)", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package types

import (
        errorsmod "cosmossdk.io/errors"
        sdk "github.com/cosmos/cosmos-sdk/types"
        sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
        oracletypes "github.com/tellor-io/layer/x/oracle/types"
)

const TypeMsgProposeDispute = "propose_dispute"

var _ sdk.Msg = &amp;MsgProposeDispute{}

func NewMsgProposeDispute(creator string, report *oracletypes.MicroReport, disputeCategory DisputeCategory, fee sdk.Coin, payFromBond bool) *MsgProposeDispute <span class="cov0" title="0">{
        return &amp;MsgProposeDispute{
                Creator:         creator,
                Report:          report,
                DisputeCategory: disputeCategory,
                Fee:             fee,
                PayFromBond:     payFromBond,
        }
}</span>

func (msg *MsgProposeDispute) Route() string <span class="cov0" title="0">{
        return RouterKey
}</span>

func (msg *MsgProposeDispute) Type() string <span class="cov0" title="0">{
        return TypeMsgProposeDispute
}</span>

func (msg *MsgProposeDispute) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        creator, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return []sdk.AccAddress{creator}</span>
}

func (msg *MsgProposeDispute) GetSignBytes() []byte <span class="cov0" title="0">{
        bz := ModuleCdc.MustMarshalJSON(msg)
        return sdk.MustSortJSON(bz)
}</span>

func (msg *MsgProposeDispute) ValidateBasic() error <span class="cov8" title="1">{
        _, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov8" title="1">{
                return errorsmod.Wrapf(sdkerrors.ErrInvalidAddress, "invalid creator address (%s)", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package types

import (
        errorsmod "cosmossdk.io/errors"
        sdk "github.com/cosmos/cosmos-sdk/types"
        sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
)

const TypeMsgVote = "vote"

var _ sdk.Msg = &amp;MsgVote{}

func NewMsgVote(voter string, id uint64, vote VoteEnum) *MsgVote <span class="cov0" title="0">{
        return &amp;MsgVote{
                Voter: voter,
                Id:    id,
                Vote:  vote,
        }
}</span>

func (msg *MsgVote) Route() string <span class="cov0" title="0">{
        return RouterKey
}</span>

func (msg *MsgVote) Type() string <span class="cov0" title="0">{
        return TypeMsgVote
}</span>

func (msg *MsgVote) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        voter, err := sdk.AccAddressFromBech32(msg.Voter)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return []sdk.AccAddress{voter}</span>
}

func (msg *MsgVote) GetSignBytes() []byte <span class="cov0" title="0">{
        bz := ModuleCdc.MustMarshalJSON(msg)
        return sdk.MustSortJSON(bz)
}</span>

func (msg *MsgVote) ValidateBasic() error <span class="cov8" title="1">{
        _, err := sdk.AccAddressFromBech32(msg.Voter)
        if err != nil </span><span class="cov8" title="1">{
                return errorsmod.Wrapf(sdkerrors.ErrInvalidAddress, "invalid voter address (%s)", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/dispute/open_disputes.proto

package types

import (
        fmt "fmt"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type OpenDisputes struct {
        Ids []uint64 `protobuf:"varint,1,rep,packed,name=ids,proto3" json:"ids,omitempty"`
}

func (m *OpenDisputes) Reset()         <span class="cov0" title="0">{ *m = OpenDisputes{} }</span>
func (m *OpenDisputes) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*OpenDisputes) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*OpenDisputes) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_12e5399bae368977, []int{0}
}</span>
func (m *OpenDisputes) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *OpenDisputes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_OpenDisputes.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *OpenDisputes) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_OpenDisputes.Merge(m, src)
}</span>
func (m *OpenDisputes) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *OpenDisputes) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_OpenDisputes.DiscardUnknown(m)
}</span>

var xxx_messageInfo_OpenDisputes proto.InternalMessageInfo

func (m *OpenDisputes) GetIds() []uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Ids
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*OpenDisputes)(nil), "layer.dispute.OpenDisputes")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/dispute/open_disputes.proto", fileDescriptor_12e5399bae368977) }</span>

var fileDescriptor_12e5399bae368977 = []byte{
        // 154 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x52, 0xcc, 0x49, 0xac, 0x4c,
        0x2d, 0xd2, 0x4f, 0xc9, 0x2c, 0x2e, 0x28, 0x2d, 0x49, 0xd5, 0xcf, 0x2f, 0x48, 0xcd, 0x8b, 0x87,
        0x72, 0x8a, 0xf5, 0x0a, 0x8a, 0xf2, 0x4b, 0xf2, 0x85, 0x78, 0xc1, 0x4a, 0xf4, 0xa0, 0xa2, 0x4a,
        0x0a, 0x5c, 0x3c, 0xfe, 0x05, 0xa9, 0x79, 0x2e, 0x50, 0x45, 0x42, 0x02, 0x5c, 0xcc, 0x99, 0x29,
        0xc5, 0x12, 0x8c, 0x0a, 0xcc, 0x1a, 0x2c, 0x41, 0x20, 0xa6, 0x93, 0xcb, 0x89, 0x47, 0x72, 0x8c,
        0x17, 0x1e, 0xc9, 0x31, 0x3e, 0x78, 0x24, 0xc7, 0x38, 0xe1, 0xb1, 0x1c, 0xc3, 0x85, 0xc7, 0x72,
        0x0c, 0x37, 0x1e, 0xcb, 0x31, 0x44, 0x69, 0xa5, 0x67, 0x96, 0x64, 0x94, 0x26, 0xe9, 0x25, 0xe7,
        0xe7, 0xea, 0x97, 0xa4, 0xe6, 0xe4, 0xe4, 0x17, 0xe9, 0x66, 0xe6, 0xeb, 0x43, 0x9c, 0x50, 0x01,
        0x77, 0x44, 0x49, 0x65, 0x41, 0x6a, 0x71, 0x12, 0x1b, 0xd8, 0x76, 0x63, 0x40, 0x00, 0x00, 0x00,
        0xff, 0xff, 0x3a, 0x07, 0x32, 0x2e, 0xa2, 0x00, 0x00, 0x00,
}

func (m *OpenDisputes) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *OpenDisputes) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *OpenDisputes) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Ids) &gt; 0 </span><span class="cov0" title="0">{
                dAtA2 := make([]byte, len(m.Ids)*10)
                var j1 int
                for _, num := range m.Ids </span><span class="cov0" title="0">{
                        for num &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                                dAtA2[j1] = uint8(uint64(num)&amp;0x7f | 0x80)
                                num &gt;&gt;= 7
                                j1++
                        }</span>
                        <span class="cov0" title="0">dAtA2[j1] = uint8(num)
                        j1++</span>
                }
                <span class="cov0" title="0">i -= j1
                copy(dAtA[i:], dAtA2[:j1])
                i = encodeVarintOpenDisputes(dAtA, i, uint64(j1))
                i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintOpenDisputes(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovOpenDisputes(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *OpenDisputes) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Ids) &gt; 0 </span><span class="cov0" title="0">{
                l = 0
                for _, e := range m.Ids </span><span class="cov0" title="0">{
                        l += sovOpenDisputes(uint64(e))
                }</span>
                <span class="cov0" title="0">n += 1 + sovOpenDisputes(uint64(l)) + l</span>
        }
        <span class="cov0" title="0">return n</span>
}

func sovOpenDisputes(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozOpenDisputes(x uint64) (n int) <span class="cov0" title="0">{
        return sovOpenDisputes(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *OpenDisputes) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowOpenDisputes
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: OpenDisputes: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: OpenDisputes: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType == 0 </span><span class="cov0" title="0">{
                                var v uint64
                                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                                return ErrIntOverflowOpenDisputes
                                        }</span>
                                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                                return io.ErrUnexpectedEOF
                                        }</span>
                                        <span class="cov0" title="0">b := dAtA[iNdEx]
                                        iNdEx++
                                        v |= uint64(b&amp;0x7F) &lt;&lt; shift
                                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">m.Ids = append(m.Ids, v)</span>
                        } else<span class="cov0" title="0"> if wireType == 2 </span><span class="cov0" title="0">{
                                var packedLen int
                                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                                return ErrIntOverflowOpenDisputes
                                        }</span>
                                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                                return io.ErrUnexpectedEOF
                                        }</span>
                                        <span class="cov0" title="0">b := dAtA[iNdEx]
                                        iNdEx++
                                        packedLen |= int(b&amp;0x7F) &lt;&lt; shift
                                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if packedLen &lt; 0 </span><span class="cov0" title="0">{
                                        return ErrInvalidLengthOpenDisputes
                                }</span>
                                <span class="cov0" title="0">postIndex := iNdEx + packedLen
                                if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                        return ErrInvalidLengthOpenDisputes
                                }</span>
                                <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">var elementCount int
                                var count int
                                for _, integer := range dAtA[iNdEx:postIndex] </span><span class="cov0" title="0">{
                                        if integer &lt; 128 </span><span class="cov0" title="0">{
                                                count++
                                        }</span>
                                }
                                <span class="cov0" title="0">elementCount = count
                                if elementCount != 0 &amp;&amp; len(m.Ids) == 0 </span><span class="cov0" title="0">{
                                        m.Ids = make([]uint64, 0, elementCount)
                                }</span>
                                <span class="cov0" title="0">for iNdEx &lt; postIndex </span><span class="cov0" title="0">{
                                        var v uint64
                                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                                        return ErrIntOverflowOpenDisputes
                                                }</span>
                                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                                        return io.ErrUnexpectedEOF
                                                }</span>
                                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                                iNdEx++
                                                v |= uint64(b&amp;0x7F) &lt;&lt; shift
                                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                                        break</span>
                                                }
                                        }
                                        <span class="cov0" title="0">m.Ids = append(m.Ids, v)</span>
                                }
                        } else<span class="cov0" title="0"> {
                                return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
                        }</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipOpenDisputes(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthOpenDisputes
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipOpenDisputes(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowOpenDisputes
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowOpenDisputes
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowOpenDisputes
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthOpenDisputes
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupOpenDisputes
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthOpenDisputes
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthOpenDisputes        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowOpenDisputes          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupOpenDisputes = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file67" style="display: none">package types

import (
        paramtypes "github.com/cosmos/cosmos-sdk/x/params/types"
        "gopkg.in/yaml.v2"
)

var _ paramtypes.ParamSet = (*Params)(nil)

// ParamKeyTable the param key table for launch module
func ParamKeyTable() paramtypes.KeyTable <span class="cov0" title="0">{
        return paramtypes.NewKeyTable().RegisterParamSet(&amp;Params{})
}</span>

// NewParams creates a new Params instance
func NewParams() Params <span class="cov8" title="1">{
        return Params{}
}</span>

// DefaultParams returns a default set of parameters
func DefaultParams() Params <span class="cov8" title="1">{
        return NewParams()
}</span>

// ParamSetPairs get the params.ParamSet
func (p *Params) ParamSetPairs() paramtypes.ParamSetPairs <span class="cov0" title="0">{
        return paramtypes.ParamSetPairs{}
}</span>

// Validate validates the set of params
func (p Params) Validate() error <span class="cov8" title="1">{
        return nil
}</span>

// String implements the Stringer interface.
func (p Params) String() string <span class="cov0" title="0">{
        out, _ := yaml.Marshal(p)
        return string(out)
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/dispute/params.proto

package types

import (
        fmt "fmt"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines the parameters for the module.
type Params struct {
}

func (m *Params) Reset()      <span class="cov0" title="0">{ *m = Params{} }</span>
func (*Params) ProtoMessage() {<span class="cov0" title="0">}</span>
func (*Params) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_390f710f1a5ca025, []int{0}
}</span>
func (m *Params) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Params.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Params) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Params.Merge(m, src)
}</span>
func (m *Params) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Params) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Params.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Params proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Params)(nil), "layer.dispute.Params")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/dispute/params.proto", fileDescriptor_390f710f1a5ca025) }</span>

var fileDescriptor_390f710f1a5ca025 = []byte{
        // 151 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0xca, 0x49, 0xac, 0x4c,
        0x2d, 0xd2, 0x4f, 0xc9, 0x2c, 0x2e, 0x28, 0x2d, 0x49, 0xd5, 0x2f, 0x48, 0x2c, 0x4a, 0xcc, 0x2d,
        0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x05, 0xcb, 0xe9, 0x41, 0xe5, 0xa4, 0x44, 0xd2,
        0xf3, 0xd3, 0xf3, 0xc1, 0x32, 0xfa, 0x20, 0x16, 0x44, 0x91, 0x12, 0x1f, 0x17, 0x5b, 0x00, 0x58,
        0x93, 0x15, 0xcb, 0x8c, 0x05, 0xf2, 0x0c, 0x4e, 0x2e, 0x27, 0x1e, 0xc9, 0x31, 0x5e, 0x78, 0x24,
        0xc7, 0xf8, 0xe0, 0x91, 0x1c, 0xe3, 0x84, 0xc7, 0x72, 0x0c, 0x17, 0x1e, 0xcb, 0x31, 0xdc, 0x78,
        0x2c, 0xc7, 0x10, 0xa5, 0x95, 0x9e, 0x59, 0x92, 0x51, 0x9a, 0xa4, 0x97, 0x9c, 0x9f, 0xab, 0x5f,
        0x92, 0x9a, 0x93, 0x93, 0x5f, 0xa4, 0x9b, 0x99, 0xaf, 0x0f, 0xb1, 0xbf, 0x02, 0xee, 0x82, 0x92,
        0xca, 0x82, 0xd4, 0xe2, 0x24, 0x36, 0xb0, 0xe1, 0xc6, 0x80, 0x00, 0x00, 0x00, 0xff, 0xff, 0x6e,
        0xda, 0x69, 0xa1, 0x9f, 0x00, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func encodeVarintParams(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovParams(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Params) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func sovParams(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozParams(x uint64) (n int) <span class="cov0" title="0">{
        return sovParams(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Params) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Params: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipParams(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipParams(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupParams
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthParams
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthParams        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowParams          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupParams = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file69" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/dispute/query.proto

package types

import (
        context "context"
        fmt "fmt"
        _ "github.com/cosmos/cosmos-sdk/types/query"
        _ "github.com/cosmos/gogoproto/gogoproto"
        grpc1 "github.com/cosmos/gogoproto/grpc"
        proto "github.com/cosmos/gogoproto/proto"
        _ "google.golang.org/genproto/googleapis/api/annotations"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QueryParamsRequest is request type for the Query/Params RPC method.
type QueryParamsRequest struct {
}

func (m *QueryParamsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryParamsRequest{} }</span>
func (m *QueryParamsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryParamsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryParamsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_972b8e1a74396a43, []int{0}
}</span>
func (m *QueryParamsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryParamsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryParamsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsRequest.Merge(m, src)
}</span>
func (m *QueryParamsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryParamsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryParamsRequest proto.InternalMessageInfo

// QueryParamsResponse is response type for the Query/Params RPC method.
type QueryParamsResponse struct {
        // params holds all the parameters of this module.
        Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
}

func (m *QueryParamsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryParamsResponse{} }</span>
func (m *QueryParamsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryParamsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryParamsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_972b8e1a74396a43, []int{1}
}</span>
func (m *QueryParamsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryParamsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryParamsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsResponse.Merge(m, src)
}</span>
func (m *QueryParamsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryParamsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryParamsResponse proto.InternalMessageInfo

func (m *QueryParamsResponse) GetParams() Params <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Params
        }</span>
        <span class="cov0" title="0">return Params{}</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*QueryParamsRequest)(nil), "layer.dispute.QueryParamsRequest")
        proto.RegisterType((*QueryParamsResponse)(nil), "layer.dispute.QueryParamsResponse")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/dispute/query.proto", fileDescriptor_972b8e1a74396a43) }</span>

var fileDescriptor_972b8e1a74396a43 = []byte{
        // 297 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x90, 0xc1, 0x4a, 0xc3, 0x30,
        0x18, 0xc7, 0x1b, 0xd1, 0x1d, 0x22, 0x5e, 0xe2, 0x04, 0x2d, 0x92, 0xb9, 0x5e, 0x94, 0x81, 0x0d,
        0xdb, 0xde, 0x60, 0x78, 0xf2, 0xa4, 0x3b, 0x7a, 0x4b, 0x67, 0x88, 0x81, 0xae, 0x5f, 0xd6, 0xa4,
        0xb2, 0x1e, 0xf5, 0x09, 0x04, 0x5f, 0x6a, 0xc7, 0x81, 0x17, 0x4f, 0x22, 0xad, 0x0f, 0x22, 0x4b,
        0x83, 0x50, 0x27, 0xde, 0xc2, 0xf7, 0xff, 0x7d, 0x3f, 0xfe, 0x5f, 0xf0, 0x49, 0xca, 0x4b, 0x91,
        0xb3, 0x7b, 0x65, 0x74, 0x61, 0x05, 0x5b, 0x14, 0x22, 0x2f, 0x63, 0x9d, 0x83, 0x05, 0x72, 0xe0,
        0xa2, 0xd8, 0x47, 0x61, 0x57, 0x82, 0x04, 0x97, 0xb0, 0xcd, 0xab, 0x81, 0xc2, 0x53, 0x09, 0x20,
        0x53, 0xc1, 0xb8, 0x56, 0x8c, 0x67, 0x19, 0x58, 0x6e, 0x15, 0x64, 0xc6, 0xa7, 0x83, 0x19, 0x98,
        0x39, 0x18, 0x96, 0x70, 0xe3, 0xdd, 0xec, 0x71, 0x98, 0x08, 0xcb, 0x87, 0x4c, 0x73, 0xa9, 0x32,
        0x07, 0x7b, 0x36, 0x6c, 0x37, 0xd1, 0x3c, 0xe7, 0x73, 0xef, 0x89, 0xba, 0x98, 0xdc, 0x6e, 0xb6,
        0x6f, 0xdc, 0x70, 0x2a, 0x16, 0x85, 0x30, 0x36, 0xba, 0xc6, 0x87, 0xad, 0xa9, 0xd1, 0x90, 0x19,
        0x41, 0xc6, 0xb8, 0xd3, 0x2c, 0x1f, 0xa3, 0x33, 0x74, 0xb1, 0x3f, 0x3a, 0x8a, 0x5b, 0x87, 0xc4,
        0x0d, 0x3e, 0xd9, 0x5d, 0x7d, 0xf4, 0x82, 0xa9, 0x47, 0x47, 0x4f, 0x08, 0xef, 0x39, 0x19, 0x59,
        0xe2, 0x4e, 0x43, 0x90, 0xfe, 0xaf, 0xc5, 0xed, 0x0a, 0x61, 0xf4, 0x1f, 0xd2, 0xf4, 0x89, 0xce,
        0x9f, 0xdf, 0xbe, 0x5e, 0x77, 0xfa, 0xa4, 0xc7, 0xac, 0x48, 0x53, 0xc8, 0x2f, 0x15, 0xb0, 0xbf,
        0x6e, 0x9d, 0x5c, 0xad, 0x2a, 0x8a, 0xd6, 0x15, 0x45, 0x9f, 0x15, 0x45, 0x2f, 0x35, 0x0d, 0xd6,
        0x35, 0x0d, 0xde, 0x6b, 0x1a, 0xdc, 0x0d, 0xa4, 0xb2, 0x0f, 0x45, 0x12, 0xcf, 0x60, 0xbe, 0x25,
        0x59, 0xfe, 0x68, 0x6c, 0xa9, 0x85, 0x49, 0x3a, 0xee, 0xcb, 0xc6, 0xdf, 0x01, 0x00, 0x00, 0xff,
        0xff, 0xe9, 0xad, 0xf4, 0x8c, 0xda, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
        // Parameters queries the parameters of the module.
        Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error)
}

type queryClient struct {
        cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient <span class="cov0" title="0">{
        return &amp;queryClient{cc}
}</span>

func (c *queryClient) Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error) <span class="cov0" title="0">{
        out := new(QueryParamsResponse)
        err := c.cc.Invoke(ctx, "/layer.dispute.Query/Params", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// QueryServer is the server API for Query service.
type QueryServer interface {
        // Parameters queries the parameters of the module.
        Params(context.Context, *QueryParamsRequest) (*QueryParamsResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) Params(ctx context.Context, req *QueryParamsRequest) (*QueryParamsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Params not implemented")
}</span>

func RegisterQueryServer(s grpc1.Server, srv QueryServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;_Query_serviceDesc, srv)
}</span>

func _Query_Params_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryParamsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).Params(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.dispute.Query/Params",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).Params(ctx, req.(*QueryParamsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _Query_serviceDesc = grpc.ServiceDesc{
        ServiceName: "layer.dispute.Query",
        HandlerType: (*QueryServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Params",
                        Handler:    _Query_Params_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "layer/dispute/query.proto",
}

func (m *QueryParamsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryParamsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryParamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *QueryParamsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryParamsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovQuery(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *QueryParamsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *QueryParamsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Params.Size()
        n += 1 + l + sovQuery(uint64(l))
        return n</span>
}

func sovQuery(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozQuery(x uint64) (n int) <span class="cov0" title="0">{
        return sovQuery(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *QueryParamsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryParamsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipQuery(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupQuery
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthQuery
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file70" style="display: none">// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: layer/dispute/query.proto

/*
Package types is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package types

import (
        "context"
        "io"
        "net/http"

        "github.com/golang/protobuf/descriptor"
        "github.com/golang/protobuf/proto"
        "github.com/grpc-ecosystem/grpc-gateway/runtime"
        "github.com/grpc-ecosystem/grpc-gateway/utilities"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/grpclog"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// Suppress "imported and not used" errors
var _ codes.Code
var _ io.Reader
var _ status.Status
var _ = runtime.String
var _ = utilities.NewDoubleArray
var _ = descriptor.ForMessage
var _ = metadata.Join

func request_Query_Params_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryParamsRequest
        var metadata runtime.ServerMetadata

        msg, err := client.Params(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err

}</span>

func local_request_Query_Params_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryParamsRequest
        var metadata runtime.ServerMetadata

        msg, err := server.Params(ctx, &amp;protoReq)
        return msg, metadata, err

}</span>

// RegisterQueryHandlerServer registers the http handlers for service Query to "mux".
// UnaryRPC     :call QueryServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterQueryHandlerFromEndpoint instead.
func RegisterQueryHandlerServer(ctx context.Context, mux *runtime.ServeMux, server QueryServer) error <span class="cov0" title="0">{

        mux.Handle("GET", pattern_Query_Params_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_Params_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_Params_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

// RegisterQueryHandlerFromEndpoint is same as RegisterQueryHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterQueryHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) <span class="cov0" title="0">{
        conn, err := grpc.Dial(endpoint, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                }()
        }()

        <span class="cov0" title="0">return RegisterQueryHandler(ctx, mux, conn)</span>
}

// RegisterQueryHandler registers the http handlers for service Query to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterQueryHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error <span class="cov0" title="0">{
        return RegisterQueryHandlerClient(ctx, mux, NewQueryClient(conn))
}</span>

// RegisterQueryHandlerClient registers the http handlers for service Query
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "QueryClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "QueryClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "QueryClient" to call the correct interceptors.
func RegisterQueryHandlerClient(ctx context.Context, mux *runtime.ServeMux, client QueryClient) error <span class="cov0" title="0">{

        mux.Handle("GET", pattern_Query_Params_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_Params_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_Params_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

var (
        pattern_Query_Params_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"tellor-io", "layer", "dispute", "params"}, "", runtime.AssumeColonVerbOpt(false)))
)

var (
        forward_Query_Params_0 = runtime.ForwardResponseMessage
)
</pre>
		
		<pre class="file" id="file71" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/dispute/tally.proto

package types

import (
        fmt "fmt"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Tally struct {
        ForVotes     *VoterClasses `protobuf:"bytes,1,opt,name=forVotes,proto3" json:"forVotes,omitempty"`
        AgainstVotes *VoterClasses `protobuf:"bytes,2,opt,name=againstVotes,proto3" json:"againstVotes,omitempty"`
        Invalid      *VoterClasses `protobuf:"bytes,3,opt,name=Invalid,proto3" json:"Invalid,omitempty"`
}

func (m *Tally) Reset()         <span class="cov0" title="0">{ *m = Tally{} }</span>
func (m *Tally) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Tally) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Tally) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_d158d5fe40855c9d, []int{0}
}</span>
func (m *Tally) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Tally) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Tally.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Tally) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Tally.Merge(m, src)
}</span>
func (m *Tally) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Tally) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Tally.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Tally proto.InternalMessageInfo

func (m *Tally) GetForVotes() *VoterClasses <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ForVotes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Tally) GetAgainstVotes() *VoterClasses <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AgainstVotes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Tally) GetInvalid() *VoterClasses <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Invalid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Tally)(nil), "layer.dispute.Tally")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/dispute/tally.proto", fileDescriptor_d158d5fe40855c9d) }</span>

var fileDescriptor_d158d5fe40855c9d = []byte{
        // 220 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0xcc, 0x49, 0xac, 0x4c,
        0x2d, 0xd2, 0x4f, 0xc9, 0x2c, 0x2e, 0x28, 0x2d, 0x49, 0xd5, 0x2f, 0x49, 0xcc, 0xc9, 0xa9, 0xd4,
        0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x05, 0x4b, 0xe9, 0x41, 0xa5, 0xa4, 0x14, 0x51, 0x55,
        0x96, 0xe5, 0x97, 0xa4, 0x16, 0xc5, 0x27, 0xe7, 0x24, 0x16, 0x17, 0xa7, 0x16, 0x43, 0x74, 0x28,
        0xed, 0x60, 0xe4, 0x62, 0x0d, 0x01, 0x99, 0x20, 0x64, 0xce, 0xc5, 0x91, 0x96, 0x5f, 0x14, 0x96,
        0x5f, 0x92, 0x5a, 0x2c, 0xc1, 0xa8, 0xc0, 0xa8, 0xc1, 0x6d, 0x24, 0xad, 0x87, 0x62, 0x9c, 0x1e,
        0x48, 0xae, 0xc8, 0x19, 0xa2, 0x3d, 0x08, 0xae, 0x58, 0xc8, 0x9e, 0x8b, 0x27, 0x31, 0x3d, 0x31,
        0x33, 0xaf, 0xb8, 0x04, 0xa2, 0x99, 0x89, 0xb0, 0x66, 0x14, 0x0d, 0x42, 0xa6, 0x5c, 0xec, 0x9e,
        0x79, 0x65, 0x89, 0x39, 0x99, 0x29, 0x12, 0xcc, 0x84, 0xf5, 0xc2, 0xd4, 0x3a, 0xb9, 0x9c, 0x78,
        0x24, 0xc7, 0x78, 0xe1, 0x91, 0x1c, 0xe3, 0x83, 0x47, 0x72, 0x8c, 0x13, 0x1e, 0xcb, 0x31, 0x5c,
        0x78, 0x2c, 0xc7, 0x70, 0xe3, 0xb1, 0x1c, 0x43, 0x94, 0x56, 0x7a, 0x66, 0x49, 0x46, 0x69, 0x92,
        0x5e, 0x72, 0x7e, 0xae, 0x7e, 0x49, 0x6a, 0x4e, 0x4e, 0x7e, 0x91, 0x6e, 0x66, 0xbe, 0x3e, 0x24,
        0x30, 0x2a, 0x10, 0x01, 0x57, 0x59, 0x90, 0x5a, 0x9c, 0xc4, 0x06, 0x0e, 0x07, 0x63, 0x40, 0x00,
        0x00, 0x00, 0xff, 0xff, 0x80, 0xc4, 0xca, 0xa4, 0x56, 0x01, 0x00, 0x00,
}

func (m *Tally) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Tally) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Tally) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Invalid != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Invalid.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintTally(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0x1a</span>
        }
        <span class="cov0" title="0">if m.AgainstVotes != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.AgainstVotes.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintTally(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov0" title="0">if m.ForVotes != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.ForVotes.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintTally(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintTally(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovTally(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Tally) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.ForVotes != nil </span><span class="cov0" title="0">{
                l = m.ForVotes.Size()
                n += 1 + l + sovTally(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.AgainstVotes != nil </span><span class="cov0" title="0">{
                l = m.AgainstVotes.Size()
                n += 1 + l + sovTally(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Invalid != nil </span><span class="cov0" title="0">{
                l = m.Invalid.Size()
                n += 1 + l + sovTally(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovTally(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozTally(x uint64) (n int) <span class="cov0" title="0">{
        return sovTally(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Tally) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTally
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Tally: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Tally: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ForVotes", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTally
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTally
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTally
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.ForVotes == nil </span><span class="cov0" title="0">{
                                m.ForVotes = &amp;VoterClasses{}
                        }</span>
                        <span class="cov0" title="0">if err := m.ForVotes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AgainstVotes", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTally
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTally
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTally
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.AgainstVotes == nil </span><span class="cov0" title="0">{
                                m.AgainstVotes = &amp;VoterClasses{}
                        }</span>
                        <span class="cov0" title="0">if err := m.AgainstVotes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Invalid", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTally
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTally
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTally
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Invalid == nil </span><span class="cov0" title="0">{
                                m.Invalid = &amp;VoterClasses{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Invalid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTally(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTally
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipTally(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowTally
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowTally
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowTally
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthTally
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupTally
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthTally
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthTally        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowTally          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupTally = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file72" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/dispute/tx.proto

package types

import (
        context "context"
        fmt "fmt"
        types1 "github.com/cosmos/cosmos-sdk/types"
        _ "github.com/cosmos/cosmos-sdk/types/msgservice"
        _ "github.com/cosmos/gogoproto/gogoproto"
        grpc1 "github.com/cosmos/gogoproto/grpc"
        proto "github.com/cosmos/gogoproto/proto"
        types "github.com/tellor-io/layer/x/oracle/types"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type VoteEnum int32

const (
        VoteEnum_VOTE_INVALID VoteEnum = 0
        VoteEnum_VOTE_SUPPORT VoteEnum = 1
        VoteEnum_VOTE_AGAINST VoteEnum = 2
)

var VoteEnum_name = map[int32]string{
        0: "VOTE_INVALID",
        1: "VOTE_SUPPORT",
        2: "VOTE_AGAINST",
}

var VoteEnum_value = map[string]int32{
        "VOTE_INVALID": 0,
        "VOTE_SUPPORT": 1,
        "VOTE_AGAINST": 2,
}

func (x VoteEnum) String() string <span class="cov0" title="0">{
        return proto.EnumName(VoteEnum_name, int32(x))
}</span>

func (VoteEnum) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_3a591d7bef5d6e8a, []int{0}
}</span>

type MsgProposeDispute struct {
        Creator         string             `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
        Report          *types.MicroReport `protobuf:"bytes,2,opt,name=report,proto3" json:"report,omitempty"`
        DisputeCategory DisputeCategory    `protobuf:"varint,3,opt,name=disputeCategory,proto3,enum=layer.dispute.DisputeCategory" json:"disputeCategory,omitempty"`
        Fee             types1.Coin        `protobuf:"bytes,4,opt,name=fee,proto3" json:"fee"`
        PayFromBond     bool               `protobuf:"varint,5,opt,name=payFromBond,proto3" json:"payFromBond,omitempty"`
}

func (m *MsgProposeDispute) Reset()         <span class="cov0" title="0">{ *m = MsgProposeDispute{} }</span>
func (m *MsgProposeDispute) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgProposeDispute) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgProposeDispute) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_3a591d7bef5d6e8a, []int{0}
}</span>
func (m *MsgProposeDispute) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgProposeDispute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgProposeDispute.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgProposeDispute) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgProposeDispute.Merge(m, src)
}</span>
func (m *MsgProposeDispute) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgProposeDispute) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgProposeDispute.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgProposeDispute proto.InternalMessageInfo

func (m *MsgProposeDispute) GetCreator() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Creator
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgProposeDispute) GetReport() *types.MicroReport <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Report
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *MsgProposeDispute) GetDisputeCategory() DisputeCategory <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DisputeCategory
        }</span>
        <span class="cov0" title="0">return Unspecified</span>
}

func (m *MsgProposeDispute) GetFee() types1.Coin <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Fee
        }</span>
        <span class="cov0" title="0">return types1.Coin{}</span>
}

func (m *MsgProposeDispute) GetPayFromBond() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PayFromBond
        }</span>
        <span class="cov0" title="0">return false</span>
}

type MsgProposeDisputeResponse struct {
}

func (m *MsgProposeDisputeResponse) Reset()         <span class="cov0" title="0">{ *m = MsgProposeDisputeResponse{} }</span>
func (m *MsgProposeDisputeResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgProposeDisputeResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgProposeDisputeResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_3a591d7bef5d6e8a, []int{1}
}</span>
func (m *MsgProposeDisputeResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgProposeDisputeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgProposeDisputeResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgProposeDisputeResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgProposeDisputeResponse.Merge(m, src)
}</span>
func (m *MsgProposeDisputeResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgProposeDisputeResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgProposeDisputeResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgProposeDisputeResponse proto.InternalMessageInfo

type MsgAddFeeToDispute struct {
        Creator     string      `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
        DisputeId   uint64      `protobuf:"varint,2,opt,name=disputeId,proto3" json:"disputeId,omitempty"`
        Amount      types1.Coin `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount"`
        PayFromBond bool        `protobuf:"varint,4,opt,name=payFromBond,proto3" json:"payFromBond,omitempty"`
}

func (m *MsgAddFeeToDispute) Reset()         <span class="cov0" title="0">{ *m = MsgAddFeeToDispute{} }</span>
func (m *MsgAddFeeToDispute) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgAddFeeToDispute) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgAddFeeToDispute) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_3a591d7bef5d6e8a, []int{2}
}</span>
func (m *MsgAddFeeToDispute) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgAddFeeToDispute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgAddFeeToDispute.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgAddFeeToDispute) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddFeeToDispute.Merge(m, src)
}</span>
func (m *MsgAddFeeToDispute) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgAddFeeToDispute) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddFeeToDispute.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgAddFeeToDispute proto.InternalMessageInfo

func (m *MsgAddFeeToDispute) GetCreator() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Creator
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgAddFeeToDispute) GetDisputeId() uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DisputeId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *MsgAddFeeToDispute) GetAmount() types1.Coin <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Amount
        }</span>
        <span class="cov0" title="0">return types1.Coin{}</span>
}

func (m *MsgAddFeeToDispute) GetPayFromBond() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PayFromBond
        }</span>
        <span class="cov0" title="0">return false</span>
}

type MsgAddFeeToDisputeResponse struct {
}

func (m *MsgAddFeeToDisputeResponse) Reset()         <span class="cov0" title="0">{ *m = MsgAddFeeToDisputeResponse{} }</span>
func (m *MsgAddFeeToDisputeResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgAddFeeToDisputeResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgAddFeeToDisputeResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_3a591d7bef5d6e8a, []int{3}
}</span>
func (m *MsgAddFeeToDisputeResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgAddFeeToDisputeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgAddFeeToDisputeResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgAddFeeToDisputeResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddFeeToDisputeResponse.Merge(m, src)
}</span>
func (m *MsgAddFeeToDisputeResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgAddFeeToDisputeResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddFeeToDisputeResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgAddFeeToDisputeResponse proto.InternalMessageInfo

type MsgVote struct {
        Voter string   `protobuf:"bytes,1,opt,name=voter,proto3" json:"voter,omitempty"`
        Id    uint64   `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
        Vote  VoteEnum `protobuf:"varint,3,opt,name=vote,proto3,enum=layer.dispute.VoteEnum" json:"vote,omitempty"`
}

func (m *MsgVote) Reset()         <span class="cov0" title="0">{ *m = MsgVote{} }</span>
func (m *MsgVote) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgVote) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgVote) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_3a591d7bef5d6e8a, []int{4}
}</span>
func (m *MsgVote) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgVote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgVote.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgVote) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgVote.Merge(m, src)
}</span>
func (m *MsgVote) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgVote) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgVote.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgVote proto.InternalMessageInfo

func (m *MsgVote) GetVoter() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Voter
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgVote) GetId() uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *MsgVote) GetVote() VoteEnum <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Vote
        }</span>
        <span class="cov0" title="0">return VoteEnum_VOTE_INVALID</span>
}

type MsgVoteResponse struct {
}

func (m *MsgVoteResponse) Reset()         <span class="cov0" title="0">{ *m = MsgVoteResponse{} }</span>
func (m *MsgVoteResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgVoteResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgVoteResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_3a591d7bef5d6e8a, []int{5}
}</span>
func (m *MsgVoteResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgVoteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgVoteResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgVoteResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgVoteResponse.Merge(m, src)
}</span>
func (m *MsgVoteResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgVoteResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgVoteResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgVoteResponse proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterEnum("layer.dispute.VoteEnum", VoteEnum_name, VoteEnum_value)
        proto.RegisterType((*MsgProposeDispute)(nil), "layer.dispute.MsgProposeDispute")
        proto.RegisterType((*MsgProposeDisputeResponse)(nil), "layer.dispute.MsgProposeDisputeResponse")
        proto.RegisterType((*MsgAddFeeToDispute)(nil), "layer.dispute.MsgAddFeeToDispute")
        proto.RegisterType((*MsgAddFeeToDisputeResponse)(nil), "layer.dispute.MsgAddFeeToDisputeResponse")
        proto.RegisterType((*MsgVote)(nil), "layer.dispute.MsgVote")
        proto.RegisterType((*MsgVoteResponse)(nil), "layer.dispute.MsgVoteResponse")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/dispute/tx.proto", fileDescriptor_3a591d7bef5d6e8a) }</span>

var fileDescriptor_3a591d7bef5d6e8a = []byte{
        // 604 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0x4f, 0x4f, 0xdb, 0x4e,
        0x10, 0x8d, 0x43, 0xf8, 0x37, 0xf0, 0x83, 0xb0, 0x42, 0x10, 0x0c, 0x32, 0xf9, 0xe5, 0x94, 0xa6,
        0xaa, 0xad, 0xd0, 0x43, 0x25, 0x0e, 0x55, 0x03, 0x81, 0x36, 0x52, 0x03, 0xc8, 0xa4, 0x1c, 0xaa,
        0x4a, 0xc8, 0xb1, 0xb7, 0xc6, 0x52, 0xec, 0xb1, 0x76, 0x37, 0x88, 0xdc, 0xaa, 0x5e, 0xab, 0x4a,
        0xfd, 0x28, 0x5c, 0xfa, 0x1d, 0x38, 0x72, 0xec, 0xa9, 0xaa, 0xe0, 0xc0, 0xd7, 0xa8, 0x6c, 0xaf,
        0x43, 0xe3, 0x54, 0x4a, 0x4f, 0xb6, 0xdf, 0xbc, 0xd9, 0x37, 0xef, 0x8d, 0xb5, 0xb0, 0xd6, 0xb3,
        0x06, 0x94, 0x19, 0x8e, 0xc7, 0xc3, 0xbe, 0xa0, 0x86, 0xb8, 0xd2, 0x43, 0x86, 0x02, 0xc9, 0x7f,
        0x31, 0xae, 0x4b, 0x5c, 0xd5, 0x6c, 0xe4, 0x3e, 0x72, 0xa3, 0x6b, 0x71, 0x6a, 0x5c, 0xd6, 0xbb,
        0x54, 0x58, 0x75, 0xc3, 0x46, 0x2f, 0x48, 0xe8, 0xea, 0xba, 0xac, 0xfb, 0xdc, 0x35, 0x2e, 0xeb,
        0xd1, 0x43, 0x16, 0x56, 0x5d, 0x74, 0x31, 0x7e, 0x35, 0xa2, 0x37, 0x89, 0x6e, 0x8e, 0xaa, 0xca,
        0xa7, 0x2c, 0x6e, 0x27, 0x45, 0x64, 0x96, 0xdd, 0xa3, 0x86, 0xef, 0xd9, 0x0c, 0xcf, 0x19, 0x0d,
        0x91, 0x89, 0x84, 0x50, 0xf9, 0x9a, 0x87, 0x95, 0x36, 0x77, 0x4f, 0x18, 0x86, 0xc8, 0x69, 0x33,
        0x69, 0x26, 0x25, 0x98, 0xb5, 0x19, 0xb5, 0x04, 0xb2, 0x92, 0x52, 0x56, 0xaa, 0xf3, 0x66, 0xfa,
        0x49, 0xea, 0x30, 0x93, 0xf4, 0x97, 0xf2, 0x65, 0xa5, 0xba, 0xb0, 0xb3, 0xa1, 0x27, 0xe6, 0x12,
        0x05, 0xbd, 0x1d, 0x29, 0x98, 0x31, 0xc1, 0x94, 0x44, 0xf2, 0x06, 0x96, 0xe5, 0x50, 0xfb, 0x96,
        0xa0, 0x2e, 0xb2, 0x41, 0x69, 0xaa, 0xac, 0x54, 0x97, 0x76, 0x34, 0x7d, 0x24, 0x18, 0xbd, 0x39,
        0xca, 0x32, 0xb3, 0x6d, 0xa4, 0x0e, 0x53, 0x1f, 0x29, 0x2d, 0x15, 0xa4, 0x72, 0x92, 0x93, 0x1e,
        0xe5, 0xa8, 0xcb, 0x1c, 0xf5, 0x7d, 0xf4, 0x82, 0xbd, 0xc2, 0xcd, 0xcf, 0xed, 0x9c, 0x19, 0x71,
        0x49, 0x19, 0x16, 0x42, 0x6b, 0x70, 0xc8, 0xd0, 0xdf, 0xc3, 0xc0, 0x29, 0x4d, 0x97, 0x95, 0xea,
        0x9c, 0xf9, 0x27, 0xb4, 0xbb, 0xf8, 0xf9, 0xe1, 0xba, 0x96, 0xfa, 0xab, 0x6c, 0xc2, 0xc6, 0x58,
        0x1c, 0x26, 0xe5, 0x21, 0x06, 0x9c, 0x56, 0xbe, 0x2b, 0x40, 0xda, 0xdc, 0x6d, 0x38, 0xce, 0x21,
        0xa5, 0x1d, 0x9c, 0x9c, 0xd6, 0x16, 0xcc, 0x4b, 0x0f, 0x2d, 0x27, 0x0e, 0xac, 0x60, 0x3e, 0x02,
        0xe4, 0x05, 0xcc, 0x58, 0x3e, 0xf6, 0x03, 0x11, 0xe7, 0xf1, 0x0f, 0x8e, 0x24, 0x3d, 0x6b, 0xaa,
        0x30, 0xc9, 0xd4, 0x16, 0xa8, 0xe3, 0x63, 0x0f, 0x5d, 0x5d, 0xc0, 0x6c, 0x9b, 0xbb, 0x67, 0x28,
        0x28, 0x59, 0x85, 0xe9, 0x4b, 0x14, 0x34, 0xf5, 0x91, 0x7c, 0x90, 0x25, 0xc8, 0x7b, 0xe9, 0xf8,
        0x79, 0xcf, 0x21, 0x4f, 0xa1, 0x10, 0x15, 0xe4, 0x16, 0xd7, 0x33, 0x5b, 0x8c, 0x0e, 0x3a, 0x08,
        0xfa, 0xbe, 0x19, 0x93, 0x76, 0x21, 0x9a, 0x24, 0x39, 0xa8, 0xb2, 0x02, 0xcb, 0x52, 0x29, 0x15,
        0xaf, 0xbd, 0x82, 0xb9, 0xb4, 0x81, 0x14, 0x61, 0xf1, 0xec, 0xb8, 0x73, 0x70, 0xde, 0x3a, 0x3a,
        0x6b, 0xbc, 0x6d, 0x35, 0x8b, 0xb9, 0x21, 0x72, 0xfa, 0xee, 0xe4, 0xe4, 0xd8, 0xec, 0x14, 0x95,
        0x21, 0xd2, 0x78, 0xdd, 0x68, 0x1d, 0x9d, 0x76, 0x8a, 0xf9, 0x9d, 0x2f, 0x79, 0x98, 0x6a, 0x73,
        0x97, 0x7c, 0x80, 0xa5, 0xcc, 0x5f, 0x5c, 0xce, 0x4c, 0x36, 0xb6, 0x58, 0xb5, 0x3a, 0x89, 0x91,
        0xce, 0x49, 0xce, 0x61, 0x39, 0xbb, 0xf6, 0xff, 0xc7, 0x9b, 0x33, 0x14, 0xf5, 0xc9, 0x44, 0xca,
        0x50, 0xe0, 0x25, 0x14, 0xe2, 0x15, 0xac, 0x8d, 0xb7, 0x44, 0xb8, 0xaa, 0xfd, 0x1d, 0x4f, 0xfb,
        0xd5, 0xe9, 0x4f, 0x0f, 0xd7, 0x35, 0x65, 0xaf, 0x79, 0x73, 0xa7, 0x29, 0xb7, 0x77, 0x9a, 0xf2,
        0xeb, 0x4e, 0x53, 0xbe, 0xdd, 0x6b, 0xb9, 0xdb, 0x7b, 0x2d, 0xf7, 0xe3, 0x5e, 0xcb, 0xbd, 0xaf,
        0xb9, 0x9e, 0xb8, 0xe8, 0x77, 0x75, 0x1b, 0x7d, 0x43, 0xd0, 0x5e, 0x0f, 0xd9, 0x33, 0x0f, 0x8d,
        0xe4, 0x7e, 0xb8, 0x7a, 0xbc, 0xb4, 0x06, 0x21, 0xe5, 0xdd, 0x99, 0xf8, 0x72, 0x78, 0xfe, 0x3b,
        0x00, 0x00, 0xff, 0xff, 0x1e, 0x6b, 0x52, 0xc0, 0xd2, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
        ProposeDispute(ctx context.Context, in *MsgProposeDispute, opts ...grpc.CallOption) (*MsgProposeDisputeResponse, error)
        AddFeeToDispute(ctx context.Context, in *MsgAddFeeToDispute, opts ...grpc.CallOption) (*MsgAddFeeToDisputeResponse, error)
        Vote(ctx context.Context, in *MsgVote, opts ...grpc.CallOption) (*MsgVoteResponse, error)
}

type msgClient struct {
        cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient <span class="cov0" title="0">{
        return &amp;msgClient{cc}
}</span>

func (c *msgClient) ProposeDispute(ctx context.Context, in *MsgProposeDispute, opts ...grpc.CallOption) (*MsgProposeDisputeResponse, error) <span class="cov0" title="0">{
        out := new(MsgProposeDisputeResponse)
        err := c.cc.Invoke(ctx, "/layer.dispute.Msg/ProposeDispute", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgClient) AddFeeToDispute(ctx context.Context, in *MsgAddFeeToDispute, opts ...grpc.CallOption) (*MsgAddFeeToDisputeResponse, error) <span class="cov0" title="0">{
        out := new(MsgAddFeeToDisputeResponse)
        err := c.cc.Invoke(ctx, "/layer.dispute.Msg/AddFeeToDispute", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgClient) Vote(ctx context.Context, in *MsgVote, opts ...grpc.CallOption) (*MsgVoteResponse, error) <span class="cov0" title="0">{
        out := new(MsgVoteResponse)
        err := c.cc.Invoke(ctx, "/layer.dispute.Msg/Vote", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
        ProposeDispute(context.Context, *MsgProposeDispute) (*MsgProposeDisputeResponse, error)
        AddFeeToDispute(context.Context, *MsgAddFeeToDispute) (*MsgAddFeeToDisputeResponse, error)
        Vote(context.Context, *MsgVote) (*MsgVoteResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) ProposeDispute(ctx context.Context, req *MsgProposeDispute) (*MsgProposeDisputeResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ProposeDispute not implemented")
}</span>
func (*UnimplementedMsgServer) AddFeeToDispute(ctx context.Context, req *MsgAddFeeToDispute) (*MsgAddFeeToDisputeResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AddFeeToDispute not implemented")
}</span>
func (*UnimplementedMsgServer) Vote(ctx context.Context, req *MsgVote) (*MsgVoteResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Vote not implemented")
}</span>

func RegisterMsgServer(s grpc1.Server, srv MsgServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;_Msg_serviceDesc, srv)
}</span>

func _Msg_ProposeDispute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgProposeDispute)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).ProposeDispute(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.dispute.Msg/ProposeDispute",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).ProposeDispute(ctx, req.(*MsgProposeDispute))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Msg_AddFeeToDispute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgAddFeeToDispute)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).AddFeeToDispute(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.dispute.Msg/AddFeeToDispute",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).AddFeeToDispute(ctx, req.(*MsgAddFeeToDispute))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Msg_Vote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgVote)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).Vote(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.dispute.Msg/Vote",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).Vote(ctx, req.(*MsgVote))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _Msg_serviceDesc = grpc.ServiceDesc{
        ServiceName: "layer.dispute.Msg",
        HandlerType: (*MsgServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "ProposeDispute",
                        Handler:    _Msg_ProposeDispute_Handler,
                },
                {
                        MethodName: "AddFeeToDispute",
                        Handler:    _Msg_AddFeeToDispute_Handler,
                },
                {
                        MethodName: "Vote",
                        Handler:    _Msg_Vote_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "layer/dispute/tx.proto",
}

func (m *MsgProposeDispute) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgProposeDispute) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgProposeDispute) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.PayFromBond </span><span class="cov0" title="0">{
                i--
                if m.PayFromBond </span><span class="cov0" title="0">{
                        dAtA[i] = 1
                }</span> else<span class="cov0" title="0"> {
                        dAtA[i] = 0
                }</span>
                <span class="cov0" title="0">i--
                dAtA[i] = 0x28</span>
        }
        <span class="cov0" title="0">{
                size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintTx(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x22
        if m.DisputeCategory != 0 </span><span class="cov0" title="0">{
                i = encodeVarintTx(dAtA, i, uint64(m.DisputeCategory))
                i--
                dAtA[i] = 0x18
        }</span>
        <span class="cov0" title="0">if m.Report != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Report.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintTx(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov0" title="0">if len(m.Creator) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Creator)
                copy(dAtA[i:], m.Creator)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgProposeDisputeResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgProposeDisputeResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgProposeDisputeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgAddFeeToDispute) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgAddFeeToDispute) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgAddFeeToDispute) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.PayFromBond </span><span class="cov0" title="0">{
                i--
                if m.PayFromBond </span><span class="cov0" title="0">{
                        dAtA[i] = 1
                }</span> else<span class="cov0" title="0"> {
                        dAtA[i] = 0
                }</span>
                <span class="cov0" title="0">i--
                dAtA[i] = 0x20</span>
        }
        <span class="cov0" title="0">{
                size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintTx(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x1a
        if m.DisputeId != 0 </span><span class="cov0" title="0">{
                i = encodeVarintTx(dAtA, i, uint64(m.DisputeId))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.Creator) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Creator)
                copy(dAtA[i:], m.Creator)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgAddFeeToDisputeResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgAddFeeToDisputeResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgAddFeeToDisputeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgVote) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgVote) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgVote) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Vote != 0 </span><span class="cov0" title="0">{
                i = encodeVarintTx(dAtA, i, uint64(m.Vote))
                i--
                dAtA[i] = 0x18
        }</span>
        <span class="cov0" title="0">if m.Id != 0 </span><span class="cov0" title="0">{
                i = encodeVarintTx(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.Voter) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Voter)
                copy(dAtA[i:], m.Voter)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Voter)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgVoteResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgVoteResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgVoteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func encodeVarintTx(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovTx(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *MsgProposeDispute) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Creator)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Report != nil </span><span class="cov0" title="0">{
                l = m.Report.Size()
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.DisputeCategory != 0 </span><span class="cov0" title="0">{
                n += 1 + sovTx(uint64(m.DisputeCategory))
        }</span>
        <span class="cov0" title="0">l = m.Fee.Size()
        n += 1 + l + sovTx(uint64(l))
        if m.PayFromBond </span><span class="cov0" title="0">{
                n += 2
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgProposeDisputeResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgAddFeeToDispute) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Creator)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.DisputeId != 0 </span><span class="cov0" title="0">{
                n += 1 + sovTx(uint64(m.DisputeId))
        }</span>
        <span class="cov0" title="0">l = m.Amount.Size()
        n += 1 + l + sovTx(uint64(l))
        if m.PayFromBond </span><span class="cov0" title="0">{
                n += 2
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgAddFeeToDisputeResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgVote) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Voter)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Id != 0 </span><span class="cov0" title="0">{
                n += 1 + sovTx(uint64(m.Id))
        }</span>
        <span class="cov0" title="0">if m.Vote != 0 </span><span class="cov0" title="0">{
                n += 1 + sovTx(uint64(m.Vote))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgVoteResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func sovTx(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozTx(x uint64) (n int) <span class="cov0" title="0">{
        return sovTx(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *MsgProposeDispute) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgProposeDispute: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgProposeDispute: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Creator = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Report", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Report == nil </span><span class="cov0" title="0">{
                                m.Report = &amp;types.MicroReport{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Report.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DisputeCategory", wireType)
                        }</span>
                        <span class="cov0" title="0">m.DisputeCategory = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.DisputeCategory |= DisputeCategory(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 5:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PayFromBond", wireType)
                        }</span>
                        <span class="cov0" title="0">var v int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                v |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">m.PayFromBond = bool(v != 0)</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgProposeDisputeResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgProposeDisputeResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgProposeDisputeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgAddFeeToDispute) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddFeeToDispute: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddFeeToDispute: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Creator = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DisputeId", wireType)
                        }</span>
                        <span class="cov0" title="0">m.DisputeId = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.DisputeId |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PayFromBond", wireType)
                        }</span>
                        <span class="cov0" title="0">var v int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                v |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">m.PayFromBond = bool(v != 0)</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgAddFeeToDisputeResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddFeeToDisputeResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddFeeToDisputeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgVote) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgVote: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgVote: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Voter", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Voter = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 3:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Vote = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Vote |= VoteEnum(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgVoteResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgVoteResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgVoteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipTx(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupTx
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthTx
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file73" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/dispute/vote.proto

package types

import (
        fmt "fmt"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
        _ "google.golang.org/protobuf/types/known/timestamppb"
        io "io"
        math "math"
        math_bits "math/bits"
        time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type VoteResult int32

const (
        VoteResult_NO_TALLY                   VoteResult = 0
        VoteResult_SUPPORT                    VoteResult = 1
        VoteResult_AGAINST                    VoteResult = 2
        VoteResult_INVALID                    VoteResult = 3
        VoteResult_NO_QUORUM_MAJORITY_SUPPORT VoteResult = 4
        VoteResult_NO_QUORUM_MAJORITY_AGAINST VoteResult = 5
        VoteResult_NO_QUORUM_MAJORITY_INVALID VoteResult = 6
)

var VoteResult_name = map[int32]string{
        0: "NO_TALLY",
        1: "SUPPORT",
        2: "AGAINST",
        3: "INVALID",
        4: "NO_QUORUM_MAJORITY_SUPPORT",
        5: "NO_QUORUM_MAJORITY_AGAINST",
        6: "NO_QUORUM_MAJORITY_INVALID",
}

var VoteResult_value = map[string]int32{
        "NO_TALLY":                   0,
        "SUPPORT":                    1,
        "AGAINST":                    2,
        "INVALID":                    3,
        "NO_QUORUM_MAJORITY_SUPPORT": 4,
        "NO_QUORUM_MAJORITY_AGAINST": 5,
        "NO_QUORUM_MAJORITY_INVALID": 6,
}

func (x VoteResult) String() string <span class="cov0" title="0">{
        return proto.EnumName(VoteResult_name, int32(x))
}</span>

func (VoteResult) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_1b528b9404bfff75, []int{0}
}</span>

type Vote struct {
        Id         uint64     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        VoteStart  time.Time  `protobuf:"bytes,2,opt,name=voteStart,proto3,stdtime" json:"voteStart"`
        VoteEnd    time.Time  `protobuf:"bytes,3,opt,name=voteEnd,proto3,stdtime" json:"voteEnd"`
        VoteResult VoteResult `protobuf:"varint,4,opt,name=voteResult,proto3,enum=layer.dispute.VoteResult" json:"voteResult,omitempty"`
        Voters     []string   `protobuf:"bytes,5,rep,name=voters,proto3" json:"voters,omitempty"`
        Executed   bool       `protobuf:"varint,6,opt,name=executed,proto3" json:"executed,omitempty"`
}

func (m *Vote) Reset()         <span class="cov0" title="0">{ *m = Vote{} }</span>
func (m *Vote) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Vote) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Vote) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_1b528b9404bfff75, []int{0}
}</span>
func (m *Vote) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Vote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Vote.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Vote) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Vote.Merge(m, src)
}</span>
func (m *Vote) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Vote) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Vote.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Vote proto.InternalMessageInfo

func (m *Vote) GetId() uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Vote) GetVoteStart() time.Time <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VoteStart
        }</span>
        <span class="cov0" title="0">return time.Time{}</span>
}

func (m *Vote) GetVoteEnd() time.Time <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VoteEnd
        }</span>
        <span class="cov0" title="0">return time.Time{}</span>
}

func (m *Vote) GetVoteResult() VoteResult <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VoteResult
        }</span>
        <span class="cov0" title="0">return VoteResult_NO_TALLY</span>
}

func (m *Vote) GetVoters() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Voters
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Vote) GetExecuted() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Executed
        }</span>
        <span class="cov0" title="0">return false</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterEnum("layer.dispute.VoteResult", VoteResult_name, VoteResult_value)
        proto.RegisterType((*Vote)(nil), "layer.dispute.Vote")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/dispute/vote.proto", fileDescriptor_1b528b9404bfff75) }</span>

var fileDescriptor_1b528b9404bfff75 = []byte{
        // 400 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x92, 0xc1, 0x8e, 0x93, 0x40,
        0x1c, 0xc6, 0x19, 0xca, 0xb2, 0xec, 0xac, 0x6e, 0xc8, 0xc4, 0x18, 0xe4, 0x40, 0x89, 0x27, 0xb2,
        0x89, 0x43, 0xb2, 0x9e, 0xbc, 0x98, 0xd0, 0xac, 0x31, 0x98, 0x2e, 0xd4, 0x29, 0x6d, 0x52, 0x2f,
        0xa4, 0x2d, 0x23, 0x92, 0x50, 0x87, 0xc0, 0x60, 0xda, 0x47, 0xf0, 0xd6, 0x57, 0xf0, 0x6d, 0x7a,
        0xec, 0xd1, 0x93, 0x9a, 0xf6, 0x45, 0x0c, 0x50, 0x5a, 0x3d, 0xf4, 0xb0, 0xb7, 0xff, 0x8f, 0xef,
        0xff, 0x7d, 0x5f, 0x98, 0xfc, 0xa1, 0x96, 0x4e, 0x57, 0x34, 0xb7, 0xa3, 0xa4, 0xc8, 0x4a, 0x4e,
        0xed, 0x6f, 0x8c, 0x53, 0x9c, 0xe5, 0x8c, 0x33, 0xf4, 0xb4, 0x56, 0xf0, 0x41, 0xd1, 0xbb, 0x31,
        0x63, 0x71, 0x4a, 0xed, 0x5a, 0x9c, 0x95, 0x9f, 0x6d, 0x9e, 0x2c, 0x68, 0xc1, 0xa7, 0x8b, 0xac,
        0xd9, 0xd7, 0x9f, 0xc5, 0x2c, 0x66, 0xf5, 0x68, 0x57, 0x53, 0xf3, 0xf5, 0xe5, 0x77, 0x11, 0x4a,
        0x63, 0xc6, 0x29, 0xba, 0x81, 0x62, 0x12, 0x69, 0xc0, 0x04, 0x96, 0x44, 0xc4, 0x24, 0x42, 0x3d,
        0x78, 0x55, 0x95, 0x0d, 0xf9, 0x34, 0xe7, 0x9a, 0x68, 0x02, 0xeb, 0xfa, 0x4e, 0xc7, 0x4d, 0x07,
        0x6e, 0x3b, 0x70, 0xd0, 0x76, 0xf4, 0x94, 0xcd, 0xaf, 0xae, 0xb0, 0xfe, 0xdd, 0x05, 0xe4, 0x64,
        0x43, 0x6f, 0xe1, 0x65, 0x05, 0xef, 0xbe, 0x46, 0x5a, 0xe7, 0x11, 0x09, 0xad, 0x09, 0xbd, 0x81,
        0xb0, 0x1a, 0x09, 0x2d, 0xca, 0x94, 0x6b, 0x92, 0x09, 0xac, 0x9b, 0xbb, 0x17, 0xf8, 0xbf, 0xff,
        0xc6, 0xe3, 0xe3, 0x02, 0xf9, 0x67, 0x19, 0x3d, 0x87, 0x72, 0x45, 0x79, 0xa1, 0x5d, 0x98, 0x1d,
        0xeb, 0x8a, 0x1c, 0x08, 0xe9, 0x50, 0xa1, 0x4b, 0x3a, 0x2f, 0x39, 0x8d, 0x34, 0xd9, 0x04, 0x96,
        0x42, 0x8e, 0x7c, 0xfb, 0x03, 0x40, 0x78, 0x8a, 0x43, 0x4f, 0xa0, 0xe2, 0xf9, 0x61, 0xe0, 0xf4,
        0xfb, 0x13, 0x55, 0x40, 0xd7, 0xf0, 0x72, 0x38, 0x1a, 0x0c, 0x7c, 0x12, 0xa8, 0xa0, 0x02, 0xe7,
        0xbd, 0xe3, 0x7a, 0xc3, 0x40, 0x15, 0x2b, 0x70, 0xbd, 0xb1, 0xd3, 0x77, 0xef, 0xd5, 0x0e, 0x32,
        0xa0, 0xee, 0xf9, 0xe1, 0xc7, 0x91, 0x4f, 0x46, 0x0f, 0xe1, 0x83, 0xf3, 0xc1, 0x27, 0x6e, 0x30,
        0x09, 0x5b, 0xa7, 0x74, 0x46, 0x6f, 0xc3, 0x2e, 0xce, 0xe8, 0x6d, 0xbe, 0xdc, 0xbb, 0xdf, 0xec,
        0x0c, 0xb0, 0xdd, 0x19, 0xe0, 0xcf, 0xce, 0x00, 0xeb, 0xbd, 0x21, 0x6c, 0xf7, 0x86, 0xf0, 0x73,
        0x6f, 0x08, 0x9f, 0x6e, 0xe3, 0x84, 0x7f, 0x29, 0x67, 0x78, 0xce, 0x16, 0x36, 0xa7, 0x69, 0xca,
        0xf2, 0x57, 0x09, 0xb3, 0x9b, 0xf3, 0x59, 0x1e, 0x0f, 0x88, 0xaf, 0x32, 0x5a, 0xcc, 0xe4, 0xfa,
        0xfd, 0x5f, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0xd2, 0xc3, 0xb8, 0xfd, 0x5e, 0x02, 0x00, 0x00,
}

func (m *Vote) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Vote) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Vote) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Executed </span><span class="cov0" title="0">{
                i--
                if m.Executed </span><span class="cov0" title="0">{
                        dAtA[i] = 1
                }</span> else<span class="cov0" title="0"> {
                        dAtA[i] = 0
                }</span>
                <span class="cov0" title="0">i--
                dAtA[i] = 0x30</span>
        }
        <span class="cov0" title="0">if len(m.Voters) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Voters) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        i -= len(m.Voters[iNdEx])
                        copy(dAtA[i:], m.Voters[iNdEx])
                        i = encodeVarintVote(dAtA, i, uint64(len(m.Voters[iNdEx])))
                        i--
                        dAtA[i] = 0x2a
                }</span>
        }
        <span class="cov0" title="0">if m.VoteResult != 0 </span><span class="cov0" title="0">{
                i = encodeVarintVote(dAtA, i, uint64(m.VoteResult))
                i--
                dAtA[i] = 0x20
        }</span>
        <span class="cov0" title="0">n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.VoteEnd, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.VoteEnd):])
        if err1 != nil </span><span class="cov0" title="0">{
                return 0, err1
        }</span>
        <span class="cov0" title="0">i -= n1
        i = encodeVarintVote(dAtA, i, uint64(n1))
        i--
        dAtA[i] = 0x1a
        n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.VoteStart, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.VoteStart):])
        if err2 != nil </span><span class="cov0" title="0">{
                return 0, err2
        }</span>
        <span class="cov0" title="0">i -= n2
        i = encodeVarintVote(dAtA, i, uint64(n2))
        i--
        dAtA[i] = 0x12
        if m.Id != 0 </span><span class="cov0" title="0">{
                i = encodeVarintVote(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintVote(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovVote(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Vote) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Id != 0 </span><span class="cov0" title="0">{
                n += 1 + sovVote(uint64(m.Id))
        }</span>
        <span class="cov0" title="0">l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.VoteStart)
        n += 1 + l + sovVote(uint64(l))
        l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.VoteEnd)
        n += 1 + l + sovVote(uint64(l))
        if m.VoteResult != 0 </span><span class="cov0" title="0">{
                n += 1 + sovVote(uint64(m.VoteResult))
        }</span>
        <span class="cov0" title="0">if len(m.Voters) &gt; 0 </span><span class="cov0" title="0">{
                for _, s := range m.Voters </span><span class="cov0" title="0">{
                        l = len(s)
                        n += 1 + l + sovVote(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">if m.Executed </span><span class="cov0" title="0">{
                n += 2
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovVote(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozVote(x uint64) (n int) <span class="cov0" title="0">{
        return sovVote(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Vote) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowVote
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Vote: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Vote: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowVote
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VoteStart", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowVote
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthVote
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthVote
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&amp;m.VoteStart, dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VoteEnd", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowVote
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthVote
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthVote
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&amp;m.VoteEnd, dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field VoteResult", wireType)
                        }</span>
                        <span class="cov0" title="0">m.VoteResult = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowVote
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.VoteResult |= VoteResult(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 5:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Voters", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowVote
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthVote
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthVote
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Voters = append(m.Voters, string(dAtA[iNdEx:postIndex]))
                        iNdEx = postIndex</span>
                case 6:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Executed", wireType)
                        }</span>
                        <span class="cov0" title="0">var v int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowVote
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                v |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">m.Executed = bool(v != 0)</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipVote(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthVote
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipVote(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowVote
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowVote
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowVote
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthVote
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupVote
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthVote
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthVote        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowVote          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupVote = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file74" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/dispute/voter_classes.proto

package types

import (
        cosmossdk_io_math "cosmossdk.io/math"
        fmt "fmt"
        _ "github.com/cosmos/cosmos-proto"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type VoterClasses struct {
        Validators   cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=validators,proto3,customtype=cosmossdk.io/math.Int" json:"validators"`
        TokenHolders cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=tokenHolders,proto3,customtype=cosmossdk.io/math.Int" json:"tokenHolders"`
        Users        cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=users,proto3,customtype=cosmossdk.io/math.Int" json:"users"`
        Team         cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=team,proto3,customtype=cosmossdk.io/math.Int" json:"team"`
}

func (m *VoterClasses) Reset()         <span class="cov0" title="0">{ *m = VoterClasses{} }</span>
func (m *VoterClasses) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*VoterClasses) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*VoterClasses) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_de6bb69a4f2a19e8, []int{0}
}</span>
func (m *VoterClasses) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *VoterClasses) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_VoterClasses.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *VoterClasses) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_VoterClasses.Merge(m, src)
}</span>
func (m *VoterClasses) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *VoterClasses) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_VoterClasses.DiscardUnknown(m)
}</span>

var xxx_messageInfo_VoterClasses proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*VoterClasses)(nil), "layer.dispute.VoterClasses")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/dispute/voter_classes.proto", fileDescriptor_de6bb69a4f2a19e8) }</span>

var fileDescriptor_de6bb69a4f2a19e8 = []byte{
        // 282 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x52, 0xcc, 0x49, 0xac, 0x4c,
        0x2d, 0xd2, 0x4f, 0xc9, 0x2c, 0x2e, 0x28, 0x2d, 0x49, 0xd5, 0x2f, 0xcb, 0x2f, 0x49, 0x2d, 0x8a,
        0x4f, 0xce, 0x49, 0x2c, 0x2e, 0x4e, 0x2d, 0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x05,
        0x2b, 0xd1, 0x83, 0x2a, 0x91, 0x92, 0x4c, 0xce, 0x2f, 0xce, 0xcd, 0x2f, 0x8e, 0x07, 0x4b, 0xea,
        0x43, 0x38, 0x10, 0x95, 0x52, 0x22, 0xe9, 0xf9, 0xe9, 0xf9, 0x10, 0x71, 0x10, 0x0b, 0x22, 0xaa,
        0xb4, 0x81, 0x89, 0x8b, 0x27, 0x0c, 0x64, 0xae, 0x33, 0xc4, 0x58, 0x21, 0x6f, 0x2e, 0xae, 0xb2,
        0xc4, 0x9c, 0xcc, 0x94, 0xc4, 0x92, 0xfc, 0xa2, 0x62, 0x09, 0x46, 0x05, 0x46, 0x0d, 0x4e, 0x27,
        0xed, 0x13, 0xf7, 0xe4, 0x19, 0x6e, 0xdd, 0x93, 0x17, 0x85, 0x18, 0x58, 0x9c, 0x92, 0xad, 0x97,
        0x99, 0xaf, 0x9f, 0x9b, 0x58, 0x92, 0xa1, 0xe7, 0x99, 0x57, 0x72, 0x69, 0x8b, 0x2e, 0x17, 0xd4,
        0x26, 0xcf, 0xbc, 0x92, 0x20, 0x24, 0xed, 0x42, 0xfe, 0x5c, 0x3c, 0x25, 0xf9, 0xd9, 0xa9, 0x79,
        0x1e, 0xf9, 0x39, 0x29, 0xa9, 0x45, 0xc5, 0x12, 0x4c, 0xa4, 0x1b, 0x87, 0x62, 0x80, 0x90, 0x23,
        0x17, 0x6b, 0x69, 0x31, 0xc8, 0x24, 0x66, 0xd2, 0x4d, 0x82, 0xe8, 0x14, 0xb2, 0xe7, 0x62, 0x29,
        0x49, 0x4d, 0xcc, 0x95, 0x60, 0x21, 0xdd, 0x04, 0xb0, 0x46, 0x27, 0x97, 0x13, 0x8f, 0xe4, 0x18,
        0x2f, 0x3c, 0x92, 0x63, 0x7c, 0xf0, 0x48, 0x8e, 0x71, 0xc2, 0x63, 0x39, 0x86, 0x0b, 0x8f, 0xe5,
        0x18, 0x6e, 0x3c, 0x96, 0x63, 0x88, 0xd2, 0x4a, 0xcf, 0x2c, 0xc9, 0x28, 0x4d, 0xd2, 0x4b, 0xce,
        0xcf, 0xd5, 0x2f, 0x49, 0xcd, 0xc9, 0xc9, 0x2f, 0xd2, 0xcd, 0xcc, 0xd7, 0x87, 0x44, 0x62, 0x05,
        0x3c, 0x1a, 0x4b, 0x2a, 0x0b, 0x52, 0x8b, 0x93, 0xd8, 0xc0, 0xe1, 0x6f, 0x0c, 0x08, 0x00, 0x00,
        0xff, 0xff, 0x26, 0xb6, 0x4f, 0x25, 0xe4, 0x01, 0x00, 0x00,
}

func (m *VoterClasses) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *VoterClasses) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *VoterClasses) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size := m.Team.Size()
                i -= size
                if _, err := m.Team.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintVoterClasses(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x22
        </span><span class="cov0" title="0">{
                size := m.Users.Size()
                i -= size
                if _, err := m.Users.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintVoterClasses(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x1a
        </span><span class="cov0" title="0">{
                size := m.TokenHolders.Size()
                i -= size
                if _, err := m.TokenHolders.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintVoterClasses(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x12
        </span><span class="cov0" title="0">{
                size := m.Validators.Size()
                i -= size
                if _, err := m.Validators.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintVoterClasses(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func encodeVarintVoterClasses(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovVoterClasses(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *VoterClasses) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Validators.Size()
        n += 1 + l + sovVoterClasses(uint64(l))
        l = m.TokenHolders.Size()
        n += 1 + l + sovVoterClasses(uint64(l))
        l = m.Users.Size()
        n += 1 + l + sovVoterClasses(uint64(l))
        l = m.Team.Size()
        n += 1 + l + sovVoterClasses(uint64(l))
        return n</span>
}

func sovVoterClasses(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozVoterClasses(x uint64) (n int) <span class="cov0" title="0">{
        return sovVoterClasses(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *VoterClasses) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowVoterClasses
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VoterClasses: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: VoterClasses: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Validators", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowVoterClasses
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthVoterClasses
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthVoterClasses
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Validators.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field TokenHolders", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowVoterClasses
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthVoterClasses
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthVoterClasses
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.TokenHolders.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowVoterClasses
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthVoterClasses
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthVoterClasses
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Users.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Team", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowVoterClasses
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthVoterClasses
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthVoterClasses
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Team.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipVoterClasses(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthVoterClasses
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipVoterClasses(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowVoterClasses
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowVoterClasses
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowVoterClasses
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthVoterClasses
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupVoterClasses
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthVoterClasses
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthVoterClasses        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowVoterClasses          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupVoterClasses = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file75" style="display: none">package oracle

import (
        "context"

        "github.com/tellor-io/layer/x/oracle/keeper"

        sdk "github.com/cosmos/cosmos-sdk/types"
)

func EndBlocker(ctx context.Context, k keeper.Keeper) error <span class="cov0" title="0">{
        sdkctx := sdk.UnwrapSDKContext(ctx)
        // Rotate through the cycle list and set the current query index
        _ = k.RotateQueries(ctx)
        return k.SetAggregatedReport(sdkctx)
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">package oracle

import (
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/oracle/keeper"
        "github.com/tellor-io/layer/x/oracle/types"
)

// InitGenesis initializes the module's state from a provided genesis state.
func InitGenesis(ctx sdk.Context, k keeper.Keeper, genState types.GenesisState) <span class="cov8" title="1">{
        // this line is used by starport scaffolding # genesis/module/init
        err := k.SetParams(ctx, genState.Params)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">err = k.GenesisCycleList(ctx, genState.Cyclelist)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// ExportGenesis returns the module's exported genesis
func ExportGenesis(ctx sdk.Context, k keeper.Keeper) *types.GenesisState <span class="cov8" title="1">{
        genesis := types.DefaultGenesis()
        params, err := k.GetParams(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">genesis.Params = params

        // this line is used by starport scaffolding # genesis/module/export

        return genesis</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package keeper

import (
        "context"
        "encoding/hex"
        "errors"
        "fmt"
        "time"

        "cosmossdk.io/collections"
        "cosmossdk.io/collections/indexes"
        "cosmossdk.io/math"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/oracle/types"
)

// SetAggregatedReport calculates and allocates rewards to reporters based on aggregated reports.
// at a specific blockchain height (to be ran in end-blocker)
// It retrieves the revealed reports from the reports store, by query.
// calculates the aggregate report for each query using either the weighted-median or weighted-mode method.
// Rewards based on the source are then allocated to the reporters.
func (k Keeper) SetAggregatedReport(ctx sdk.Context) (err error) <span class="cov0" title="0">{

        // aggregate
        idsIterator, err := k.Query.Indexes.HasReveals.MatchExact(ctx, true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">defer idsIterator.Close()
        queries, err := indexes.CollectValues(ctx, k.Query, idsIterator)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var aggrFunc func(ctx context.Context, reports []types.MicroReport) (*types.Aggregate, error)
        reportersToPay := make([]*types.AggregateReporter, 0)
        for _, query := range queries </span><span class="cov0" title="0">{
                if query.Expiration.Add(offset).Before(ctx.BlockTime()) </span><span class="cov0" title="0">{
                        reportsIterator, err := k.Reports.Indexes.Id.MatchExact(ctx, query.Id)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer reportsIterator.Close()
                        reports, err := indexes.CollectValues(ctx, k.Reports, reportsIterator)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // there should always be at least one report otherwise how did the query set hasrevealedreports to true
                        <span class="cov0" title="0">if reports[0].AggregateMethod == "weighted-median" </span><span class="cov0" title="0">{
                                // Calculate the aggregated report.
                                aggrFunc = k.WeightedMedian
                        }</span> else<span class="cov0" title="0"> {
                                // default to weighted-mode aggregation method.
                                // Calculate the aggregated report.
                                aggrFunc = k.WeightedMode
                        }</span>

                        <span class="cov0" title="0">report, err := aggrFunc(ctx, reports)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if !query.Amount.IsZero() </span><span class="cov0" title="0">{
                                err = k.AllocateRewards(ctx, report.Reporters, query.Amount, true)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                // zero out the amount in the query
                                <span class="cov0" title="0">query.Amount = math.ZeroInt()</span>
                        }
                        // Add reporters to the tbr payment list.
                        <span class="cov0" title="0">if reports[0].Cyclelist </span><span class="cov0" title="0">{
                                reportersToPay = append(reportersToPay, report.Reporters...)
                        }</span>

                        <span class="cov0" title="0">query.HasRevealedReports = false
                        err = k.Query.Set(ctx, query.QueryId, query)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        // Process time-based rewards for reporters.
        <span class="cov0" title="0">tbr := k.getTimeBasedRewards(ctx)
        // Allocate time-based rewards to all eligible reporters.
        return k.AllocateRewards(ctx, reportersToPay, tbr, false)</span>
}

func (k Keeper) SetAggregate(ctx context.Context, report *types.Aggregate) error <span class="cov8" title="1">{
        nonce, err := k.Nonces.Get(ctx, report.QueryId)
        if err != nil &amp;&amp; !errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">nonce++
        err = k.Nonces.Set(ctx, report.QueryId, nonce)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">report.Nonce = nonce

        sdkCtx := sdk.UnwrapSDKContext(ctx)
        currentTimestamp := sdkCtx.BlockTime().Unix()
        report.Height = sdkCtx.BlockHeight()

        return k.Aggregates.Set(ctx, collections.Join(report.QueryId, currentTimestamp), *report)</span>
}

// getDataBefore returns the last aggregate before or at the given timestamp for the given query id.
// TODO: add a test for this function.
func (k Keeper) getDataBefore(ctx context.Context, queryId []byte, timestamp time.Time) (*types.Aggregate, error) <span class="cov0" title="0">{
        rng := collections.NewPrefixedPairRange[[]byte, int64](queryId).EndInclusive(timestamp.Unix()).Descending()
        var mostRecent *types.Aggregate
        // This should get us the most recent aggregate, as they are walked in descending order
        err := k.Aggregates.Walk(ctx, rng, func(key collections.Pair[[]byte, int64], value types.Aggregate) (stop bool, err error) </span><span class="cov0" title="0">{
                if !value.Flagged </span><span class="cov0" title="0">{
                        mostRecent = &amp;value
                        return true, nil
                }</span>
                <span class="cov0" title="0">return false, nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                // why panic here? should we return an error instead?
                panic(err)</span>
        }

        <span class="cov0" title="0">if mostRecent == nil </span><span class="cov0" title="0">{
                return nil, types.ErrNoAvailableReports.Wrapf("no data before timestamp %v available for query id %s", timestamp, hex.EncodeToString(queryId))
        }</span>

        <span class="cov0" title="0">return mostRecent, nil</span>
}

func (k Keeper) GetDataBeforePublic(ctx context.Context, queryId []byte, timestamp time.Time) (*types.Aggregate, error) <span class="cov0" title="0">{
        return k.getDataBefore(ctx, queryId, timestamp)
}</span>

func (k Keeper) GetCurrentValueForQueryId(ctx context.Context, queryId []byte) (*types.Aggregate, error) <span class="cov8" title="1">{
        rng := collections.NewPrefixedPairRange[[]byte, int64](queryId).Descending()
        var mostRecent *types.Aggregate
        // This should get us the most recent aggregate, as they are walked in descending order
        err := k.Aggregates.Walk(ctx, rng, func(key collections.Pair[[]byte, int64], value types.Aggregate) (stop bool, err error) </span><span class="cov8" title="1">{
                mostRecent = &amp;value
                return true, nil
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return mostRecent, nil</span>
}

func (k Keeper) GetTimestampBefore(ctx context.Context, queryId []byte, timestamp time.Time) (time.Time, error) <span class="cov8" title="1">{
        rng := collections.NewPrefixedPairRange[[]byte, int64](queryId).EndExclusive(timestamp.Unix()).Descending()
        var mostRecent int64
        err := k.Aggregates.Walk(ctx, rng, func(key collections.Pair[[]byte, int64], value types.Aggregate) (stop bool, err error) </span><span class="cov8" title="1">{
                mostRecent = key.K2()
                return true, nil
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">if mostRecent == 0 </span><span class="cov8" title="1">{
                return time.Time{}, fmt.Errorf("no data before timestamp %v available for query id %s", timestamp, hex.EncodeToString(queryId))
        }</span>

        <span class="cov8" title="1">return time.Unix(mostRecent, 0), nil</span>
}

func (k Keeper) GetTimestampAfter(ctx context.Context, queryId []byte, timestamp time.Time) (time.Time, error) <span class="cov8" title="1">{
        rng := collections.NewPrefixedPairRange[[]byte, int64](queryId).StartExclusive(timestamp.Unix())
        var mostRecent int64
        err := k.Aggregates.Walk(ctx, rng, func(key collections.Pair[[]byte, int64], value types.Aggregate) (stop bool, err error) </span><span class="cov8" title="1">{
                mostRecent = key.K2()
                return true, nil
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">if mostRecent == 0 </span><span class="cov8" title="1">{
                return time.Time{}, fmt.Errorf("no data before timestamp %v available for query id %s", timestamp, hex.EncodeToString(queryId))
        }</span>

        <span class="cov8" title="1">return time.Unix(mostRecent, 0), nil</span>
}

func (k Keeper) GetAggregatedReportsByHeight(ctx context.Context, height int64) []types.Aggregate <span class="cov0" title="0">{
        iter, err := k.Aggregates.Indexes.BlockHeight.MatchExact(ctx, height)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">kvs, err := indexes.CollectKeyValues(ctx, k.Aggregates, iter)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">reports := make([]types.Aggregate, len(kvs))
        for i, kv := range kvs </span><span class="cov0" title="0">{
                reports[i] = kv.Value
        }</span>

        <span class="cov0" title="0">return reports</span>
}

func (k Keeper) GetCurrentAggregateReport(ctx context.Context, queryId []byte) (aggregate *types.Aggregate, timestamp time.Time) <span class="cov0" title="0">{
        rng := collections.NewPrefixedPairRange[[]byte, int64](queryId).Descending()
        err := k.Aggregates.Walk(ctx, rng, func(key collections.Pair[[]byte, int64], value types.Aggregate) (stop bool, err error) </span><span class="cov0" title="0">{
                aggregate = &amp;value
                timestamp = time.Unix(key.K2(), 0)
                return true, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // Handle the error appropriately
        }
        <span class="cov0" title="0">return aggregate, timestamp</span>
}

func (k Keeper) GetAggregateBefore(ctx context.Context, queryId []byte, timestampBefore time.Time) (aggregate *types.Aggregate, timestamp time.Time, err error) <span class="cov0" title="0">{
        // Convert the timestampBefore to Unix time and create a range that ends just before this timestamp
        rng := collections.NewPrefixedPairRange[[]byte, int64](queryId).EndExclusive(timestampBefore.Unix()).Descending()

        var mostRecent *types.Aggregate
        var mostRecentTimestamp int64

        // Walk through the aggregates in descending order to find the most recent one before timestampBefore
        err = k.Aggregates.Walk(ctx, rng, func(key collections.Pair[[]byte, int64], value types.Aggregate) (stop bool, err error) </span><span class="cov0" title="0">{
                mostRecent = &amp;value
                mostRecentTimestamp = key.K2()
                return true, nil // Stop after the first (most recent) match
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, time.Time{}, err
        }</span>

        <span class="cov0" title="0">if mostRecent == nil </span><span class="cov0" title="0">{
                return nil, time.Time{}, fmt.Errorf("no aggregate report found before timestamp %v for query id %s", timestampBefore, hex.EncodeToString(queryId))
        }</span>

        // Convert the Unix timestamp back to time.Time
        <span class="cov0" title="0">timestamp = time.Unix(mostRecentTimestamp, 0)
        return mostRecent, timestamp, nil</span>
}

func (k Keeper) GetAggregateByTimestamp(ctx sdk.Context, queryId []byte, timestamp time.Time) (aggregate *types.Aggregate, err error) <span class="cov0" title="0">{
        timestampUnix := timestamp.Unix()

        // Create a range that specifically targets the exact timestamp
        rng := collections.NewPrefixedPairRange[[]byte, int64](queryId).StartInclusive(timestampUnix).EndInclusive(timestampUnix)

        // Walk through the aggregates to find the one that exactly matches the timestamp
        err = k.Aggregates.Walk(ctx, rng, func(key collections.Pair[[]byte, int64], value types.Aggregate) (stop bool, err error) </span><span class="cov0" title="0">{
                if key.K2() == timestampUnix </span><span class="cov0" title="0">{
                        aggregate = &amp;value
                        return true, nil // Stop when the exact match is found
                }</span>
                <span class="cov0" title="0">return false, nil</span> // Continue if this is not the exact match
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if aggregate == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no aggregate report found at timestamp %v for query id %s", timestamp, hex.EncodeToString(queryId))
        }</span>

        <span class="cov0" title="0">return aggregate, nil</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package keeper

import (
        "context"

        "github.com/tellor-io/layer/utils"
        "github.com/tellor-io/layer/x/oracle/types"
)

func (k Keeper) GetCyclelist(ctx context.Context) ([][]byte, error) <span class="cov8" title="1">{

        iter, err := k.Cyclelist.Iterate(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">q, err := iter.Values()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return q, nil</span>
}

// rotation of the cycle list
func (k Keeper) RotateQueries(ctx context.Context) error <span class="cov8" title="1">{
        // todo: better to set length of cycle list as an item and read that
        // so we don't do this read operation every time

        q, err := k.GetCyclelist(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">n, err := k.CyclelistSequencer.Next(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">max := len(q)
        switch </span>{
        case n == uint64(max-1):<span class="cov8" title="1">
                return k.CyclelistSequencer.Set(ctx, 0)</span>
        default:<span class="cov8" title="1">
                return nil</span>
        }

}

func (k Keeper) GetCurrentQueryInCycleList(ctx context.Context) ([]byte, error) <span class="cov8" title="1">{
        idx, err := k.CyclelistSequencer.Peek(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">q, err := k.GetCyclelist(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return q[idx], nil</span>
}

// should be called only once when updating the cycle list
func (k Keeper) InitCycleListQuery(ctx context.Context, queries [][]byte) error <span class="cov0" title="0">{

        for _, querydata := range queries </span><span class="cov0" title="0">{

                query, err := k.initializeQuery(ctx, querydata)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">queryId := utils.QueryIDFromData(querydata)
                err = k.Query.Set(ctx, queryId, query)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err = k.Cyclelist.Set(ctx, queryId, querydata)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (k Keeper) GenesisCycleList(ctx context.Context, cyclelist [][]byte) error <span class="cov8" title="1">{

        for _, queryData := range cyclelist </span><span class="cov8" title="1">{
                queryId := utils.QueryIDFromData(queryData)

                nextId, err := k.QuerySequnecer.Next(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">meta := types.QueryMeta{
                        Id:                    nextId,
                        RegistrySpecTimeframe: 0,
                        QueryId:               queryId,
                }
                err = k.Query.Set(ctx, queryId, meta)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">err = k.Cyclelist.Set(ctx, queryId, queryData)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package keeper

import (
        "context"

        "github.com/tellor-io/layer/x/oracle/types"

        rtypes "github.com/tellor-io/layer/x/registry/types"
)

var _ types.RegistryHooks = Hooks{}

// Hooks wrapper struct for oracle keeper
type Hooks struct {
        k Keeper
}

// Return the oracle hooks
func (k Keeper) Hooks() Hooks <span class="cov0" title="0">{
        return Hooks{k}
}</span>

func (h Hooks) AfterDataSpecUpdated(ctx context.Context, querytype string, dataspec rtypes.DataSpec) error <span class="cov0" title="0">{
        return h.k.UpdateQuery(ctx, querytype, dataspec.ReportBufferWindow)
}</span>
</pre>
		
		<pre class="file" id="file80" style="display: none">package keeper

import (
        "cosmossdk.io/collections"
        "cosmossdk.io/collections/indexes"
        "cosmossdk.io/math"
        "github.com/tellor-io/layer/x/oracle/types"
)

type tipsIndex struct {
        Tipper *indexes.Multi[[]byte, collections.Pair[[]byte, []byte], math.Int]
}

func (a tipsIndex) IndexesList() []collections.Index[collections.Pair[[]byte, []byte], math.Int] <span class="cov0" title="0">{
        return []collections.Index[collections.Pair[[]byte, []byte], math.Int]{a.Tipper}
}</span>

func NewTipsIndex(sb *collections.SchemaBuilder) tipsIndex <span class="cov8" title="1">{
        return tipsIndex{
                Tipper: indexes.NewMulti(
                        sb, types.TipsIndexPrefix, "tips_by_tipper",
                        collections.BytesKey, collections.PairKeyCodec[[]byte, []byte](collections.BytesKey, collections.BytesKey),
                        func(k collections.Pair[[]byte, []byte], _ math.Int) ([]byte, error) </span><span class="cov0" title="0">{
                                return k.K2(), nil
                        }</span>,
                ),
        }
}

type aggregatesIndex struct {
        BlockHeight *indexes.Multi[int64, collections.Pair[[]byte, int64], types.Aggregate]
}

func (a aggregatesIndex) IndexesList() []collections.Index[collections.Pair[[]byte, int64], types.Aggregate] <span class="cov8" title="1">{
        return []collections.Index[collections.Pair[[]byte, int64], types.Aggregate]{
                a.BlockHeight,
        }
}</span>

func NewAggregatesIndex(sb *collections.SchemaBuilder) aggregatesIndex <span class="cov8" title="1">{
        return aggregatesIndex{
                BlockHeight: indexes.NewMulti(
                        sb, types.AggregatesHeightIndexPrefix, "aggregates_by_height",
                        collections.Int64Key, collections.PairKeyCodec[[]byte, int64](collections.BytesKey, collections.Int64Key),
                        func(_ collections.Pair[[]byte, int64], v types.Aggregate) (int64, error) </span><span class="cov8" title="1">{
                                return v.Height, nil
                        }</span>,
                ),
        }
}

type reportsIndex struct {
        Id       *indexes.Multi[uint64, collections.Triple[[]byte, []byte, uint64], types.MicroReport]
        Reporter *indexes.Multi[[]byte, collections.Triple[[]byte, []byte, uint64], types.MicroReport]
}

func (a reportsIndex) IndexesList() []collections.Index[collections.Triple[[]byte, []byte, uint64], types.MicroReport] <span class="cov8" title="1">{
        return []collections.Index[collections.Triple[[]byte, []byte, uint64], types.MicroReport]{
                a.Id,
                a.Reporter,
        }
}</span>

func NewReportsIndex(sb *collections.SchemaBuilder) reportsIndex <span class="cov8" title="1">{
        return reportsIndex{
                Id: indexes.NewMulti(
                        sb, types.ReportsHeightIndexPrefix, "reports_by_id",
                        collections.Uint64Key, collections.TripleKeyCodec[[]byte, []byte, uint64](collections.BytesKey, collections.BytesKey, collections.Uint64Key),
                        func(k collections.Triple[[]byte, []byte, uint64], _ types.MicroReport) (uint64, error) </span><span class="cov8" title="1">{
                                return k.K3(), nil
                        }</span>,
                ),
                Reporter: indexes.NewMulti(
                        sb, types.ReportsReporterIndexPrefix, "reports_by_reporter",
                        collections.BytesKey, collections.TripleKeyCodec[[]byte, []byte, uint64](collections.BytesKey, collections.BytesKey, collections.Uint64Key),
                        func(k collections.Triple[[]byte, []byte, uint64], _ types.MicroReport) ([]byte, error) <span class="cov8" title="1">{
                                return k.K2(), nil
                        }</span>,
                ),
        }
}

type queryMetaIndex struct {
        HasReveals *indexes.Multi[bool, []byte, types.QueryMeta]
        QueryType  *indexes.Multi[string, []byte, types.QueryMeta]
}

func (a queryMetaIndex) IndexesList() []collections.Index[[]byte, types.QueryMeta] <span class="cov8" title="1">{
        return []collections.Index[[]byte, types.QueryMeta]{a.HasReveals, a.QueryType}
}</span>

func NewQueryIndex(sb *collections.SchemaBuilder) queryMetaIndex <span class="cov8" title="1">{
        return queryMetaIndex{
                HasReveals: indexes.NewMulti(
                        sb, types.QueryRevealedIdsIndexPrefix, "query_by_revealed",
                        collections.BoolKey, collections.BytesKey,
                        func(_ []byte, v types.QueryMeta) (bool, error) </span><span class="cov8" title="1">{
                                return v.HasRevealedReports, nil
                        }</span>,
                ),
                QueryType: indexes.NewMulti(
                        sb, types.QueryTypeIndexPrefix, "query_by_type",
                        collections.StringKey, collections.BytesKey,
                        func(_ []byte, v types.QueryMeta) (string, error) <span class="cov8" title="1">{
                                return v.QueryType, nil
                        }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package keeper

import (
        "context"
        "fmt"
        "time"

        "cosmossdk.io/collections"
        "cosmossdk.io/collections/indexes"
        "cosmossdk.io/core/store"
        "cosmossdk.io/log"
        "cosmossdk.io/math"
        "github.com/cosmos/cosmos-sdk/codec"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/utils"
        "github.com/tellor-io/layer/x/oracle/types"
        regTypes "github.com/tellor-io/layer/x/registry/types"
)

var offset = time.Second * 3

type (
        Keeper struct {
                cdc            codec.BinaryCodec
                storeService   store.KVStoreService
                Params         collections.Item[types.Params]
                accountKeeper  types.AccountKeeper
                bankKeeper     types.BankKeeper
                registryKeeper types.RegistryKeeper
                reporterKeeper types.ReporterKeeper
                Schema         collections.Schema
                Commits        collections.Map[collections.Pair[[]byte, uint64], types.Commit]                                      // key: reporter, queryid
                Tips           *collections.IndexedMap[collections.Pair[[]byte, []byte], math.Int, tipsIndex]                       // key: queryId, tipper
                TotalTips      collections.Item[math.Int]                                                                           // keep track of the total tips                                  // key: queryId, timestamp
                Nonces         collections.Map[[]byte, uint64]                                                                      // key: queryId
                Reports        *collections.IndexedMap[collections.Triple[[]byte, []byte, uint64], types.MicroReport, reportsIndex] // key: queryId, reporter, query.id
                QuerySequnecer collections.Sequence
                Query          *collections.IndexedMap[[]byte, types.QueryMeta, queryMetaIndex]
                // the address capable of executing a MsgUpdateParams message. Typically, this
                // should be the x/gov module account.                           // key: reporter, queryid                                                                       // keep track of the total tips
                Aggregates         *collections.IndexedMap[collections.Pair[[]byte, int64], types.Aggregate, aggregatesIndex] // key: queryId, timestamp                                                                    // key: queryId                                                                  // keep track of the current cycle
                Cyclelist          collections.Map[[]byte, []byte]
                CyclelistSequencer collections.Sequence
                authority          string
        }
)

func NewKeeper(
        cdc codec.BinaryCodec,
        storeService store.KVStoreService,
        accountKeeper types.AccountKeeper,
        bankKeeper types.BankKeeper,
        registryKeeper types.RegistryKeeper,
        reporterKeeper types.ReporterKeeper,
        authority string,
) Keeper <span class="cov8" title="1">{
        if _, err := sdk.AccAddressFromBech32(authority); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("invalid authority address: %s", authority))</span>
        }

        <span class="cov8" title="1">sb := collections.NewSchemaBuilder(storeService)

        k := Keeper{
                cdc:          cdc,
                storeService: storeService,

                Params:         collections.NewItem(sb, types.ParamsKeyPrefix(), "params", codec.CollValue[types.Params](cdc)),
                accountKeeper:  accountKeeper,
                bankKeeper:     bankKeeper,
                registryKeeper: registryKeeper,
                reporterKeeper: reporterKeeper,

                authority: authority,

                Commits: collections.NewMap(sb, types.CommitsPrefix, "commits", collections.PairKeyCodec(collections.BytesKey, collections.Uint64Key), codec.CollValue[types.Commit](cdc)),
                Tips: collections.NewIndexedMap(sb,
                        types.TipsPrefix,
                        "tips",
                        collections.PairKeyCodec(collections.BytesKey, collections.BytesKey),
                        sdk.IntValue,
                        NewTipsIndex(sb),
                ),
                TotalTips:  collections.NewItem(sb, types.TotalTipsPrefix, "total_tips", sdk.IntValue),
                Nonces:     collections.NewMap(sb, types.NoncesPrefix, "nonces", collections.BytesKey, collections.Uint64Value),
                Aggregates: collections.NewIndexedMap(sb, types.AggregatesPrefix, "aggregates", collections.PairKeyCodec(collections.BytesKey, collections.Int64Key), codec.CollValue[types.Aggregate](cdc), NewAggregatesIndex(sb)),
                Reports: collections.NewIndexedMap(sb,
                        types.ReportsPrefix,
                        "reports",
                        collections.TripleKeyCodec(collections.BytesKey, collections.BytesKey, collections.Uint64Key),
                        codec.CollValue[types.MicroReport](cdc),
                        NewReportsIndex(sb),
                ),
                QuerySequnecer: collections.NewSequence(sb, types.QuerySeqPrefix, "sequencer"),
                Query: collections.NewIndexedMap(sb,
                        types.QueryTipPrefix,
                        "query",
                        collections.BytesKey,
                        codec.CollValue[types.QueryMeta](cdc),
                        NewQueryIndex(sb),
                ),
                Cyclelist:          collections.NewMap(sb, types.CyclelistPrefix, "cyclelist", collections.BytesKey, collections.BytesValue),
                CyclelistSequencer: collections.NewSequence(sb, types.CycleSeqPrefix, "cycle_sequencer"),
        }

        schema, err := sb.Build()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">k.Schema = schema

        return k</span>
}

// GetAuthority returns the module's authority.
func (k Keeper) GetAuthority() string <span class="cov8" title="1">{
        return k.authority
}</span>

func (k Keeper) Logger(ctx context.Context) log.Logger <span class="cov0" title="0">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)
        return sdkCtx.Logger().With("module", fmt.Sprintf("x/%s", types.ModuleName))
}</span>

// initialize query for a given query data
func (k Keeper) initializeQuery(ctx context.Context, querydata []byte) (types.QueryMeta, error) <span class="cov8" title="1">{
        // initialize query tip first time

        queryType, _, err := regTypes.DecodeQueryType(querydata)
        if err != nil </span><span class="cov0" title="0">{
                return types.QueryMeta{}, err
        }</span>
        <span class="cov8" title="1">dataSpec, err := k.GetDataSpec(sdk.UnwrapSDKContext(ctx), queryType)
        if err != nil </span><span class="cov0" title="0">{
                return types.QueryMeta{}, err
        }</span>
        <span class="cov8" title="1">id, err := k.QuerySequnecer.Next(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return types.QueryMeta{}, err
        }</span>
        <span class="cov8" title="1">query := types.QueryMeta{
                Id:                    id,
                RegistrySpecTimeframe: dataSpec.ReportBufferWindow,
                QueryId:               utils.QueryIDFromData(querydata),
        }
        return query, nil</span>
}

func (k Keeper) UpdateQuery(ctx context.Context, queryType string, newTimeframe time.Duration) error <span class="cov0" title="0">{
        iter, err := k.Query.Indexes.QueryType.MatchExact(ctx, queryType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">queries, err := indexes.CollectValues(ctx, k.Query, iter)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, query := range queries </span><span class="cov0" title="0">{
                query.RegistrySpecTimeframe = newTimeframe
                err = k.Query.Set(ctx, query.QueryId, query)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package keeper

import (
        "github.com/tellor-io/layer/x/oracle/types"
)

type msgServer struct {
        Keeper
}

// NewMsgServerImpl returns an implementation of the MsgServer interface
// for the provided Keeper.
func NewMsgServerImpl(keeper Keeper) types.MsgServer <span class="cov8" title="1">{
        return &amp;msgServer{Keeper: keeper}
}</span>

var _ types.MsgServer = msgServer{}
</pre>
		
		<pre class="file" id="file83" style="display: none">package keeper

import (
        "bytes"
        "context"
        "errors"

        "cosmossdk.io/collections"
        errorsmod "cosmossdk.io/errors"
        "cosmossdk.io/math"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/utils"
        "github.com/tellor-io/layer/x/oracle/types"
)

func (k msgServer) CommitReport(goCtx context.Context, msg *types.MsgCommitReport) (*types.MsgCommitReportResponse, error) <span class="cov8" title="1">{
        ctx := sdk.UnwrapSDKContext(goCtx)

        reporterAddr, err := msg.GetSignerAndValidateMsg()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // get reporter
        <span class="cov8" title="1">reporter, err := k.reporterKeeper.Reporter(ctx, reporterAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if reporter.Jailed </span><span class="cov8" title="1">{
                return nil, errorsmod.Wrapf(types.ErrReporterJailed, "reporter %s is in jail", reporterAddr)
        }</span>

        <span class="cov8" title="1">params, err := k.Params.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if reporter.TotalTokens.LT(params.MinStakeAmount) </span><span class="cov8" title="1">{
                return nil, errorsmod.Wrapf(types.ErrNotEnoughStake, "reporter has %s, required amount is %s", reporter.TotalTokens, params.MinStakeAmount)
        }</span>

        // get query id bytes hash from query data
        <span class="cov8" title="1">queryId := utils.QueryIDFromData(msg.QueryData)

        // get query info by query id
        query, err := k.Keeper.Query.Get(ctx, queryId)
        if err != nil </span><span class="cov8" title="1">{
                // if no query it means its not a cyclelist query and doesn't have tips (cyclelist queries are initialized in genesis)
                if errors.Is(err, collections.ErrNotFound) </span><span class="cov8" title="1">{
                        return nil, types.ErrNoTipsNotInCycle.Wrapf("query not part of cyclelist")
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        // get current query in cycle
        <span class="cov8" title="1">cycleQuery, err := k.Keeper.GetCurrentQueryInCycleList(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // bool to check if query is in cycle
        <span class="cov8" title="1">incycle := bytes.Equal(msg.QueryData, cycleQuery)

        if query.Amount.IsZero() &amp;&amp; query.Expiration.Before(ctx.BlockTime()) &amp;&amp; !incycle </span><span class="cov0" title="0">{
                return nil, types.ErrNoTipsNotInCycle.Wrapf("query does not have tips and is not in cycle")
        }</span>

        <span class="cov8" title="1">if query.Amount.GT(math.ZeroInt()) &amp;&amp; query.Expiration.Before(ctx.BlockTime()) &amp;&amp; !incycle </span><span class="cov0" title="0">{
                return nil, errors.New("query's tip is expired and is not in cycle")
        }</span>

        // if tip is zero and expired, move query forward only if in cycle
        // if tip amount is zero and query timeframe is expired, it means one of two things
        // the tip has been paid out because the query has expired and there were revealed reports
        // or the query was in cycle and expired (either revealed or not)
        // in either case move query forward by incrementing id and setting expiration
        <span class="cov8" title="1">if query.Amount.IsZero() &amp;&amp; query.Expiration.Before(ctx.BlockTime()) &amp;&amp; incycle </span><span class="cov8" title="1">{
                nextId, err := k.Keeper.QuerySequnecer.Next(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">query.Id = nextId
                // reset query fields when generating next id
                query.HasRevealedReports = false
                query.Expiration = ctx.BlockTime().Add(query.RegistrySpecTimeframe)
                err = k.Query.Set(ctx, queryId, query)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // if there is tip but window expired, only incycle can extend the window, otherwise requires tip vi msgTip tx
        // if tip amount is greater than zero and query timeframe is expired, it means that the query didn't have any revealed reports
        // and the tip is still there and so the time can be extended only if the query is in cycle or via a tip transaction
        // maintains the same id until the query is paid out
        <span class="cov8" title="1">if query.Amount.GT(math.ZeroInt()) &amp;&amp; query.Expiration.Before(ctx.BlockTime()) &amp;&amp; incycle </span><span class="cov0" title="0">{
                query.Expiration = ctx.BlockTime().Add(query.RegistrySpecTimeframe)
                err = k.Query.Set(ctx, queryId, query)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // if tip is zero and not expired, this could only mean that the query is still accepting submissions
        <span class="cov8" title="1">if query.Amount.IsZero() &amp;&amp; ctx.BlockTime().Before(query.Expiration) </span><span class="cov0" title="0">{
                incycle = true
        }</span>

        <span class="cov8" title="1">commit := types.Commit{
                Reporter: msg.Creator,
                QueryId:  queryId,
                Hash:     msg.Hash,
                Incycle:  incycle,
        }
        err = k.Commits.Set(ctx, collections.Join(reporterAddr.Bytes(), query.Id), commit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;types.MsgCommitReportResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package keeper

import (
        "bytes"
        "context"
        "errors"

        "cosmossdk.io/collections"
        "cosmossdk.io/math"

        errorsmod "cosmossdk.io/errors"
        "github.com/tellor-io/layer/utils"
        "github.com/tellor-io/layer/x/oracle/types"
        oracleutils "github.com/tellor-io/layer/x/oracle/utils"

        sdk "github.com/cosmos/cosmos-sdk/types"
        layertypes "github.com/tellor-io/layer/types"
)

func (k msgServer) SubmitValue(goCtx context.Context, msg *types.MsgSubmitValue) (*types.MsgSubmitValueResponse, error) <span class="cov8" title="1">{
        ctx := sdk.UnwrapSDKContext(goCtx)

        reporterAddr, err := msg.GetSignerAndValidateMsg()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        // get reporter
        <span class="cov8" title="1">reporter, err := k.reporterKeeper.Reporter(ctx, reporterAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if reporter.Jailed </span><span class="cov0" title="0">{
                return nil, errorsmod.Wrapf(types.ErrReporterJailed, "reporter %s is in jail", reporterAddr)
        }</span>
        <span class="cov8" title="1">params, err := k.Params.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if reporter.TotalTokens.LT(params.MinStakeAmount) </span><span class="cov0" title="0">{
                return nil, errorsmod.Wrapf(types.ErrNotEnoughStake, "reporter has %s, required %s", reporter.TotalTokens, params.MinStakeAmount)
        }</span>

        <span class="cov8" title="1">votingPower := reporter.TotalTokens.Quo(layertypes.PowerReduction).Int64()
        // decode query data hex string to bytes

        queryId := utils.QueryIDFromData(msg.QueryData)

        query, err := k.Keeper.Query.Get(ctx, queryId)
        if err != nil </span><span class="cov8" title="1">{
                // if entered here it means that there is no tip because in cycle query are initialized in genesis
                return nil, err
        }</span>
        <span class="cov8" title="1">var incycle bool
        // get commit by identifier
        commit, err := k.Keeper.Commits.Get(ctx, collections.Join(reporterAddr.Bytes(), query.Id))
        if err != nil </span><span class="cov0" title="0">{
                if !errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                        return nil, err
                }</span> else<span class="cov0" title="0"> {
                        // if there is no commit check if in cycle
                        cycleQuery, err := k.Keeper.GetCurrentQueryInCycleList(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">incycle = bytes.Equal(msg.QueryData, cycleQuery)
                        err = k.directReveal(ctx, query, msg.QueryData, msg.Value, reporterAddr, votingPower, incycle)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return &amp;types.MsgSubmitValueResponse{}, nil</span>
                }
        }
        // if there is a commit then check if its expired and verify commit, and add in cycle from commit.incycle
        <span class="cov8" title="1">if query.Expiration.Add(offset).Before(ctx.BlockTime()) </span><span class="cov8" title="1">{
                return nil, errors.New("missed commit reveal window")
        }</span>
        <span class="cov8" title="1">genHash := oracleutils.CalculateCommitment(msg.Value, msg.Salt)
        if genHash != commit.Hash </span><span class="cov8" title="1">{
                return nil, errors.New("submitted value doesn't match commitment, are you a cheater?")
        }</span>
        <span class="cov8" title="1">incycle = commit.Incycle

        err = k.setValue(ctx, reporterAddr, query, msg.Value, msg.QueryData, votingPower, incycle)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // todo: do we need to keep all the commits? also whats best do it here or aggregation?
        // remove commit from store
        // err = k.Keeper.Commits.Remove(ctx, collections.Join(reporterAddr.Bytes(), query.Id))
        // if err != nil {
        //         return nil, err
        // }
        <span class="cov8" title="1">return &amp;types.MsgSubmitValueResponse{}, nil</span>
}

func (k Keeper) directReveal(ctx sdk.Context,
        query types.QueryMeta,
        qDataBytes []byte,
        value string,
        reporterAddr sdk.AccAddress,
        votingPower int64,
        incycle bool) error <span class="cov0" title="0">{

        if query.Amount.IsZero() &amp;&amp; query.Expiration.Add(offset).Before(ctx.BlockTime()) &amp;&amp; !incycle </span><span class="cov0" title="0">{
                return types.ErrNoTipsNotInCycle
        }</span>

        <span class="cov0" title="0">if query.Amount.IsZero() &amp;&amp; query.Expiration.Add(offset).Before(ctx.BlockTime()) &amp;&amp; incycle </span><span class="cov0" title="0">{
                nextId, err := k.QuerySequnecer.Next(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">query.Id = nextId
                query.Expiration = ctx.BlockTime().Add(query.RegistrySpecTimeframe)</span>
        }

        <span class="cov0" title="0">if query.Amount.GT(math.ZeroInt()) &amp;&amp; query.Expiration.Add(offset).Before(ctx.BlockTime()) &amp;&amp; !incycle </span><span class="cov0" title="0">{
                return errors.New("tip submission window expired and query is not in cycle")
        }</span>

        <span class="cov0" title="0">if query.Amount.GT(math.ZeroInt()) &amp;&amp; query.Expiration.Add(offset).Before(ctx.BlockTime()) &amp;&amp; incycle </span><span class="cov0" title="0">{
                query.Expiration = ctx.BlockTime().Add(query.RegistrySpecTimeframe)
        }</span>
        <span class="cov0" title="0">if query.Amount.IsZero() &amp;&amp; ctx.BlockTime().Before(query.Expiration.Add(offset)) </span><span class="cov0" title="0">{
                incycle = true
        }</span>
        <span class="cov0" title="0">err := k.setValue(ctx, reporterAddr, query, value, qDataBytes, votingPower, incycle)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package keeper

import (
        "context"
        "errors"
        "fmt"

        "cosmossdk.io/collections"
        sdk "github.com/cosmos/cosmos-sdk/types"
        sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
        layer "github.com/tellor-io/layer/types"
        "github.com/tellor-io/layer/utils"
        "github.com/tellor-io/layer/x/oracle/types"
)

func (k msgServer) Tip(goCtx context.Context, msg *types.MsgTip) (*types.MsgTipResponse, error) <span class="cov8" title="1">{
        ctx := sdk.UnwrapSDKContext(goCtx)

        if msg.Amount.Denom != layer.BondDenom || msg.Amount.Amount.IsZero() || msg.Amount.Amount.IsNegative() </span><span class="cov0" title="0">{
                return nil, sdkerrors.ErrInvalidRequest
        }</span>
        <span class="cov8" title="1">tipper := sdk.MustAccAddressFromBech32(msg.Tipper)

        tip, err := k.Keeper.transfer(ctx, tipper, msg.Amount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // get query id bytes hash from query data
        <span class="cov8" title="1">queryId := utils.QueryIDFromData(msg.QueryData)

        // get query info for the query id
        query, err := k.Keeper.Query.Get(ctx, queryId)
        if err != nil </span><span class="cov8" title="1">{
                if !errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // initialize query tip first time
                <span class="cov8" title="1">query, err := k.Keeper.initializeQuery(ctx, msg.QueryData)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">query.Amount = tip.Amount
                query.Expiration = ctx.BlockTime().Add(query.RegistrySpecTimeframe)
                err = k.Keeper.Query.Set(ctx, queryId, query)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return &amp;types.MsgTipResponse{}, nil</span>
        }
        <span class="cov0" title="0">prevAmt := query.Amount
        query.Amount = query.Amount.Add(tip.Amount)

        // expired submission window
        if query.Expiration.Before(ctx.BlockTime()) </span><span class="cov0" title="0">{
                // query expired, create new expiration time and new id
                query.Expiration = ctx.BlockTime().Add(query.RegistrySpecTimeframe)
                // in aggregate you set revealed reports to false after pay out
                // so if query either has reports or is paid out then new id should be generated
                if query.HasRevealedReports || prevAmt.IsZero() </span><span class="cov0" title="0">{
                        id, err := k.QuerySequnecer.Next(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">query.Id = id
                        query.Amount = tip.Amount
                        query.HasRevealedReports = false</span>
                }
        }
        <span class="cov0" title="0">err = k.Keeper.Query.Set(ctx, queryId, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">prevTip, err := k.Keeper.Tips.Get(ctx, collections.Join(queryId, tipper.Bytes()))
        if err != nil &amp;&amp; !errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get previous tip: %w", err)
        }</span>

        <span class="cov0" title="0">if !prevTip.IsNil() </span><span class="cov0" title="0">{
                tip = tip.AddAmount(prevTip)
        }</span>
        <span class="cov0" title="0">err = k.Keeper.Tips.Set(ctx, collections.Join(queryId, tipper.Bytes()), tip.Amount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = k.Keeper.AddtoTotalTips(ctx, tip.Amount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;types.MsgTipResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package keeper

import (
        "context"

        errorsmod "cosmossdk.io/errors"

        "github.com/tellor-io/layer/x/oracle/types"
)

func (k msgServer) UpdateCyclelist(ctx context.Context, req *types.MsgUpdateCyclelist) (*types.MsgUpdateCyclelistResponse, error) <span class="cov0" title="0">{
        if k.GetAuthority() != req.Authority </span><span class="cov0" title="0">{
                return nil, errorsmod.Wrapf(types.ErrInvalidSigner, "invalid authority; expected %s, got %s", k.GetAuthority(), req.Authority)
        }</span>

        <span class="cov0" title="0">if err := k.Cyclelist.Clear(ctx, nil); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := k.InitCycleListQuery(ctx, req.Cyclelist); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;types.MsgUpdateCyclelistResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package keeper

import (
        "context"

        errorsmod "cosmossdk.io/errors"
        sdk "github.com/cosmos/cosmos-sdk/types"

        "github.com/tellor-io/layer/x/oracle/types"
)

func (k msgServer) UpdateParams(goCtx context.Context, req *types.MsgUpdateParams) (*types.MsgUpdateParamsResponse, error) <span class="cov8" title="1">{
        if k.GetAuthority() != req.Authority </span><span class="cov8" title="1">{
                return nil, errorsmod.Wrapf(types.ErrInvalidSigner, "invalid authority; expected %s, got %s", k.GetAuthority(), req.Authority)
        }</span>

        <span class="cov8" title="1">ctx := sdk.UnwrapSDKContext(goCtx)
        if err := k.SetParams(ctx, req.Params); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;types.MsgUpdateParamsResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package keeper

import (
        sdk "github.com/cosmos/cosmos-sdk/types"

        "github.com/tellor-io/layer/x/oracle/types"
)

// SetParams sets the x/oracle module parameters.
func (k Keeper) SetParams(ctx sdk.Context, params types.Params) error <span class="cov8" title="1">{
        if err := params.Validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return k.Params.Set(ctx, params)</span>
}

// GetParams sets the x/oracle module parameters.
func (k Keeper) GetParams(ctx sdk.Context) (types.Params, error) <span class="cov8" title="1">{
        return k.Params.Get(ctx)
}</span>
</pre>
		
		<pre class="file" id="file89" style="display: none">package keeper

import (
        "github.com/tellor-io/layer/x/oracle/types"
)

var _ types.QueryServer = Querier{}

type Querier struct {
        Keeper
}

func NewQuerier(keeper Keeper) Querier <span class="cov8" title="1">{
        return Querier{Keeper: keeper}
}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">package keeper

import (
        "context"

        "github.com/tellor-io/layer/x/oracle/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Querier) CurrentCyclelistQuery(ctx context.Context, req *types.QueryCurrentCyclelistQueryRequest) (*types.QueryCurrentCyclelistQueryResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov0" title="0">querydata, err := k.GetCurrentQueryInCycleList(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;types.QueryCurrentCyclelistQueryResponse{QueryData: querydata}, nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package keeper

import (
        "context"

        "github.com/tellor-io/layer/x/oracle/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Keeper) GetAggregatedReport(ctx context.Context, req *types.QueryGetCurrentAggregatedReportRequest) (*types.QueryGetAggregatedReportResponse, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov8" title="1">mostRecent, err := k.GetCurrentValueForQueryId(ctx, req.QueryId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if mostRecent == nil </span><span class="cov8" title="1">{
                return nil, types.ErrNoAvailableReports.Wrapf("no reports available for query id %s", req.QueryId)
        }</span>
        <span class="cov8" title="1">return &amp;types.QueryGetAggregatedReportResponse{Report: mostRecent}, nil</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package keeper

import (
        "context"

        "github.com/tellor-io/layer/utils"
        "github.com/tellor-io/layer/x/oracle/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Keeper) GetCurrentTip(ctx context.Context, req *types.QueryGetCurrentTipRequest) (*types.QueryGetCurrentTipResponse, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov0" title="0">queryId := utils.QueryIDFromData(req.QueryData)
        tips, err := k.GetQueryTip(ctx, queryId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;types.QueryGetCurrentTipResponse{Tips: &amp;types.Tips{
                QueryData: req.QueryData, // TODO: avoid returning the same data as the request
                Amount:    tips,
        }}, nil</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package keeper

import (
        "context"
        "time"

        "github.com/tellor-io/layer/x/oracle/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Keeper) GetDataBefore(goCtx context.Context, req *types.QueryGetDataBeforeRequest) (*types.QueryGetAggregatedReportResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov0" title="0">t := time.Unix(req.Timestamp, 0)
        report, err := k.getDataBefore(goCtx, req.QueryId, t)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;types.QueryGetAggregatedReportResponse{Report: report}, nil</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package keeper

import (
        "context"

        "github.com/tellor-io/layer/x/oracle/types"

        "cosmossdk.io/collections"
        "cosmossdk.io/collections/indexes"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Querier) GetReportsbyQid(ctx context.Context, req *types.QueryGetReportsbyQidRequest) (*types.QueryGetReportsbyQidResponse, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>
        <span class="cov8" title="1">reports := types.Reports{
                MicroReports: []*types.MicroReport{},
        }

        rng := collections.NewPrefixedTripleRange[[]byte, []byte, uint64](req.QueryId)
        err := k.Reports.Walk(ctx, rng, func(key collections.Triple[[]byte, []byte, uint64], value types.MicroReport) (stop bool, err error) </span><span class="cov8" title="1">{
                reports.MicroReports = append(reports.MicroReports, &amp;value)
                return false, nil
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;types.QueryGetReportsbyQidResponse{Reports: reports}, nil</span>
}

func (k Querier) GetReportsbyReporter(ctx context.Context, req *types.QueryGetReportsbyReporterRequest) (*types.QueryGetReportsbyReporterResponse, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov8" title="1">reporter := sdk.MustAccAddressFromBech32(req.Reporter)

        // Retrieve the stored reports for the current block height.
        iter, err := k.Reports.Indexes.Reporter.MatchExact(ctx, reporter.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">reports, err := indexes.CollectValues(ctx, k.Reports, iter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;types.QueryGetReportsbyReporterResponse{MicroReports: reports}, nil</span>
}

func (k Querier) GetReportsbyReporterQid(ctx context.Context, req *types.QueryGetReportsbyReporterQidRequest) (*types.QueryGetReportsbyQidResponse, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov8" title="1">reporterAdd, err := sdk.AccAddressFromBech32(req.Reporter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "failed to decode reporter address")
        }</span>

        <span class="cov8" title="1">microReports := []*types.MicroReport{}
        rng := collections.NewSuperPrefixedTripleRange[[]byte, []byte, uint64](req.QueryId, reporterAdd.Bytes())
        err = k.Reports.Walk(ctx, rng, func(key collections.Triple[[]byte, []byte, uint64], value types.MicroReport) (stop bool, err error) </span><span class="cov8" title="1">{
                microReports = append(microReports, &amp;value)
                return false, nil
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;types.QueryGetReportsbyQidResponse{Reports: types.Reports{
                MicroReports: microReports,
        }}, nil</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package keeper

import (
        "context"

        sdk "github.com/cosmos/cosmos-sdk/types"
        layer "github.com/tellor-io/layer/types"
        "github.com/tellor-io/layer/x/oracle/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Keeper) GetTimeBasedRewards(goCtx context.Context, req *types.QueryGetTimeBasedRewardsRequest) (*types.QueryGetTimeBasedRewardsResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov0" title="0">ctx := sdk.UnwrapSDKContext(goCtx)

        rewards := k.getTimeBasedRewards(ctx)

        return &amp;types.QueryGetTimeBasedRewardsResponse{Reward: sdk.NewCoin(layer.BondDenom, rewards)}, nil</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package keeper

import (
        "context"
        "errors"

        "cosmossdk.io/collections"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/utils"
        "github.com/tellor-io/layer/x/oracle/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Keeper) GetUserTipTotal(goCtx context.Context, req *types.QueryGetUserTipTotalRequest) (*types.QueryGetUserTipTotalResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov0" title="0">ctx := sdk.UnwrapSDKContext(goCtx)

        tipper := sdk.MustAccAddressFromBech32(req.Tipper)

        var totalTips types.UserTipTotal
        if len(req.QueryData) == 0 </span><span class="cov0" title="0">{
                // if query data is not provide, return total tips for the tipper on all queries
                totalTips, err := k.GetUserTips(ctx, tipper)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;types.QueryGetUserTipTotalResponse{TotalTips: &amp;totalTips}, nil</span>
        }
        // if query data is provided, return total tips for the tipper on the specific query
        <span class="cov0" title="0">queryId := utils.QueryIDFromData(req.QueryData)

        tip, err := k.Tips.Get(ctx, collections.Join(queryId, tipper.Bytes()))
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                        return &amp;types.QueryGetUserTipTotalResponse{TotalTips: &amp;totalTips}, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">totalTips.Total = tip

        return &amp;types.QueryGetUserTipTotalResponse{TotalTips: &amp;totalTips}, nil</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package keeper

import (
        "context"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/oracle/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Querier) Params(goCtx context.Context, req *types.QueryParamsRequest) (*types.QueryParamsResponse, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>
        <span class="cov8" title="1">ctx := sdk.UnwrapSDKContext(goCtx)
        params, err := k.Keeper.GetParams(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;types.QueryParamsResponse{Params: params}, nil</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">package keeper

import (
        "cosmossdk.io/math"
        sdk "github.com/cosmos/cosmos-sdk/types"
        layer "github.com/tellor-io/layer/types"
        minttypes "github.com/tellor-io/layer/x/mint/types"
        "github.com/tellor-io/layer/x/oracle/types"
        reportertypes "github.com/tellor-io/layer/x/reporter/types"
)

type ReportersReportCount struct {
        Power   int64
        Reports int
}

// AllocateRewards distributes rewards to reporters based on their power and number of reports.
// It calculates the reward amount for each reporter and allocates the rewards.
// Finally, it sends the allocated rewards to the apprppopriate module based on the source of the reward.
func (k Keeper) AllocateRewards(ctx sdk.Context, reporters []*types.AggregateReporter, reward math.Int, toStake bool) error <span class="cov0" title="0">{
        // Initialize totalPower to keep track of the total power of all reporters.
        totalPower := int64(0)
        // reportCounts maps reporter's address to their ValidatorReportCount.
        reportCounts := make(map[string]ReportersReportCount)

        // Loop through each reporter to calculate total power and individual report counts.
        for _, r := range reporters </span><span class="cov0" title="0">{
                reporter, found := reportCounts[r.Reporter]
                if found </span><span class="cov0" title="0">{
                        // If the reporter is already in the map, increment their report count.
                        reporter.Reports++
                }</span> else<span class="cov0" title="0"> {
                        // If not found, add the reporter with their initial power and report count set to 1.
                        reporter = ReportersReportCount{Power: r.Power, Reports: 1}
                }</span>
                <span class="cov0" title="0">reportCounts[r.Reporter] = reporter
                // Add the reporter's power to the total power.
                totalPower += r.Power</span>
        }

        <span class="cov0" title="0">var allocateReward func(ctx sdk.Context, addr []byte, amount math.Int) error
        var from, to string
        if toStake </span><span class="cov0" title="0">{
                allocateReward = k.AllocateTip
                from = types.ModuleName
                to = reportertypes.TipsEscrowPool
        }</span> else<span class="cov0" title="0"> {
                allocateReward = k.AllocateTBR
                from = minttypes.TimeBasedRewards
                to = reportertypes.ModuleName

        }</span>
        <span class="cov0" title="0">for r, c := range reportCounts </span><span class="cov0" title="0">{
                amount := CalculateRewardAmount(c.Power, int64(c.Reports), totalPower, reward)
                repoterAddr, err := sdk.AccAddressFromBech32(r)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err = allocateReward(ctx, repoterAddr.Bytes(), amount)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return k.bankKeeper.SendCoinsFromModuleToModule(ctx, from, to, sdk.NewCoins(sdk.NewCoin(layer.BondDenom, reward)))</span>
}

func (k Keeper) getTimeBasedRewards(ctx sdk.Context) math.Int <span class="cov0" title="0">{
        tbrAccount := k.getTimeBasedRewardsAccount(ctx)
        balance := k.bankKeeper.GetBalance(ctx, tbrAccount.GetAddress(), layer.BondDenom)
        return balance.Amount
}</span>

func (k Keeper) getTimeBasedRewardsAccount(ctx sdk.Context) sdk.ModuleAccountI <span class="cov0" title="0">{
        return k.accountKeeper.GetModuleAccount(ctx, minttypes.TimeBasedRewards)
}</span>

func CalculateRewardAmount(reporterPower, reportsCount, totalPower int64, reward math.Int) math.Int <span class="cov8" title="1">{
        power := math.LegacyNewDec(reporterPower * reportsCount)
        amount := power.Quo(math.LegacyNewDec(totalPower)).MulTruncate(math.LegacyNewDecFromBigInt(reward.BigInt()))
        return amount.RoundInt()
}</span>

func (k Keeper) AllocateTBR(ctx sdk.Context, addr []byte, amount math.Int) error <span class="cov0" title="0">{
        reward := sdk.NewDecCoins(sdk.NewDecCoin(layer.BondDenom, amount))
        return k.reporterKeeper.AllocateTokensToReporter(ctx, addr, reward)
}</span>

func (k Keeper) AllocateTip(ctx sdk.Context, addr []byte, amount math.Int) error <span class="cov0" title="0">{
        return k.reporterKeeper.DivvyingTips(ctx, addr, amount)
}</span>
</pre>
		
		<pre class="file" id="file99" style="display: none">package keeper

import (
        "fmt"

        "cosmossdk.io/collections"
        "github.com/tellor-io/layer/utils"
        "github.com/tellor-io/layer/x/oracle/types"
        oracleutils "github.com/tellor-io/layer/x/oracle/utils"
        regTypes "github.com/tellor-io/layer/x/registry/types"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Keeper) setValue(ctx sdk.Context, reporter sdk.AccAddress, query types.QueryMeta, val string, queryData []byte, power int64, incycle bool) error <span class="cov8" title="1">{
        // decode query data hex to get query type, returns interface array
        queryType, _, err := regTypes.DecodeQueryType(queryData)
        if err != nil </span><span class="cov0" title="0">{
                return status.Error(codes.InvalidArgument, fmt.Sprintf("failed to decode query type: %v", err))
        }</span>
        <span class="cov8" title="1">dataSpec, err := k.GetDataSpec(ctx, queryType)
        if err != nil </span><span class="cov0" title="0">{
                return status.Error(codes.InvalidArgument, fmt.Sprintf("failed to get value type: %v", err))
        }</span>
        // decode value using value type from data spec and check if decodes successfully
        // value is not used, only used to check if it decodes successfully
        <span class="cov8" title="1">if err := dataSpec.ValidateValue(val); err != nil </span><span class="cov0" title="0">{
                return status.Error(codes.InvalidArgument, fmt.Sprintf("failed to validate value: %v", err))
        }</span>
        <span class="cov8" title="1">queryId := utils.QueryIDFromData(queryData)
        report := types.MicroReport{
                Reporter:        reporter.String(),
                Power:           power,
                QueryType:       queryType,
                QueryId:         queryId,
                Value:           val,
                AggregateMethod: dataSpec.AggregationMethod,
                Timestamp:       ctx.BlockTime(),
                Cyclelist:       incycle,
                BlockNumber:     ctx.BlockHeight(),
        }

        query.HasRevealedReports = true
        err = k.Query.Set(ctx, queryId, query)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return k.Reports.Set(ctx, collections.Join3(queryId, reporter.Bytes(), query.Id), report)</span>
}

func (k Keeper) VerifyCommit(ctx sdk.Context, reporter string, value, salt, hash string) bool <span class="cov8" title="1">{
        // calculate commitment
        calculatedCommit := oracleutils.CalculateCommitment(value, salt)
        // compare calculated commitment with the one stored
        return calculatedCommit == hash
}</span>

func (k Keeper) GetDataSpec(ctx sdk.Context, queryType string) (regTypes.DataSpec, error) <span class="cov8" title="1">{
        // get data spec from registry by query type to validate value
        dataSpec, err := k.registryKeeper.GetSpec(ctx, queryType)
        if err != nil </span><span class="cov0" title="0">{
                return regTypes.DataSpec{}, err
        }</span>
        <span class="cov8" title="1">return dataSpec, nil</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package keeper

import (
        "context"
        "errors"

        "cosmossdk.io/collections"
        "cosmossdk.io/collections/indexes"
        "cosmossdk.io/math"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/oracle/types"
)

func (k Keeper) transfer(ctx context.Context, tipper sdk.AccAddress, tip sdk.Coin) (sdk.Coin, error) <span class="cov8" title="1">{
        twoPercent := tip.Amount.Mul(math.NewInt(2)).Quo(math.NewInt(100))
        burnCoin := sdk.NewCoin(tip.Denom, twoPercent)
        if err := k.bankKeeper.SendCoinsFromAccountToModule(ctx, tipper, types.ModuleName, sdk.NewCoins(tip)); err != nil </span><span class="cov0" title="0">{
                return sdk.Coin{}, err
        }</span>
        // burn 2% of tip
        <span class="cov8" title="1">if err := k.bankKeeper.BurnCoins(ctx, types.ModuleName, sdk.NewCoins(burnCoin)); err != nil </span><span class="cov0" title="0">{
                return sdk.Coin{}, err
        }</span>
        <span class="cov8" title="1">return tip.Sub(burnCoin), nil</span>
}

func (k Keeper) GetQueryTip(ctx context.Context, queryId []byte) (math.Int, error) <span class="cov0" title="0">{
        tip, err := k.Query.Get(ctx, queryId)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                        return math.ZeroInt(), nil
                }</span> else<span class="cov0" title="0"> {
                        return math.Int{}, err
                }</span>
        }
        <span class="cov0" title="0">return tip.Amount, nil</span>
}

func (k Keeper) GetUserTips(ctx context.Context, tipper sdk.AccAddress) (types.UserTipTotal, error) <span class="cov0" title="0">{
        it, err := k.Tips.Indexes.Tipper.MatchExact(ctx, tipper.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return types.UserTipTotal{}, err
        }</span>

        <span class="cov0" title="0">vals, err := indexes.CollectValues(ctx, k.Tips, it)
        if err != nil </span><span class="cov0" title="0">{
                return types.UserTipTotal{}, err
        }</span>

        <span class="cov0" title="0">totalTips := math.ZeroInt()
        for _, tip := range vals </span><span class="cov0" title="0">{
                totalTips = totalTips.Add(tip)
        }</span>

        <span class="cov0" title="0">return types.UserTipTotal{
                Address: tipper.String(),
                Total:   totalTips,
        }, nil</span>
}

func (k Keeper) GetTotalTips(ctx context.Context) (math.Int, error) <span class="cov0" title="0">{
        totalTips, err := k.TotalTips.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                        return math.ZeroInt(), nil
                }</span>
                <span class="cov0" title="0">return math.Int{}, err</span>
        }

        <span class="cov0" title="0">return totalTips, nil</span>
}

// Add to overall total tips, used for dispute voting calculation
func (k Keeper) AddtoTotalTips(ctx context.Context, tip math.Int) error <span class="cov0" title="0">{
        totalTips, err := k.TotalTips.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                        return k.TotalTips.Set(ctx, tip)
                }</span>
        } else<span class="cov0" title="0"> {
                return err
        }</span>
        <span class="cov0" title="0">totalTips = totalTips.Add(totalTips)
        return k.TotalTips.Set(ctx, totalTips)</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">package keeper

import (
        "context"
        "errors"
        "math"
        "math/big"
        "sort"

        cosmath "cosmossdk.io/math"
        layertypes "github.com/tellor-io/layer/types"
        "github.com/tellor-io/layer/x/oracle/types"
)

func (k Keeper) WeightedMedian(ctx context.Context, reports []types.MicroReport) (*types.Aggregate, error) <span class="cov8" title="1">{
        var medianReport types.Aggregate
        values := make(map[string]*big.Int)

        for _, r := range reports </span><span class="cov8" title="1">{
                val, ok := new(big.Int).SetString(r.Value, 16)
                if !ok </span><span class="cov0" title="0">{
                        k.Logger(ctx).Error("WeightedMedian", "error", "failed to parse value")
                        return nil, errors.New("failed to parse value")
                }</span>
                <span class="cov8" title="1">values[r.Reporter] = val</span>
        }

        <span class="cov8" title="1">sort.SliceStable(reports, func(i, j int) bool </span><span class="cov8" title="1">{
                return values[reports[i].Reporter].Cmp(values[reports[j].Reporter]) &lt; 0

        }</span>)

        <span class="cov8" title="1">var totalReporterPower, weightedSum big.Int
        for _, r := range reports </span><span class="cov8" title="1">{
                weightedSum.Add(&amp;weightedSum, new(big.Int).Mul(values[r.Reporter], big.NewInt(r.Power)))
                totalReporterPower.Add(&amp;totalReporterPower, big.NewInt(r.Power))
                medianReport.Reporters = append(medianReport.Reporters, &amp;types.AggregateReporter{Reporter: r.Reporter, Power: r.Power})
        }</span>

        <span class="cov8" title="1">halfTotalPower := new(big.Int).Div(&amp;totalReporterPower, big.NewInt(2))
        cumulativePower := new(big.Int)

        // Find the weighted median
        totalReporterPowerMathInt := cosmath.NewInt(totalReporterPower.Int64())
        for i, s := range reports </span><span class="cov8" title="1">{
                cumulativePower.Add(cumulativePower, big.NewInt(s.Power))
                if cumulativePower.Cmp(halfTotalPower) &gt;= 0 </span><span class="cov8" title="1">{
                        medianReport.ReporterPower = totalReporterPowerMathInt.Mul(layertypes.PowerReduction).Int64()
                        medianReport.AggregateReporter = s.Reporter
                        medianReport.AggregateValue = s.Value
                        medianReport.QueryId = s.QueryId
                        medianReport.AggregateReportIndex = int64(i)
                        break</span>
                }
        }

        // Calculate the weighted standard deviation
        <span class="cov8" title="1">var sumWeightedSquaredDiffs float64
        weightedMean := new(big.Float).Quo(new(big.Float).SetInt(&amp;weightedSum), new(big.Float).SetInt(&amp;totalReporterPower))

        for _, r := range reports </span><span class="cov8" title="1">{
                valBigFloat := new(big.Float).SetInt(values[r.Reporter])
                diff := new(big.Float).Sub(valBigFloat, weightedMean)
                diffSquared := new(big.Float).Mul(diff, diff)
                weightedSquaredDiff := diffSquared.Mul(diffSquared, new(big.Float).SetInt64(r.Power))
                diffStdDev, _ := weightedSquaredDiff.Float64()
                sumWeightedSquaredDiffs += diffStdDev
        }</span>
        <span class="cov8" title="1">weightedStdDev := math.Sqrt(sumWeightedSquaredDiffs / float64(totalReporterPower.Int64()))
        medianReport.StandardDeviation = weightedStdDev

        err := k.SetAggregate(ctx, &amp;medianReport)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;medianReport, nil</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package keeper

import (
        "context"

        "github.com/tellor-io/layer/x/oracle/types"
)

func (k Keeper) WeightedMode(ctx context.Context, reports []types.MicroReport) (*types.Aggregate, error) <span class="cov8" title="1">{
        if len(reports) == 0 </span><span class="cov0" title="0">{
                return nil, types.ErrNoReportsToAggregate.Wrapf("can't aggregate empty reports")
        }</span>

        <span class="cov8" title="1">var modeReport types.MicroReport
        var modeReporters []*types.AggregateReporter
        var maxWeight = int64(0)
        var maxFrequency = 0
        var mode string
        frequencyMap := make(map[string]int)

        // populate frequency map
        for _, r := range reports </span><span class="cov8" title="1">{
                modeReporters = append(modeReporters, &amp;types.AggregateReporter{Reporter: r.Reporter, Power: r.Power})
                entries := r.Power
                for i := int64(0); i &lt; entries; i++ </span><span class="cov8" title="1">{
                        frequencyMap[r.Value]++
                }</span>
        }

        // find the max frequency
        <span class="cov8" title="1">for value, frequency := range frequencyMap </span><span class="cov8" title="1">{
                if frequency &gt; maxFrequency </span><span class="cov8" title="1">{
                        maxFrequency = frequency
                        mode = value
                }</span>
        }

        // set mode report from most powerful reporter who submitted mode value
        <span class="cov8" title="1">var modeReportIndex int64
        for i, r := range reports </span><span class="cov8" title="1">{
                if mode == r.Value </span><span class="cov8" title="1">{
                        if r.Power &gt; maxWeight </span><span class="cov8" title="1">{
                                maxWeight = r.Power
                                modeReport = r
                                modeReportIndex = int64(i)
                        }</span>
                }

        }

        <span class="cov8" title="1">aggregateReport := types.Aggregate{
                QueryId:              modeReport.QueryId,
                AggregateValue:       modeReport.Value,
                AggregateReporter:    modeReport.Reporter,
                ReporterPower:        modeReport.Power,
                Reporters:            modeReporters,
                AggregateReportIndex: modeReportIndex,
        }

        err := k.SetAggregate(ctx, &amp;aggregateReport)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;aggregateReport, nil</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package oracle

import (
        "context"
        "encoding/json"
        "fmt"

        // this line is used by starport scaffolding # 1

        "cosmossdk.io/core/appmodule"
        "cosmossdk.io/core/store"
        "cosmossdk.io/depinject"
        abci "github.com/cometbft/cometbft/abci/types"
        authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
        govtypes "github.com/cosmos/cosmos-sdk/x/gov/types"
        "github.com/grpc-ecosystem/grpc-gateway/runtime"
        "github.com/spf13/cobra"

        "github.com/cosmos/cosmos-sdk/client"
        "github.com/cosmos/cosmos-sdk/codec"
        cdctypes "github.com/cosmos/cosmos-sdk/codec/types"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/module"
        oraclemodulev1 "github.com/tellor-io/layer/api/layer/oracle/module"
        "github.com/tellor-io/layer/x/oracle/client/cli"
        "github.com/tellor-io/layer/x/oracle/keeper"
        "github.com/tellor-io/layer/x/oracle/types"
)

var (
        _ module.AppModule          = AppModule{}
        _ module.AppModuleBasic     = AppModuleBasic{}
        _ appmodule.HasBeginBlocker = AppModule{}
        _ appmodule.HasEndBlocker   = AppModule{}
)

// ----------------------------------------------------------------------------
// AppModuleBasic
// ----------------------------------------------------------------------------

// AppModuleBasic implements the AppModuleBasic interface that defines the independent methods a Cosmos SDK module needs to implement.
type AppModuleBasic struct {
        cdc codec.BinaryCodec
}

// IsOnePerModuleType implements the depinject.OnePerModuleType interface.
func (AppModuleBasic) IsOnePerModuleType() {<span class="cov0" title="0">}</span>

// IsAppModule implements the appmodule.AppModule interface.
func (AppModuleBasic) IsAppModule() {<span class="cov0" title="0">}</span>

func NewAppModuleBasic(cdc codec.BinaryCodec) AppModuleBasic <span class="cov0" title="0">{
        return AppModuleBasic{cdc: cdc}
}</span>

// Name returns the name of the module as a string
func (AppModuleBasic) Name() string <span class="cov0" title="0">{
        return types.ModuleName
}</span>

// RegisterLegacyAminoCodec registers the amino codec for the module, which is used to marshal and unmarshal structs to/from []byte in order to persist them in the module's KVStore
func (AppModuleBasic) RegisterLegacyAminoCodec(cdc *codec.LegacyAmino) <span class="cov0" title="0">{
        types.RegisterCodec(cdc)
}</span>

// RegisterInterfaces registers a module's interface types and their concrete implementations as proto.Message
func (a AppModuleBasic) RegisterInterfaces(reg cdctypes.InterfaceRegistry) <span class="cov0" title="0">{
        types.RegisterInterfaces(reg)
}</span>

// DefaultGenesis returns a default GenesisState for the module, marshalled to json.RawMessage. The default GenesisState need to be defined by the module developer and is primarily used for testing
func (AppModuleBasic) DefaultGenesis(cdc codec.JSONCodec) json.RawMessage <span class="cov0" title="0">{
        return cdc.MustMarshalJSON(types.DefaultGenesis())
}</span>

// ValidateGenesis used to validate the GenesisState, given in its json.RawMessage form
func (AppModuleBasic) ValidateGenesis(cdc codec.JSONCodec, config client.TxEncodingConfig, bz json.RawMessage) error <span class="cov0" title="0">{
        var genState types.GenesisState
        if err := cdc.UnmarshalJSON(bz, &amp;genState); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal %s genesis state: %w", types.ModuleName, err)
        }</span>
        <span class="cov0" title="0">return genState.Validate()</span>
}

// RegisterGRPCGatewayRoutes registers the gRPC Gateway routes for the module
func (AppModuleBasic) RegisterGRPCGatewayRoutes(clientCtx client.Context, mux *runtime.ServeMux) <span class="cov0" title="0">{
        types.RegisterQueryHandlerClient(context.Background(), mux, types.NewQueryClient(clientCtx))
}</span>

// GetTxCmd returns the root Tx command for the module. The subcommands of this root command are used by end-users to generate new transactions containing messages defined in the module
func (a AppModuleBasic) GetTxCmd() *cobra.Command <span class="cov0" title="0">{
        return cli.GetTxCmd()
}</span>

// GetQueryCmd returns the root query command for the module. The subcommands of this root command are used by end-users to generate new queries to the subset of the state defined by the module
func (AppModuleBasic) GetQueryCmd() *cobra.Command <span class="cov0" title="0">{
        return cli.GetQueryCmd(types.StoreKey)
}</span>

// ----------------------------------------------------------------------------
// AppModule
// ----------------------------------------------------------------------------

// AppModule implements the AppModule interface that defines the inter-dependent methods that modules need to implement
type AppModule struct {
        AppModuleBasic

        keeper        keeper.Keeper
        accountKeeper types.AccountKeeper
        bankKeeper    types.BankKeeper
}

func NewAppModule(
        cdc codec.Codec,
        keeper keeper.Keeper,
        accountKeeper types.AccountKeeper,
        bankKeeper types.BankKeeper,
) AppModule <span class="cov0" title="0">{
        return AppModule{
                AppModuleBasic: NewAppModuleBasic(cdc),
                keeper:         keeper,
                accountKeeper:  accountKeeper,
                bankKeeper:     bankKeeper,
        }
}</span>

// RegisterServices registers a gRPC query service to respond to the module-specific gRPC queries
func (am AppModule) RegisterServices(cfg module.Configurator) <span class="cov0" title="0">{
        types.RegisterMsgServer(cfg.MsgServer(), keeper.NewMsgServerImpl(am.keeper))
        types.RegisterQueryServer(cfg.QueryServer(), keeper.NewQuerier(am.keeper))
}</span>

// RegisterInvariants registers the invariants of the module. If an invariant deviates from its predicted value, the InvariantRegistry triggers appropriate logic (most often the chain will be halted)
func (am AppModule) RegisterInvariants(_ sdk.InvariantRegistry) {<span class="cov0" title="0">}</span>

// InitGenesis performs the module's genesis initialization. It returns no validator updates.
func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, gs json.RawMessage) []abci.ValidatorUpdate <span class="cov0" title="0">{
        var genState types.GenesisState
        // Initialize global index to index in genesis state
        cdc.MustUnmarshalJSON(gs, &amp;genState)

        InitGenesis(ctx, am.keeper, genState)

        return []abci.ValidatorUpdate{}
}</span>

// ExportGenesis returns the module's exported genesis state as raw JSON bytes.
func (am AppModule) ExportGenesis(ctx sdk.Context, cdc codec.JSONCodec) json.RawMessage <span class="cov0" title="0">{
        genState := ExportGenesis(ctx, am.keeper)
        return cdc.MustMarshalJSON(genState)
}</span>

// ConsensusVersion is a sequence number for state-breaking change of the module. It should be incremented on each consensus-breaking change introduced by the module. To avoid wrong/empty versions, the initial version should be set to 1
func (AppModule) ConsensusVersion() uint64 <span class="cov0" title="0">{ return 1 }</span>

// BeginBlock contains the logic that is automatically triggered at the beginning of each block
func (am AppModule) BeginBlock(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// EndBlock contains the logic that is automatically triggered at the end of each block
func (am AppModule) EndBlock(ctx context.Context) error <span class="cov0" title="0">{
        return EndBlocker(ctx, am.keeper)
}</span>

// ----------------------------------------------------------------------------
// App Wiring Setup
// ----------------------------------------------------------------------------

func init() <span class="cov8" title="1">{
        appmodule.Register(&amp;oraclemodulev1.Module{},
                appmodule.Provide(ProvideModule))

}</span>

type OracleInputs struct {
        depinject.In

        StoreService store.KVStoreService
        Cdc          codec.Codec
        Config       *oraclemodulev1.Module

        AccountKeeper types.AccountKeeper
        BankKeeper    types.BankKeeper

        RegistryKeeper types.RegistryKeeper
        ReporterKeeper types.ReporterKeeper
}

type OracleOutputs struct {
        depinject.Out

        OracleKeeper keeper.Keeper
        Module       appmodule.AppModule
}

func ProvideModule(in OracleInputs) OracleOutputs <span class="cov0" title="0">{
        authority := authtypes.NewModuleAddress(govtypes.ModuleName)
        if in.Config.Authority != "" </span><span class="cov0" title="0">{
                authority = authtypes.NewModuleAddressOrBech32Address(in.Config.Authority)
        }</span>
        <span class="cov0" title="0">k := keeper.NewKeeper(
                in.Cdc,
                in.StoreService,
                in.AccountKeeper,
                in.BankKeeper,
                in.RegistryKeeper,
                in.ReporterKeeper,
                authority.String(),
        )
        m := NewAppModule(
                in.Cdc,
                k,
                in.AccountKeeper,
                in.BankKeeper,
        )
        return OracleOutputs{OracleKeeper: k, Module: m}</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">package oracle

import (
        "math/rand"

        "github.com/cosmos/cosmos-sdk/baseapp"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/module"
        simtypes "github.com/cosmos/cosmos-sdk/types/simulation"
        "github.com/cosmos/cosmos-sdk/x/simulation"
        "github.com/tellor-io/layer/testutil/sample"
        oraclesimulation "github.com/tellor-io/layer/x/oracle/simulation"
        "github.com/tellor-io/layer/x/oracle/types"
)

// avoid unused import issue
var (
        _ = sample.AccAddress
        _ = oraclesimulation.FindAccount
        _ = simulation.MsgEntryKind
        _ = baseapp.Paramspace
        _ = rand.Rand{}
)

const (
        opWeightMsgSubmitValue = "op_weight_msg_submit_value"
        // TODO: Determine the simulation weight value
        defaultWeightMsgSubmitValue int = 100

        opWeightMsgCommitReport = "op_weight_msg_commit_report"
        // TODO: Determine the simulation weight value
        defaultWeightMsgCommitReport int = 100

        opWeightMsgTip = "op_weight_msg_tip"
        // TODO: Determine the simulation weight value
        defaultWeightMsgTip int = 100

        // this line is used by starport scaffolding # simapp/module/const
)

// GenerateGenesisState creates a randomized GenState of the module.
func (AppModule) GenerateGenesisState(simState *module.SimulationState) <span class="cov0" title="0">{
        accs := make([]string, len(simState.Accounts))
        for i, acc := range simState.Accounts </span><span class="cov0" title="0">{
                accs[i] = acc.Address.String()
        }</span>
        <span class="cov0" title="0">oracleGenesis := types.GenesisState{
                Params: types.DefaultParams(),
                // this line is used by starport scaffolding # simapp/module/genesisState
        }
        simState.GenState[types.ModuleName] = simState.Cdc.MustMarshalJSON(&amp;oracleGenesis)</span>
}

// RegisterStoreDecoder registers a decoder.
func (am AppModule) RegisterStoreDecoder(_ simtypes.StoreDecoderRegistry) {<span class="cov0" title="0">}</span>

// ProposalContents doesn't return any content functions for governance proposals.
func (AppModule) ProposalContents(_ module.SimulationState) []simtypes.WeightedProposalContent <span class="cov0" title="0">{
        return nil
}</span>

// WeightedOperations returns the all the gov module operations with their respective weights.
func (am AppModule) WeightedOperations(simState module.SimulationState) []simtypes.WeightedOperation <span class="cov0" title="0">{
        operations := make([]simtypes.WeightedOperation, 0)

        var weightMsgSubmitValue int
        simState.AppParams.GetOrGenerate(opWeightMsgSubmitValue, &amp;weightMsgSubmitValue, nil,
                func(_ *rand.Rand) </span><span class="cov0" title="0">{
                        weightMsgSubmitValue = defaultWeightMsgSubmitValue
                }</span>,
        )
        <span class="cov0" title="0">operations = append(operations, simulation.NewWeightedOperation(
                weightMsgSubmitValue,
                oraclesimulation.SimulateMsgSubmitValue(am.accountKeeper, am.bankKeeper, am.keeper),
        ))

        var weightMsgCommitReport int
        simState.AppParams.GetOrGenerate(opWeightMsgCommitReport, &amp;weightMsgCommitReport, nil,
                func(_ *rand.Rand) </span><span class="cov0" title="0">{
                        weightMsgCommitReport = defaultWeightMsgCommitReport
                }</span>,
        )
        <span class="cov0" title="0">operations = append(operations, simulation.NewWeightedOperation(
                weightMsgCommitReport,
                oraclesimulation.SimulateMsgCommitReport(am.accountKeeper, am.bankKeeper, am.keeper),
        ))

        var weightMsgTip int
        simState.AppParams.GetOrGenerate(opWeightMsgTip, &amp;weightMsgTip, nil,
                func(_ *rand.Rand) </span><span class="cov0" title="0">{
                        weightMsgTip = defaultWeightMsgTip
                }</span>,
        )
        <span class="cov0" title="0">operations = append(operations, simulation.NewWeightedOperation(
                weightMsgTip,
                oraclesimulation.SimulateMsgTip(am.accountKeeper, am.bankKeeper, am.keeper),
        ))

        // this line is used by starport scaffolding # simapp/module/operation

        return operations</span>
}

// ProposalMsgs returns msgs used for governance proposals for simulations.
func (am AppModule) ProposalMsgs(simState module.SimulationState) []simtypes.WeightedProposalMsg <span class="cov0" title="0">{
        return []simtypes.WeightedProposalMsg{
                simulation.NewWeightedProposalMsg(
                        opWeightMsgSubmitValue,
                        defaultWeightMsgSubmitValue,
                        func(r *rand.Rand, ctx sdk.Context, accs []simtypes.Account) sdk.Msg </span><span class="cov0" title="0">{
                                oraclesimulation.SimulateMsgSubmitValue(am.accountKeeper, am.bankKeeper, am.keeper)
                                return nil
                        }</span>,
                ),
                simulation.NewWeightedProposalMsg(
                        opWeightMsgCommitReport,
                        defaultWeightMsgCommitReport,
                        func(r *rand.Rand, ctx sdk.Context, accs []simtypes.Account) sdk.Msg <span class="cov0" title="0">{
                                oraclesimulation.SimulateMsgCommitReport(am.accountKeeper, am.bankKeeper, am.keeper)
                                return nil
                        }</span>,
                ),
                simulation.NewWeightedProposalMsg(
                        opWeightMsgTip,
                        defaultWeightMsgTip,
                        func(r *rand.Rand, ctx sdk.Context, accs []simtypes.Account) sdk.Msg <span class="cov0" title="0">{
                                oraclesimulation.SimulateMsgTip(am.accountKeeper, am.bankKeeper, am.keeper)
                                return nil
                        }</span>,
                ),
                // this line is used by starport scaffolding # simapp/module/OpMsg
        }
}
</pre>
		
		<pre class="file" id="file105" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/oracle/aggregate.proto

package types

import (
        encoding_binary "encoding/binary"
        fmt "fmt"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
        _ "google.golang.org/protobuf/types/known/timestamppb"
        io "io"
        math "math"
        math_bits "math/bits"
        time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Aggregate struct {
        QueryId              []byte               `protobuf:"bytes,1,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
        AggregateValue       string               `protobuf:"bytes,2,opt,name=aggregateValue,proto3" json:"aggregateValue,omitempty"`
        AggregateReporter    string               `protobuf:"bytes,3,opt,name=aggregateReporter,proto3" json:"aggregateReporter,omitempty"`
        ReporterPower        int64                `protobuf:"varint,4,opt,name=reporterPower,proto3" json:"reporterPower,omitempty"`
        StandardDeviation    float64              `protobuf:"fixed64,5,opt,name=standardDeviation,proto3" json:"standardDeviation,omitempty"`
        Reporters            []*AggregateReporter `protobuf:"bytes,6,rep,name=reporters,proto3" json:"reporters,omitempty"`
        Flagged              bool                 `protobuf:"varint,7,opt,name=flagged,proto3" json:"flagged,omitempty"`
        Nonce                uint64               `protobuf:"varint,8,opt,name=nonce,proto3" json:"nonce,omitempty"`
        AggregateReportIndex int64                `protobuf:"varint,9,opt,name=aggregateReportIndex,proto3" json:"aggregateReportIndex,omitempty"`
        Height               int64                `protobuf:"varint,10,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *Aggregate) Reset()         <span class="cov0" title="0">{ *m = Aggregate{} }</span>
func (m *Aggregate) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Aggregate) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Aggregate) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_788ad347f505f8a6, []int{0}
}</span>
func (m *Aggregate) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Aggregate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Aggregate.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Aggregate) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Aggregate.Merge(m, src)
}</span>
func (m *Aggregate) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Aggregate) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Aggregate.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Aggregate proto.InternalMessageInfo

func (m *Aggregate) GetQueryId() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryId
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Aggregate) GetAggregateValue() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AggregateValue
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Aggregate) GetAggregateReporter() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AggregateReporter
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Aggregate) GetReporterPower() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ReporterPower
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Aggregate) GetStandardDeviation() float64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.StandardDeviation
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Aggregate) GetReporters() []*AggregateReporter <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Reporters
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Aggregate) GetFlagged() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Flagged
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *Aggregate) GetNonce() uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Nonce
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Aggregate) GetAggregateReportIndex() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AggregateReportIndex
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Aggregate) GetHeight() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Height
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type AvailableTimestamps struct {
        Timestamps []time.Time `protobuf:"bytes,1,rep,name=timestamps,proto3,stdtime" json:"timestamps"`
}

func (m *AvailableTimestamps) Reset()         <span class="cov0" title="0">{ *m = AvailableTimestamps{} }</span>
func (m *AvailableTimestamps) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*AvailableTimestamps) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*AvailableTimestamps) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_788ad347f505f8a6, []int{1}
}</span>
func (m *AvailableTimestamps) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *AvailableTimestamps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_AvailableTimestamps.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *AvailableTimestamps) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_AvailableTimestamps.Merge(m, src)
}</span>
func (m *AvailableTimestamps) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *AvailableTimestamps) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_AvailableTimestamps.DiscardUnknown(m)
}</span>

var xxx_messageInfo_AvailableTimestamps proto.InternalMessageInfo

func (m *AvailableTimestamps) GetTimestamps() []time.Time <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Timestamps
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Aggregate)(nil), "layer.oracle.Aggregate")
        proto.RegisterType((*AvailableTimestamps)(nil), "layer.oracle.AvailableTimestamps")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/oracle/aggregate.proto", fileDescriptor_788ad347f505f8a6) }</span>

var fileDescriptor_788ad347f505f8a6 = []byte{
        // 422 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x52, 0x41, 0x6f, 0xd3, 0x30,
        0x14, 0xae, 0xe9, 0xd6, 0x36, 0x66, 0x20, 0x61, 0x2a, 0x64, 0x2a, 0x94, 0x44, 0x13, 0xa0, 0x20,
        0x81, 0x23, 0x8d, 0x33, 0x87, 0x8e, 0x5d, 0x76, 0x43, 0x16, 0xe2, 0x00, 0x87, 0xc9, 0x69, 0xde,
        0x5c, 0x4b, 0x6e, 0x1c, 0x1c, 0x67, 0xac, 0xbf, 0x81, 0xcb, 0x7e, 0xd6, 0x8e, 0x3b, 0x72, 0x02,
        0xd4, 0xfe, 0x11, 0x34, 0xa7, 0x09, 0x5b, 0xb7, 0x5b, 0xbe, 0xf7, 0x7d, 0x9f, 0xdf, 0x7b, 0x79,
        0x1f, 0x7e, 0xa1, 0xc5, 0x12, 0x6c, 0x6a, 0xac, 0x98, 0x69, 0x48, 0x85, 0x94, 0x16, 0xa4, 0x70,
        0xc0, 0x4a, 0x6b, 0x9c, 0x21, 0x7b, 0x9e, 0x65, 0x0d, 0x3b, 0x19, 0x4b, 0x23, 0x8d, 0x27, 0xd2,
        0xeb, 0xaf, 0x46, 0x33, 0x89, 0xa4, 0x31, 0x52, 0x43, 0xea, 0x51, 0x56, 0x9f, 0xa6, 0x4e, 0x2d,
        0xa0, 0x72, 0x62, 0x51, 0x6e, 0x04, 0xaf, 0xee, 0x6f, 0x71, 0x62, 0xa1, 0x34, 0xd6, 0x81, 0x6d,
        0x64, 0xfb, 0x3f, 0xfb, 0x38, 0x98, 0xb6, 0x24, 0x79, 0x8e, 0x47, 0xdf, 0x6b, 0xb0, 0xcb, 0x13,
        0x95, 0x53, 0x14, 0xa3, 0x64, 0x8f, 0x0f, 0x3d, 0x3e, 0xce, 0xc9, 0x6b, 0xfc, 0xb8, 0x7b, 0xe4,
        0x8b, 0xd0, 0x35, 0xd0, 0x07, 0x31, 0x4a, 0x02, 0xbe, 0x55, 0x25, 0x6f, 0xf1, 0x93, 0xae, 0xc2,
        0x37, 0xbd, 0x68, 0xdf, 0x4b, 0xef, 0x12, 0xe4, 0x25, 0x7e, 0xd4, 0x0e, 0xf4, 0xc9, 0xfc, 0x00,
        0x4b, 0x77, 0x62, 0x94, 0xf4, 0xf9, 0xed, 0xe2, 0xf5, 0x9b, 0x95, 0x13, 0x45, 0x2e, 0x6c, 0x7e,
        0x04, 0x67, 0x4a, 0x38, 0x65, 0x0a, 0xba, 0x1b, 0xa3, 0x04, 0xf1, 0xbb, 0x04, 0xf9, 0x80, 0x83,
        0xd6, 0x5e, 0xd1, 0x41, 0xdc, 0x4f, 0x1e, 0x1e, 0x44, 0xec, 0xe6, 0x2f, 0x65, 0xd3, 0xed, 0x39,
        0xf8, 0x7f, 0x07, 0xa1, 0x78, 0x78, 0xaa, 0x85, 0x94, 0x90, 0xd3, 0x61, 0x8c, 0x92, 0x11, 0x6f,
        0x21, 0x19, 0xe3, 0xdd, 0xc2, 0x14, 0x33, 0xa0, 0xa3, 0x18, 0x25, 0x3b, 0xbc, 0x01, 0xe4, 0x00,
        0x8f, 0xb7, 0xf6, 0x3a, 0x2e, 0x72, 0x38, 0xa7, 0x81, 0xdf, 0xe4, 0x5e, 0x8e, 0x3c, 0xc3, 0x83,
        0x39, 0x28, 0x39, 0x77, 0x14, 0x7b, 0xd5, 0x06, 0xed, 0x7f, 0xc3, 0x4f, 0xa7, 0x67, 0x42, 0x69,
        0x91, 0x69, 0xf8, 0xdc, 0x1e, 0xb4, 0x22, 0x47, 0x18, 0x77, 0xe7, 0xad, 0x28, 0xf2, 0x2b, 0x4d,
        0x58, 0x93, 0x00, 0xd6, 0x26, 0x80, 0x75, 0x86, 0xc3, 0xd1, 0xe5, 0xef, 0xa8, 0x77, 0xf1, 0x27,
        0x42, 0xfc, 0x86, 0xef, 0xf0, 0xe3, 0xe5, 0x2a, 0x44, 0x57, 0xab, 0x10, 0xfd, 0x5d, 0x85, 0xe8,
        0x62, 0x1d, 0xf6, 0xae, 0xd6, 0x61, 0xef, 0xd7, 0x3a, 0xec, 0x7d, 0x7d, 0x23, 0x95, 0x9b, 0xd7,
        0x19, 0x9b, 0x99, 0x45, 0xea, 0x40, 0x6b, 0x63, 0xdf, 0x29, 0x93, 0x36, 0x01, 0x3a, 0x6f, 0x23,
        0xe4, 0x96, 0x25, 0x54, 0xd9, 0xc0, 0xb7, 0x7b, 0xff, 0x2f, 0x00, 0x00, 0xff, 0xff, 0xf0, 0xf9,
        0xe2, 0x3e, 0xc2, 0x02, 0x00, 0x00,
}

func (m *Aggregate) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Aggregate) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Aggregate) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Height != 0 </span><span class="cov0" title="0">{
                i = encodeVarintAggregate(dAtA, i, uint64(m.Height))
                i--
                dAtA[i] = 0x50
        }</span>
        <span class="cov0" title="0">if m.AggregateReportIndex != 0 </span><span class="cov0" title="0">{
                i = encodeVarintAggregate(dAtA, i, uint64(m.AggregateReportIndex))
                i--
                dAtA[i] = 0x48
        }</span>
        <span class="cov0" title="0">if m.Nonce != 0 </span><span class="cov0" title="0">{
                i = encodeVarintAggregate(dAtA, i, uint64(m.Nonce))
                i--
                dAtA[i] = 0x40
        }</span>
        <span class="cov0" title="0">if m.Flagged </span><span class="cov0" title="0">{
                i--
                if m.Flagged </span><span class="cov0" title="0">{
                        dAtA[i] = 1
                }</span> else<span class="cov0" title="0"> {
                        dAtA[i] = 0
                }</span>
                <span class="cov0" title="0">i--
                dAtA[i] = 0x38</span>
        }
        <span class="cov0" title="0">if len(m.Reporters) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Reporters) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Reporters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintAggregate(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x32</span>
                }
        }
        <span class="cov0" title="0">if m.StandardDeviation != 0 </span><span class="cov0" title="0">{
                i -= 8
                encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.StandardDeviation))))
                i--
                dAtA[i] = 0x29
        }</span>
        <span class="cov0" title="0">if m.ReporterPower != 0 </span><span class="cov0" title="0">{
                i = encodeVarintAggregate(dAtA, i, uint64(m.ReporterPower))
                i--
                dAtA[i] = 0x20
        }</span>
        <span class="cov0" title="0">if len(m.AggregateReporter) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.AggregateReporter)
                copy(dAtA[i:], m.AggregateReporter)
                i = encodeVarintAggregate(dAtA, i, uint64(len(m.AggregateReporter)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.AggregateValue) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.AggregateValue)
                copy(dAtA[i:], m.AggregateValue)
                i = encodeVarintAggregate(dAtA, i, uint64(len(m.AggregateValue)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.QueryId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryId)
                copy(dAtA[i:], m.QueryId)
                i = encodeVarintAggregate(dAtA, i, uint64(len(m.QueryId)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *AvailableTimestamps) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *AvailableTimestamps) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *AvailableTimestamps) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Timestamps) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Timestamps) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        n, err := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamps[iNdEx], dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamps[iNdEx]):])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= n
                        i = encodeVarintAggregate(dAtA, i, uint64(n))
                        i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintAggregate(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovAggregate(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Aggregate) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.QueryId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovAggregate(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.AggregateValue)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovAggregate(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.AggregateReporter)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovAggregate(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.ReporterPower != 0 </span><span class="cov0" title="0">{
                n += 1 + sovAggregate(uint64(m.ReporterPower))
        }</span>
        <span class="cov0" title="0">if m.StandardDeviation != 0 </span><span class="cov0" title="0">{
                n += 9
        }</span>
        <span class="cov0" title="0">if len(m.Reporters) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Reporters </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovAggregate(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">if m.Flagged </span><span class="cov0" title="0">{
                n += 2
        }</span>
        <span class="cov0" title="0">if m.Nonce != 0 </span><span class="cov0" title="0">{
                n += 1 + sovAggregate(uint64(m.Nonce))
        }</span>
        <span class="cov0" title="0">if m.AggregateReportIndex != 0 </span><span class="cov0" title="0">{
                n += 1 + sovAggregate(uint64(m.AggregateReportIndex))
        }</span>
        <span class="cov0" title="0">if m.Height != 0 </span><span class="cov0" title="0">{
                n += 1 + sovAggregate(uint64(m.Height))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *AvailableTimestamps) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Timestamps) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Timestamps </span><span class="cov0" title="0">{
                        l = github_com_cosmos_gogoproto_types.SizeOfStdTime(e)
                        n += 1 + l + sovAggregate(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func sovAggregate(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozAggregate(x uint64) (n int) <span class="cov0" title="0">{
        return sovAggregate(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Aggregate) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAggregate
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Aggregate: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Aggregate: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAggregate
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAggregate
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAggregate
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryId = append(m.QueryId[:0], dAtA[iNdEx:postIndex]...)
                        if m.QueryId == nil </span><span class="cov0" title="0">{
                                m.QueryId = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AggregateValue", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAggregate
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAggregate
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAggregate
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.AggregateValue = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AggregateReporter", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAggregate
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAggregate
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAggregate
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.AggregateReporter = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ReporterPower", wireType)
                        }</span>
                        <span class="cov0" title="0">m.ReporterPower = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAggregate
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.ReporterPower |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 5:<span class="cov0" title="0">
                        if wireType != 1 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field StandardDeviation", wireType)
                        }</span>
                        <span class="cov0" title="0">var v uint64
                        if (iNdEx + 8) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
                        iNdEx += 8
                        m.StandardDeviation = float64(math.Float64frombits(v))</span>
                case 6:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Reporters", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAggregate
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAggregate
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAggregate
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Reporters = append(m.Reporters, &amp;AggregateReporter{})
                        if err := m.Reporters[len(m.Reporters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 7:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Flagged", wireType)
                        }</span>
                        <span class="cov0" title="0">var v int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAggregate
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                v |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">m.Flagged = bool(v != 0)</span>
                case 8:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Nonce = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAggregate
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Nonce |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 9:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AggregateReportIndex", wireType)
                        }</span>
                        <span class="cov0" title="0">m.AggregateReportIndex = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAggregate
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.AggregateReportIndex |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 10:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Height = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAggregate
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Height |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipAggregate(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAggregate
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *AvailableTimestamps) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAggregate
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: AvailableTimestamps: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: AvailableTimestamps: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Timestamps", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAggregate
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAggregate
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAggregate
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Timestamps = append(m.Timestamps, time.Time{})
                        if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&amp;(m.Timestamps[len(m.Timestamps)-1]), dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipAggregate(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAggregate
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipAggregate(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowAggregate
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowAggregate
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowAggregate
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthAggregate
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupAggregate
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthAggregate
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthAggregate        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowAggregate          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupAggregate = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file106" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/oracle/aggregate_reporter.proto

package types

import (
        fmt "fmt"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AggregateReporter struct {
        Reporter string `protobuf:"bytes,1,opt,name=reporter,proto3" json:"reporter,omitempty"`
        Power    int64  `protobuf:"varint,2,opt,name=power,proto3" json:"power,omitempty"`
}

func (m *AggregateReporter) Reset()         <span class="cov0" title="0">{ *m = AggregateReporter{} }</span>
func (m *AggregateReporter) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*AggregateReporter) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*AggregateReporter) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_c1d4f41be31c27a7, []int{0}
}</span>
func (m *AggregateReporter) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *AggregateReporter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_AggregateReporter.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *AggregateReporter) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_AggregateReporter.Merge(m, src)
}</span>
func (m *AggregateReporter) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *AggregateReporter) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_AggregateReporter.DiscardUnknown(m)
}</span>

var xxx_messageInfo_AggregateReporter proto.InternalMessageInfo

func (m *AggregateReporter) GetReporter() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Reporter
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *AggregateReporter) GetPower() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Power
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*AggregateReporter)(nil), "layer.oracle.AggregateReporter")
}</span>

func init() <span class="cov8" title="1">{
        proto.RegisterFile("layer/oracle/aggregate_reporter.proto", fileDescriptor_c1d4f41be31c27a7)
}</span>

var fileDescriptor_c1d4f41be31c27a7 = []byte{
        // 179 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x52, 0xcd, 0x49, 0xac, 0x4c,
        0x2d, 0xd2, 0xcf, 0x2f, 0x4a, 0x4c, 0xce, 0x49, 0xd5, 0x4f, 0x4c, 0x4f, 0x2f, 0x4a, 0x4d, 0x4f,
        0x2c, 0x49, 0x8d, 0x2f, 0x4a, 0x2d, 0xc8, 0x2f, 0x2a, 0x49, 0x2d, 0xd2, 0x2b, 0x28, 0xca, 0x2f,
        0xc9, 0x17, 0xe2, 0x01, 0x2b, 0xd3, 0x83, 0x28, 0x53, 0x72, 0xe5, 0x12, 0x74, 0x84, 0xa9, 0x0c,
        0x82, 0x2a, 0x14, 0x92, 0xe2, 0xe2, 0x80, 0x69, 0x92, 0x60, 0x54, 0x60, 0xd4, 0xe0, 0x0c, 0x82,
        0xf3, 0x85, 0x44, 0xb8, 0x58, 0x0b, 0xf2, 0xcb, 0x53, 0x8b, 0x24, 0x98, 0x14, 0x18, 0x35, 0x98,
        0x83, 0x20, 0x1c, 0x27, 0xe7, 0x13, 0x8f, 0xe4, 0x18, 0x2f, 0x3c, 0x92, 0x63, 0x7c, 0xf0, 0x48,
        0x8e, 0x71, 0xc2, 0x63, 0x39, 0x86, 0x0b, 0x8f, 0xe5, 0x18, 0x6e, 0x3c, 0x96, 0x63, 0x88, 0xd2,
        0x4c, 0xcf, 0x2c, 0xc9, 0x28, 0x4d, 0xd2, 0x4b, 0xce, 0xcf, 0xd5, 0x2f, 0x49, 0xcd, 0xc9, 0xc9,
        0x2f, 0xd2, 0xcd, 0xcc, 0xd7, 0x87, 0x38, 0xb5, 0x02, 0xe6, 0xd8, 0x92, 0xca, 0x82, 0xd4, 0xe2,
        0x24, 0x36, 0xb0, 0x03, 0x8d, 0x01, 0x01, 0x00, 0x00, 0xff, 0xff, 0x52, 0x6d, 0xbc, 0x71, 0xc9,
        0x00, 0x00, 0x00,
}

func (m *AggregateReporter) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *AggregateReporter) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *AggregateReporter) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Power != 0 </span><span class="cov0" title="0">{
                i = encodeVarintAggregateReporter(dAtA, i, uint64(m.Power))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.Reporter) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Reporter)
                copy(dAtA[i:], m.Reporter)
                i = encodeVarintAggregateReporter(dAtA, i, uint64(len(m.Reporter)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintAggregateReporter(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovAggregateReporter(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *AggregateReporter) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Reporter)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovAggregateReporter(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Power != 0 </span><span class="cov0" title="0">{
                n += 1 + sovAggregateReporter(uint64(m.Power))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovAggregateReporter(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozAggregateReporter(x uint64) (n int) <span class="cov0" title="0">{
        return sovAggregateReporter(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *AggregateReporter) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAggregateReporter
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: AggregateReporter: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: AggregateReporter: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAggregateReporter
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAggregateReporter
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAggregateReporter
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Reporter = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Power = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAggregateReporter
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Power |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipAggregateReporter(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAggregateReporter
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipAggregateReporter(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowAggregateReporter
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowAggregateReporter
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowAggregateReporter
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthAggregateReporter
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupAggregateReporter
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthAggregateReporter
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthAggregateReporter        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowAggregateReporter          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupAggregateReporter = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file107" style="display: none">package types

import (
        "github.com/cosmos/cosmos-sdk/codec"
        cdctypes "github.com/cosmos/cosmos-sdk/codec/types"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/msgservice"
)

func RegisterCodec(cdc *codec.LegacyAmino) <span class="cov0" title="0">{
        cdc.RegisterConcrete(&amp;MsgSubmitValue{}, "oracle/SubmitValue", nil)
        cdc.RegisterConcrete(&amp;MsgCommitReport{}, "oracle/CommitReport", nil)
        cdc.RegisterConcrete(&amp;MsgTip{}, "oracle/Tip", nil)
        cdc.RegisterConcrete(&amp;MsgUpdateParams{}, "oracle/UpdateParams", nil)
        cdc.RegisterConcrete(&amp;MsgUpdateCyclelist{}, "oracle/UpdateCyclelist", nil)
        // this line is used by starport scaffolding # 2
}</span>

func RegisterInterfaces(registry cdctypes.InterfaceRegistry) <span class="cov0" title="0">{
        registry.RegisterImplementations((*sdk.Msg)(nil),
                &amp;MsgSubmitValue{},
        )
        registry.RegisterImplementations((*sdk.Msg)(nil),
                &amp;MsgCommitReport{},
        )
        registry.RegisterImplementations((*sdk.Msg)(nil),
                &amp;MsgTip{},
        )
        registry.RegisterImplementations((*sdk.Msg)(nil),
                &amp;MsgUpdateParams{},
        )
        registry.RegisterImplementations((*sdk.Msg)(nil),
                &amp;MsgUpdateCyclelist{},
        )
        // this line is used by starport scaffolding # 3

        msgservice.RegisterMsgServiceDesc(registry, &amp;_Msg_serviceDesc)
}</span>

var (
        Amino     = codec.NewLegacyAmino()
        ModuleCdc = codec.NewProtoCodec(cdctypes.NewInterfaceRegistry())
)
</pre>
		
		<pre class="file" id="file108" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/oracle/commit_report.proto

package types

import (
        fmt "fmt"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Commit struct {
        Reporter string `protobuf:"bytes,1,opt,name=reporter,proto3" json:"reporter,omitempty"`
        QueryId  []byte `protobuf:"bytes,2,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
        Hash     string `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
        Incycle  bool   `protobuf:"varint,4,opt,name=incycle,proto3" json:"incycle,omitempty"`
}

func (m *Commit) Reset()         <span class="cov0" title="0">{ *m = Commit{} }</span>
func (m *Commit) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Commit) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Commit) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_b56672e00badb6a1, []int{0}
}</span>
func (m *Commit) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Commit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Commit.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Commit) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Commit.Merge(m, src)
}</span>
func (m *Commit) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Commit) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Commit.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Commit proto.InternalMessageInfo

func (m *Commit) GetReporter() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Reporter
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Commit) GetQueryId() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryId
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Commit) GetHash() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Hash
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Commit) GetIncycle() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Incycle
        }</span>
        <span class="cov0" title="0">return false</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Commit)(nil), "layer.oracle.Commit")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/oracle/commit_report.proto", fileDescriptor_b56672e00badb6a1) }</span>

var fileDescriptor_b56672e00badb6a1 = []byte{
        // 219 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x52, 0xc8, 0x49, 0xac, 0x4c,
        0x2d, 0xd2, 0xcf, 0x2f, 0x4a, 0x4c, 0xce, 0x49, 0xd5, 0x4f, 0xce, 0xcf, 0xcd, 0xcd, 0x2c, 0x89,
        0x2f, 0x4a, 0x2d, 0xc8, 0x2f, 0x2a, 0xd1, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x01, 0xab,
        0xd0, 0x83, 0xa8, 0x90, 0x12, 0x45, 0x51, 0x5f, 0x52, 0x01, 0x51, 0xa4, 0x94, 0xcb, 0xc5, 0xe6,
        0x0c, 0xd6, 0x2b, 0x24, 0xc5, 0xc5, 0x01, 0xd1, 0x9e, 0x5a, 0x24, 0xc1, 0xa8, 0xc0, 0xa8, 0xc1,
        0x19, 0x04, 0xe7, 0x0b, 0x49, 0x72, 0x71, 0x14, 0x96, 0xa6, 0x16, 0x55, 0xc6, 0x67, 0xa6, 0x48,
        0x30, 0x29, 0x30, 0x6a, 0xf0, 0x04, 0xb1, 0x83, 0xf9, 0x9e, 0x29, 0x42, 0x42, 0x5c, 0x2c, 0x19,
        0x89, 0xc5, 0x19, 0x12, 0xcc, 0x60, 0x2d, 0x60, 0xb6, 0x90, 0x04, 0x17, 0x7b, 0x66, 0x5e, 0x72,
        0x65, 0x72, 0x4e, 0xaa, 0x04, 0x8b, 0x02, 0xa3, 0x06, 0x47, 0x10, 0x8c, 0xeb, 0xe4, 0x7c, 0xe2,
        0x91, 0x1c, 0xe3, 0x85, 0x47, 0x72, 0x8c, 0x0f, 0x1e, 0xc9, 0x31, 0x4e, 0x78, 0x2c, 0xc7, 0x70,
        0xe1, 0xb1, 0x1c, 0xc3, 0x8d, 0xc7, 0x72, 0x0c, 0x51, 0x9a, 0xe9, 0x99, 0x25, 0x19, 0xa5, 0x49,
        0x7a, 0xc9, 0xf9, 0xb9, 0xfa, 0x25, 0xa9, 0x39, 0x39, 0xf9, 0x45, 0xba, 0x99, 0xf9, 0xfa, 0x10,
        0x47, 0x57, 0xc0, 0x9d, 0x5d, 0x59, 0x90, 0x5a, 0x9c, 0xc4, 0x06, 0x76, 0xba, 0x31, 0x20, 0x00,
        0x00, 0xff, 0xff, 0x74, 0xb4, 0x6d, 0xff, 0x03, 0x01, 0x00, 0x00,
}

func (m *Commit) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Commit) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Commit) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Incycle </span><span class="cov0" title="0">{
                i--
                if m.Incycle </span><span class="cov0" title="0">{
                        dAtA[i] = 1
                }</span> else<span class="cov0" title="0"> {
                        dAtA[i] = 0
                }</span>
                <span class="cov0" title="0">i--
                dAtA[i] = 0x20</span>
        }
        <span class="cov0" title="0">if len(m.Hash) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Hash)
                copy(dAtA[i:], m.Hash)
                i = encodeVarintCommitReport(dAtA, i, uint64(len(m.Hash)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.QueryId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryId)
                copy(dAtA[i:], m.QueryId)
                i = encodeVarintCommitReport(dAtA, i, uint64(len(m.QueryId)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Reporter) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Reporter)
                copy(dAtA[i:], m.Reporter)
                i = encodeVarintCommitReport(dAtA, i, uint64(len(m.Reporter)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintCommitReport(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovCommitReport(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Commit) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Reporter)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovCommitReport(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.QueryId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovCommitReport(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Hash)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovCommitReport(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Incycle </span><span class="cov0" title="0">{
                n += 2
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovCommitReport(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozCommitReport(x uint64) (n int) <span class="cov0" title="0">{
        return sovCommitReport(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Commit) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCommitReport
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Commit: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Commit: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCommitReport
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCommitReport
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCommitReport
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Reporter = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCommitReport
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCommitReport
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCommitReport
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryId = append(m.QueryId[:0], dAtA[iNdEx:postIndex]...)
                        if m.QueryId == nil </span><span class="cov0" title="0">{
                                m.QueryId = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCommitReport
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCommitReport
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCommitReport
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Hash = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Incycle", wireType)
                        }</span>
                        <span class="cov0" title="0">var v int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCommitReport
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                v |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">m.Incycle = bool(v != 0)</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCommitReport(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCommitReport
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipCommitReport(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowCommitReport
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowCommitReport
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowCommitReport
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthCommitReport
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupCommitReport
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthCommitReport
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthCommitReport        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowCommitReport          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupCommitReport = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file109" style="display: none">package types

import "encoding/hex"

func InitialCycleList() [][]byte <span class="cov8" title="1">{
        strs := []string{
                //ETH/USD
                "00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000953706F745072696365000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C0000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000003657468000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000037573640000000000000000000000000000000000000000000000000000000000",
                //BTC/USD
                "00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000953706F745072696365000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C0000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000003627463000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000037573640000000000000000000000000000000000000000000000000000000000",
                //TRB/USD
                "00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000953706F745072696365000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C0000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000003747262000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000037573640000000000000000000000000000000000000000000000000000000000",
        }

        var cycleList [][]byte

        for _, str := range strs </span><span class="cov8" title="1">{
                bz, err := hex.DecodeString(str)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov8" title="1">cycleList = append(cycleList, bz)</span>
        }

        <span class="cov8" title="1">return cycleList</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package types

// this line is used by starport scaffolding # genesis/types/import

// DefaultIndex is the default global index
const DefaultIndex uint64 = 1

// DefaultGenesis returns the default genesis state
func DefaultGenesis() *GenesisState <span class="cov8" title="1">{
        return &amp;GenesisState{
                // this line is used by starport scaffolding # genesis/types/default
                Params:    DefaultParams(),
                Cyclelist: InitialCycleList(),
        }
}</span>

// Validate performs basic genesis state validation returning an error upon any
// failure.
func (gs GenesisState) Validate() error <span class="cov8" title="1">{
        // this line is used by starport scaffolding # genesis/types/validate

        return gs.Params.Validate()
}</span>
</pre>
		
		<pre class="file" id="file111" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/oracle/genesis.proto

package types

import (
        fmt "fmt"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GenesisState defines the oracle module's genesis state.
type GenesisState struct {
        Params    Params   `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
        Cyclelist [][]byte `protobuf:"bytes,2,rep,name=cyclelist,proto3" json:"cyclelist,omitempty"`
}

func (m *GenesisState) Reset()         <span class="cov0" title="0">{ *m = GenesisState{} }</span>
func (m *GenesisState) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GenesisState) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GenesisState) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_ae3e046083fcf09b, []int{0}
}</span>
func (m *GenesisState) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *GenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_GenesisState.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *GenesisState) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GenesisState.Merge(m, src)
}</span>
func (m *GenesisState) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *GenesisState) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GenesisState.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GenesisState proto.InternalMessageInfo

func (m *GenesisState) GetParams() Params <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Params
        }</span>
        <span class="cov0" title="0">return Params{}</span>
}

func (m *GenesisState) GetCyclelist() [][]byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Cyclelist
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*GenesisState)(nil), "layer.oracle.GenesisState")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/oracle/genesis.proto", fileDescriptor_ae3e046083fcf09b) }</span>

var fileDescriptor_ae3e046083fcf09b = []byte{
        // 214 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0xca, 0x49, 0xac, 0x4c,
        0x2d, 0xd2, 0xcf, 0x2f, 0x4a, 0x4c, 0xce, 0x49, 0xd5, 0x4f, 0x4f, 0xcd, 0x4b, 0x2d, 0xce, 0x2c,
        0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x01, 0xcb, 0xe9, 0x41, 0xe4, 0xa4, 0x44, 0xd2,
        0xf3, 0xd3, 0xf3, 0xc1, 0x12, 0xfa, 0x20, 0x16, 0x44, 0x8d, 0x94, 0x24, 0x8a, 0xfe, 0x82, 0xc4,
        0xa2, 0xc4, 0x5c, 0xa8, 0x76, 0xa5, 0x34, 0x2e, 0x1e, 0x77, 0x88, 0x79, 0xc1, 0x25, 0x89, 0x25,
        0xa9, 0x42, 0x46, 0x5c, 0x6c, 0x10, 0x79, 0x09, 0x46, 0x05, 0x46, 0x0d, 0x6e, 0x23, 0x11, 0x3d,
        0x64, 0xf3, 0xf5, 0x02, 0xc0, 0x72, 0x4e, 0x2c, 0x27, 0xee, 0xc9, 0x33, 0x04, 0x41, 0x55, 0x0a,
        0x29, 0x71, 0x71, 0x26, 0x57, 0x26, 0xe7, 0xa4, 0xe6, 0x64, 0x16, 0x97, 0x48, 0x30, 0x29, 0x30,
        0x6b, 0xf0, 0x40, 0x15, 0x20, 0x84, 0x9d, 0x9c, 0x4f, 0x3c, 0x92, 0x63, 0xbc, 0xf0, 0x48, 0x8e,
        0xf1, 0xc1, 0x23, 0x39, 0xc6, 0x09, 0x8f, 0xe5, 0x18, 0x2e, 0x3c, 0x96, 0x63, 0xb8, 0xf1, 0x58,
        0x8e, 0x21, 0x4a, 0x33, 0x3d, 0xb3, 0x24, 0xa3, 0x34, 0x49, 0x2f, 0x39, 0x3f, 0x57, 0xbf, 0x24,
        0x35, 0x27, 0x27, 0xbf, 0x48, 0x37, 0x33, 0x5f, 0x1f, 0xe2, 0xe2, 0x0a, 0x98, 0x9b, 0x4b, 0x2a,
        0x0b, 0x52, 0x8b, 0x93, 0xd8, 0xc0, 0x6e, 0x36, 0x06, 0x04, 0x00, 0x00, 0xff, 0xff, 0x34, 0x40,
        0x07, 0xff, 0x10, 0x01, 0x00, 0x00,
}

func (m *GenesisState) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *GenesisState) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *GenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Cyclelist) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Cyclelist) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        i -= len(m.Cyclelist[iNdEx])
                        copy(dAtA[i:], m.Cyclelist[iNdEx])
                        i = encodeVarintGenesis(dAtA, i, uint64(len(m.Cyclelist[iNdEx])))
                        i--
                        dAtA[i] = 0x12
                }</span>
        }
        <span class="cov0" title="0">{
                size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintGenesis(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func encodeVarintGenesis(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovGenesis(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *GenesisState) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Params.Size()
        n += 1 + l + sovGenesis(uint64(l))
        if len(m.Cyclelist) &gt; 0 </span><span class="cov0" title="0">{
                for _, b := range m.Cyclelist </span><span class="cov0" title="0">{
                        l = len(b)
                        n += 1 + l + sovGenesis(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func sovGenesis(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozGenesis(x uint64) (n int) <span class="cov0" title="0">{
        return sovGenesis(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *GenesisState) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowGenesis
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Cyclelist", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Cyclelist = append(m.Cyclelist, make([]byte, postIndex-iNdEx))
                        copy(m.Cyclelist[len(m.Cyclelist)-1], dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipGenesis(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipGenesis(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowGenesis
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupGenesis
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthGenesis
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthGenesis        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowGenesis          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupGenesis = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file112" style="display: none">package types

import (
        "cosmossdk.io/collections"
)

const (
        // ModuleName defines the module name
        ModuleName = "oracle"

        // StoreKey defines the primary module store key
        StoreKey = ModuleName

        // RouterKey defines the module's message routing key
        RouterKey = ModuleName

        // MemStoreKey defines the in-memory store key
        MemStoreKey = "mem_oracle"

        // ParamsKey
        ParamsKey = "oracle_params"
)

var (
        CommitsPrefix   = collections.NewPrefix(0)
        TipsPrefix      = collections.NewPrefix(1)
        TipsIndexPrefix = collections.NewPrefix(2)

        ReportsPrefix              = collections.NewPrefix(3)
        ReportsHeightIndexPrefix   = collections.NewPrefix(4)
        ReportsReporterIndexPrefix = collections.NewPrefix(5)

        AggregatesPrefix = collections.NewPrefix(6)
        NoncesPrefix     = collections.NewPrefix(7)
        TotalTipsPrefix  = collections.NewPrefix(8)

        QuerySeqPrefix              = collections.NewPrefix(9)
        QueryTipPrefix              = collections.NewPrefix(10)
        ReportsIdIndexPrefix        = collections.NewPrefix(11)
        QueryCyclePrefix            = collections.NewPrefix(12)
        CycleSeqPrefix              = collections.NewPrefix(13)
        QueryTipPrefix2             = collections.NewPrefix(14)
        NextInListPrefix            = collections.NewPrefix(15)
        QueryRevealedIdsIndexPrefix = collections.NewPrefix(16)
        CyclelistPrefix             = collections.NewPrefix(17)
        QueryTypeIndexPrefix        = collections.NewPrefix(18)
        AggregatesHeightIndexPrefix = collections.NewPrefix(19)
)

func KeyPrefix(p string) []byte <span class="cov0" title="0">{
        return []byte(p)
}</span>

func ParamsKeyPrefix() []byte <span class="cov0" title="0">{
        return KeyPrefix(ParamsKey)
}</span>
</pre>
		
		<pre class="file" id="file113" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/oracle/median_values.proto

package types

import (
        fmt "fmt"
        io "io"
        math "math"
        math_bits "math/bits"

        proto "github.com/cosmos/gogoproto/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MedianValues struct {
        MarketId uint32 `protobuf:"varint,1,opt,name=marketId,proto3" json:"marketId,omitempty"`
        Price    uint64 `protobuf:"varint,2,opt,name=price,proto3" json:"price,omitempty"`
}

func (m *MedianValues) Reset()         <span class="cov0" title="0">{ *m = MedianValues{} }</span>
func (m *MedianValues) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MedianValues) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MedianValues) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_5100164e71c118d7, []int{0}
}</span>
func (m *MedianValues) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MedianValues) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MedianValues.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MedianValues) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MedianValues.Merge(m, src)
}</span>
func (m *MedianValues) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MedianValues) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MedianValues.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MedianValues proto.InternalMessageInfo

func (m *MedianValues) GetMarketId() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MarketId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *MedianValues) GetPrice() uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Price
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*MedianValues)(nil), "layer.oracle.MedianValues")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/oracle/median_values.proto", fileDescriptor_5100164e71c118d7) }</span>

var fileDescriptor_5100164e71c118d7 = []byte{
        // 180 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x52, 0xc8, 0x49, 0xac, 0x4c,
        0x2d, 0xd2, 0xcf, 0x2f, 0x4a, 0x4c, 0xce, 0x49, 0xd5, 0xcf, 0x4d, 0x4d, 0xc9, 0x4c, 0xcc, 0x8b,
        0x2f, 0x4b, 0xcc, 0x29, 0x4d, 0x2d, 0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x01, 0xab,
        0xd0, 0x83, 0xa8, 0x50, 0x72, 0xe0, 0xe2, 0xf1, 0x05, 0x2b, 0x0a, 0x03, 0xab, 0x11, 0x92, 0xe2,
        0xe2, 0xc8, 0x4d, 0x2c, 0xca, 0x4e, 0x2d, 0xf1, 0x4c, 0x91, 0x60, 0x54, 0x60, 0xd4, 0xe0, 0x0d,
        0x82, 0xf3, 0x85, 0x44, 0xb8, 0x58, 0x0b, 0x8a, 0x32, 0x93, 0x53, 0x25, 0x98, 0x14, 0x18, 0x35,
        0x58, 0x82, 0x20, 0x1c, 0x27, 0xe7, 0x13, 0x8f, 0xe4, 0x18, 0x2f, 0x3c, 0x92, 0x63, 0x7c, 0xf0,
        0x48, 0x8e, 0x71, 0xc2, 0x63, 0x39, 0x86, 0x0b, 0x8f, 0xe5, 0x18, 0x6e, 0x3c, 0x96, 0x63, 0x88,
        0xd2, 0x4c, 0xcf, 0x2c, 0xc9, 0x28, 0x4d, 0xd2, 0x4b, 0xce, 0xcf, 0xd5, 0x2f, 0x49, 0xcd, 0xc9,
        0xc9, 0x2f, 0xd2, 0xcd, 0xcc, 0xd7, 0x87, 0x38, 0xb0, 0x02, 0xe6, 0xc4, 0x92, 0xca, 0x82, 0xd4,
        0xe2, 0x24, 0x36, 0xb0, 0xdb, 0x8c, 0x01, 0x01, 0x00, 0x00, 0xff, 0xff, 0x88, 0x84, 0xe1, 0x9d,
        0xbf, 0x00, 0x00, 0x00,
}

func (m *MedianValues) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MedianValues) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MedianValues) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Price != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMedianValues(dAtA, i, uint64(m.Price))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if m.MarketId != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMedianValues(dAtA, i, uint64(m.MarketId))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintMedianValues(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovMedianValues(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *MedianValues) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.MarketId != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMedianValues(uint64(m.MarketId))
        }</span>
        <span class="cov0" title="0">if m.Price != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMedianValues(uint64(m.Price))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovMedianValues(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozMedianValues(x uint64) (n int) <span class="cov0" title="0">{
        return sovMedianValues(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *MedianValues) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMedianValues
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MedianValues: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MedianValues: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
                        }</span>
                        <span class="cov0" title="0">m.MarketId = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMedianValues
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.MarketId |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Price = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMedianValues
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Price |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMedianValues(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMedianValues
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipMedianValues(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowMedianValues
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowMedianValues
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowMedianValues
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthMedianValues
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupMedianValues
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthMedianValues
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthMedianValues        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowMedianValues          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupMedianValues = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file114" style="display: none">package types

import (
        errorsmod "cosmossdk.io/errors"
        sdk "github.com/cosmos/cosmos-sdk/types"
        sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
        "github.com/tellor-io/layer/utils"
)

const TypeMsgCommitReport = "commit_report"

var _ sdk.Msg = &amp;MsgCommitReport{}

func NewMsgCommitReport(creator string, queryData string, hash string) *MsgCommitReport <span class="cov0" title="0">{
        qDataBz, err := utils.QueryBytesFromString(queryData)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return &amp;MsgCommitReport{
                Creator:   creator,
                QueryData: qDataBz,
                Hash:      hash,
        }</span>
}

func (msg *MsgCommitReport) Route() string <span class="cov0" title="0">{
        return RouterKey
}</span>

func (msg *MsgCommitReport) Type() string <span class="cov0" title="0">{
        return TypeMsgCommitReport
}</span>

func (msg *MsgCommitReport) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        creator, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return []sdk.AccAddress{creator}</span>
}

func (msg *MsgCommitReport) GetSignBytes() []byte <span class="cov0" title="0">{
        bz := ModuleCdc.MustMarshalJSON(msg)
        return sdk.MustSortJSON(bz)
}</span>

func (msg *MsgCommitReport) ValidateBasic() error <span class="cov8" title="1">{
        _, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov8" title="1">{
                return errorsmod.Wrapf(sdkerrors.ErrInvalidAddress, "invalid creator address (%s)", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (msg *MsgCommitReport) GetSignerAndValidateMsg() (sdk.AccAddress, error) <span class="cov0" title="0">{
        addr, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errorsmod.Wrapf(sdkerrors.ErrInvalidAddress, "invalid creator address (%s)", err)
        }</span>
        <span class="cov0" title="0">if len(msg.QueryData) == 0 </span><span class="cov0" title="0">{
                return nil, errorsmod.Wrap(sdkerrors.ErrInvalidRequest, "query data field cannot be empty")
        }</span>
        <span class="cov0" title="0">if msg.Hash == "" </span><span class="cov0" title="0">{
                return nil, errorsmod.Wrap(sdkerrors.ErrInvalidRequest, "hash field cannot be empty")
        }</span>
        <span class="cov0" title="0">return addr, nil</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package types

import (
        errorsmod "cosmossdk.io/errors"
        sdk "github.com/cosmos/cosmos-sdk/types"
        sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
        "github.com/tellor-io/layer/utils"
)

const TypeMsgSubmitValue = "submit_value"

var _ sdk.Msg = &amp;MsgSubmitValue{}

func NewMsgSubmitValue(creator string, queryData string, value string, salt string) *MsgSubmitValue <span class="cov0" title="0">{
        queryDataBz, err := utils.QueryBytesFromString(queryData)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return &amp;MsgSubmitValue{
                Creator:   creator,
                QueryData: queryDataBz,
                Value:     value,
                Salt:      salt,
        }</span>
}

func (msg *MsgSubmitValue) Route() string <span class="cov0" title="0">{
        return RouterKey
}</span>

func (msg *MsgSubmitValue) Type() string <span class="cov0" title="0">{
        return TypeMsgSubmitValue
}</span>

func (msg *MsgSubmitValue) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        creator, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return []sdk.AccAddress{creator}</span>
}

func (msg *MsgSubmitValue) GetSignBytes() []byte <span class="cov0" title="0">{
        bz := ModuleCdc.MustMarshalJSON(msg)
        return sdk.MustSortJSON(bz)
}</span>

func (msg *MsgSubmitValue) ValidateBasic() error <span class="cov8" title="1">{
        _, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov8" title="1">{
                return errorsmod.Wrapf(sdkerrors.ErrInvalidAddress, "invalid creator address (%s)", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (msg *MsgSubmitValue) GetSignerAndValidateMsg() (sdk.AccAddress, error) <span class="cov0" title="0">{
        addr, err := sdk.AccAddressFromBech32(msg.Creator)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errorsmod.Wrapf(sdkerrors.ErrInvalidAddress, "invalid creator address (%s)", err)
        }</span>
        <span class="cov0" title="0">if len(msg.QueryData) == 0 </span><span class="cov0" title="0">{
                return nil, errorsmod.Wrap(sdkerrors.ErrInvalidRequest, "query data cannot be empty")
        }</span>
        <span class="cov0" title="0">if msg.Value == "" </span><span class="cov0" title="0">{
                return nil, errorsmod.Wrap(sdkerrors.ErrInvalidRequest, "value cannot be empty")
        }</span>
        <span class="cov0" title="0">return addr, nil</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">package types

import (
        errorsmod "cosmossdk.io/errors"
        sdk "github.com/cosmos/cosmos-sdk/types"
        sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
        "github.com/tellor-io/layer/utils"
)

const TypeMsgTip = "tip"

var _ sdk.Msg = &amp;MsgTip{}

func NewMsgTip(tipper string, queryData string, amount sdk.Coin) *MsgTip <span class="cov0" title="0">{
        queryDataBz, err := utils.QueryBytesFromString(queryData)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return &amp;MsgTip{
                Tipper:    tipper,
                QueryData: queryDataBz,
                Amount:    amount,
        }</span>
}

func (msg *MsgTip) Route() string <span class="cov0" title="0">{
        return RouterKey
}</span>

func (msg *MsgTip) Type() string <span class="cov0" title="0">{
        return TypeMsgTip
}</span>

func (msg *MsgTip) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        tipper, err := sdk.AccAddressFromBech32(msg.Tipper)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return []sdk.AccAddress{tipper}</span>
}

func (msg *MsgTip) GetSignBytes() []byte <span class="cov0" title="0">{
        bz := ModuleCdc.MustMarshalJSON(msg)
        return sdk.MustSortJSON(bz)
}</span>

func (msg *MsgTip) ValidateBasic() error <span class="cov8" title="1">{
        _, err := sdk.AccAddressFromBech32(msg.Tipper)
        if err != nil </span><span class="cov8" title="1">{
                return errorsmod.Wrapf(sdkerrors.ErrInvalidAddress, "invalid tipper address (%s)", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/oracle/micro_report.proto

package types

import (
        fmt "fmt"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
        _ "google.golang.org/protobuf/types/known/timestamppb"
        io "io"
        math "math"
        math_bits "math/bits"
        time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MicroReport represents data for a single report
type MicroReport struct {
        // reporter is the address of the reporter
        Reporter string `protobuf:"bytes,1,opt,name=reporter,proto3" json:"reporter,omitempty"`
        // the power of the reporter based on total tokens normalized
        Power int64 `protobuf:"varint,2,opt,name=power,proto3" json:"power,omitempty"`
        // string identifier of the data spec
        QueryType string `protobuf:"bytes,3,opt,name=query_type,json=queryType,proto3" json:"query_type,omitempty"`
        // hash of the query data
        QueryId []byte `protobuf:"bytes,4,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
        // aggregate method to use for aggregating all the reports for the query id
        AggregateMethod string `protobuf:"bytes,5,opt,name=aggregate_method,json=aggregateMethod,proto3" json:"aggregate_method,omitempty"`
        // hex string of the response value
        Value string `protobuf:"bytes,6,opt,name=value,proto3" json:"value,omitempty"`
        // timestamp of when the report was created
        Timestamp time.Time `protobuf:"bytes,7,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
        // indicates if the report's query id is in the cyclelist
        Cyclelist bool `protobuf:"varint,8,opt,name=cyclelist,proto3" json:"cyclelist,omitempty"`
        // block number of when the report was created
        BlockNumber int64 `protobuf:"varint,9,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
}

func (m *MicroReport) Reset()         <span class="cov0" title="0">{ *m = MicroReport{} }</span>
func (m *MicroReport) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MicroReport) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MicroReport) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_c39350954f878191, []int{0}
}</span>
func (m *MicroReport) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MicroReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MicroReport.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MicroReport) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MicroReport.Merge(m, src)
}</span>
func (m *MicroReport) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MicroReport) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MicroReport.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MicroReport proto.InternalMessageInfo

func (m *MicroReport) GetReporter() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Reporter
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MicroReport) GetPower() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Power
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *MicroReport) GetQueryType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MicroReport) GetQueryId() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryId
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *MicroReport) GetAggregateMethod() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AggregateMethod
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MicroReport) GetValue() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Value
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MicroReport) GetTimestamp() time.Time <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Timestamp
        }</span>
        <span class="cov0" title="0">return time.Time{}</span>
}

func (m *MicroReport) GetCyclelist() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Cyclelist
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *MicroReport) GetBlockNumber() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BlockNumber
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*MicroReport)(nil), "layer.oracle.MicroReport")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/oracle/micro_report.proto", fileDescriptor_c39350954f878191) }</span>

var fileDescriptor_c39350954f878191 = []byte{
        // 364 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x44, 0x91, 0xb1, 0x6e, 0xdb, 0x30,
        0x10, 0x86, 0x45, 0xbb, 0xb6, 0x25, 0xda, 0x40, 0x0b, 0xc2, 0x03, 0x2b, 0xb4, 0x92, 0xda, 0x49,
        0x1e, 0x2a, 0x01, 0xed, 0x1b, 0xb8, 0x53, 0x06, 0x67, 0x10, 0x3c, 0x65, 0x11, 0x24, 0xf9, 0x42,
        0x0b, 0xa1, 0x42, 0x85, 0xa6, 0x92, 0xe8, 0x2d, 0xfc, 0x46, 0x59, 0x3d, 0x7a, 0xcc, 0x94, 0x04,
        0xf6, 0x8b, 0x04, 0x22, 0x61, 0x7b, 0xd3, 0xff, 0xdd, 0x7f, 0x77, 0xfa, 0x79, 0xd8, 0xe7, 0x59,
        0x0b, 0x32, 0x16, 0x32, 0x2b, 0x38, 0xc4, 0x55, 0x59, 0x48, 0x91, 0x4a, 0xa8, 0x85, 0x54, 0x51,
        0x2d, 0x85, 0x12, 0x64, 0xa2, 0x0d, 0x91, 0x31, 0xb8, 0x53, 0x26, 0x98, 0xd0, 0x85, 0xb8, 0xfb,
        0x32, 0x1e, 0xd7, 0x67, 0x42, 0x30, 0x0e, 0xb1, 0x56, 0x79, 0x73, 0x1b, 0xab, 0xb2, 0x82, 0x8d,
        0xca, 0xaa, 0xda, 0x18, 0x7e, 0xbf, 0xf4, 0xf0, 0x78, 0xd1, 0xcd, 0x4e, 0xf4, 0x68, 0xe2, 0x62,
        0xdb, 0x2c, 0x01, 0x49, 0x51, 0x80, 0x42, 0x27, 0x39, 0x6b, 0x32, 0xc5, 0x83, 0x5a, 0x3c, 0x81,
        0xa4, 0xbd, 0x00, 0x85, 0xfd, 0xc4, 0x08, 0xf2, 0x13, 0xe3, 0x87, 0x06, 0x64, 0x9b, 0xaa, 0xb6,
        0x06, 0xda, 0xd7, 0x3d, 0x8e, 0x26, 0xcb, 0xb6, 0x06, 0xf2, 0x1d, 0xdb, 0xa6, 0x5c, 0xae, 0xe8,
        0x97, 0x00, 0x85, 0x93, 0x64, 0xa4, 0xf5, 0xd5, 0x8a, 0xcc, 0xf0, 0xb7, 0x8c, 0x31, 0x09, 0x2c,
        0x53, 0x90, 0x56, 0xa0, 0xd6, 0x62, 0x45, 0x07, 0xba, 0xff, 0xeb, 0x99, 0x2f, 0x34, 0xee, 0x56,
        0x3f, 0x66, 0xbc, 0x01, 0x3a, 0xd4, 0x75, 0x23, 0xc8, 0x1c, 0x3b, 0xe7, 0x3c, 0x74, 0x14, 0xa0,
        0x70, 0xfc, 0xd7, 0x8d, 0x4c, 0xe2, 0xe8, 0x94, 0x38, 0x5a, 0x9e, 0x1c, 0x73, 0x7b, 0xf7, 0xe6,
        0x5b, 0xdb, 0x77, 0x1f, 0x25, 0x97, 0x36, 0xf2, 0x03, 0x3b, 0x45, 0x5b, 0x70, 0xe0, 0xe5, 0x46,
        0x51, 0x3b, 0x40, 0xa1, 0x9d, 0x5c, 0x00, 0xf9, 0x85, 0x27, 0x39, 0x17, 0xc5, 0x5d, 0x7a, 0xdf,
        0x54, 0x39, 0x48, 0xea, 0xe8, 0xe4, 0x63, 0xcd, 0xae, 0x35, 0x9a, 0xff, 0xdf, 0x1d, 0x3c, 0xb4,
        0x3f, 0x78, 0xe8, 0xe3, 0xe0, 0xa1, 0xed, 0xd1, 0xb3, 0xf6, 0x47, 0xcf, 0x7a, 0x3d, 0x7a, 0xd6,
        0xcd, 0x8c, 0x95, 0x6a, 0xdd, 0xe4, 0x51, 0x21, 0xaa, 0x58, 0x01, 0xe7, 0x42, 0xfe, 0x29, 0x45,
        0x6c, 0xce, 0xfa, 0x7c, 0x3a, 0x6c, 0xf7, 0x6a, 0x9b, 0x7c, 0xa8, 0x7f, 0xf7, 0xdf, 0x67, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xfd, 0x3f, 0xc3, 0x21, 0xf5, 0x01, 0x00, 0x00,
}

func (m *MicroReport) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MicroReport) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MicroReport) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.BlockNumber != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMicroReport(dAtA, i, uint64(m.BlockNumber))
                i--
                dAtA[i] = 0x48
        }</span>
        <span class="cov0" title="0">if m.Cyclelist </span><span class="cov0" title="0">{
                i--
                if m.Cyclelist </span><span class="cov0" title="0">{
                        dAtA[i] = 1
                }</span> else<span class="cov0" title="0"> {
                        dAtA[i] = 0
                }</span>
                <span class="cov0" title="0">i--
                dAtA[i] = 0x40</span>
        }
        <span class="cov0" title="0">n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
        if err1 != nil </span><span class="cov0" title="0">{
                return 0, err1
        }</span>
        <span class="cov0" title="0">i -= n1
        i = encodeVarintMicroReport(dAtA, i, uint64(n1))
        i--
        dAtA[i] = 0x3a
        if len(m.Value) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Value)
                copy(dAtA[i:], m.Value)
                i = encodeVarintMicroReport(dAtA, i, uint64(len(m.Value)))
                i--
                dAtA[i] = 0x32
        }</span>
        <span class="cov0" title="0">if len(m.AggregateMethod) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.AggregateMethod)
                copy(dAtA[i:], m.AggregateMethod)
                i = encodeVarintMicroReport(dAtA, i, uint64(len(m.AggregateMethod)))
                i--
                dAtA[i] = 0x2a
        }</span>
        <span class="cov0" title="0">if len(m.QueryId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryId)
                copy(dAtA[i:], m.QueryId)
                i = encodeVarintMicroReport(dAtA, i, uint64(len(m.QueryId)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov0" title="0">if len(m.QueryType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryType)
                copy(dAtA[i:], m.QueryType)
                i = encodeVarintMicroReport(dAtA, i, uint64(len(m.QueryType)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if m.Power != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMicroReport(dAtA, i, uint64(m.Power))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.Reporter) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Reporter)
                copy(dAtA[i:], m.Reporter)
                i = encodeVarintMicroReport(dAtA, i, uint64(len(m.Reporter)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintMicroReport(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovMicroReport(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *MicroReport) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Reporter)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMicroReport(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Power != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMicroReport(uint64(m.Power))
        }</span>
        <span class="cov0" title="0">l = len(m.QueryType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMicroReport(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.QueryId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMicroReport(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.AggregateMethod)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMicroReport(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Value)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMicroReport(uint64(l))
        }</span>
        <span class="cov0" title="0">l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
        n += 1 + l + sovMicroReport(uint64(l))
        if m.Cyclelist </span><span class="cov0" title="0">{
                n += 2
        }</span>
        <span class="cov0" title="0">if m.BlockNumber != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMicroReport(uint64(m.BlockNumber))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovMicroReport(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozMicroReport(x uint64) (n int) <span class="cov0" title="0">{
        return sovMicroReport(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *MicroReport) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMicroReport
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MicroReport: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MicroReport: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMicroReport
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMicroReport
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMicroReport
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Reporter = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Power = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMicroReport
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Power |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMicroReport
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMicroReport
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMicroReport
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMicroReport
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMicroReport
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMicroReport
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryId = append(m.QueryId[:0], dAtA[iNdEx:postIndex]...)
                        if m.QueryId == nil </span><span class="cov0" title="0">{
                                m.QueryId = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 5:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AggregateMethod", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMicroReport
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMicroReport
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMicroReport
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.AggregateMethod = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 6:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMicroReport
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMicroReport
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMicroReport
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Value = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 7:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMicroReport
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMicroReport
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMicroReport
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&amp;m.Timestamp, dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 8:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Cyclelist", wireType)
                        }</span>
                        <span class="cov0" title="0">var v int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMicroReport
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                v |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">m.Cyclelist = bool(v != 0)</span>
                case 9:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
                        }</span>
                        <span class="cov0" title="0">m.BlockNumber = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMicroReport
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.BlockNumber |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMicroReport(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMicroReport
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipMicroReport(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowMicroReport
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowMicroReport
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowMicroReport
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthMicroReport
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupMicroReport
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthMicroReport
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthMicroReport        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowMicroReport          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupMicroReport = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file118" style="display: none">package types

import (
        errorsmod "cosmossdk.io/errors"
        sdk "github.com/cosmos/cosmos-sdk/types"
)

var _ sdk.Msg = &amp;MsgUpdateParams{}

// ValidateBasic does a sanity check on the provided data.
func (m *MsgUpdateParams) ValidateBasic() error <span class="cov0" title="0">{
        if _, err := sdk.AccAddressFromBech32(m.Authority); err != nil </span><span class="cov0" title="0">{
                return errorsmod.Wrap(err, "invalid authority address")
        }</span>

        <span class="cov0" title="0">if err := m.Params.Validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (msg *MsgUpdateParams) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        creator, err := sdk.AccAddressFromBech32(msg.Authority)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return []sdk.AccAddress{creator}</span>
}

func (msg *MsgUpdateParams) GetSignBytes() []byte <span class="cov0" title="0">{
        bz := ModuleCdc.MustMarshalJSON(msg)
        return sdk.MustSortJSON(bz)
}</span>
</pre>
		
		<pre class="file" id="file119" style="display: none">package types

import (
        "fmt"

        "cosmossdk.io/math"
        paramtypes "github.com/cosmos/cosmos-sdk/x/params/types"
        "gopkg.in/yaml.v2"
)

var _ paramtypes.ParamSet = (*Params)(nil)

var (
        KeyMinStakeAmount = []byte("MinStakeAmount")
        // TODO: Determine the default value
        DefaultMinStakeAmount = math.NewInt(1_000_000) // one TRB
)

// ParamKeyTable the param key table for launch module
func ParamKeyTable() paramtypes.KeyTable <span class="cov0" title="0">{
        return paramtypes.NewKeyTable().RegisterParamSet(&amp;Params{})
}</span>

// NewParams creates a new Params instance
func NewParams(minStakeAmount math.Int) Params <span class="cov8" title="1">{
        return Params{
                MinStakeAmount: minStakeAmount,
        }
}</span>

// DefaultParams returns a default set of parameters
func DefaultParams() Params <span class="cov8" title="1">{
        return NewParams(DefaultMinStakeAmount)
}</span>

// ParamSetPairs get the params.ParamSet
func (p *Params) ParamSetPairs() paramtypes.ParamSetPairs <span class="cov0" title="0">{
        return paramtypes.ParamSetPairs{
                paramtypes.NewParamSetPair(KeyMinStakeAmount, &amp;p.MinStakeAmount, validateMinStakeAmount),
        }
}</span>

// Validate validates the set of params
func (p Params) Validate() error <span class="cov8" title="1">{
        return nil
}</span>

// String implements the Stringer interface.
func (p Params) String() string <span class="cov0" title="0">{
        out, _ := yaml.Marshal(p)
        return string(out)
}</span>

// validateMinStakeAmount validates the MinStakeAmount param
func validateMinStakeAmount(v interface{}) error <span class="cov0" title="0">{
        _, ok := v.(math.Int)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid parameter type: %T", v)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/oracle/params.proto

package types

import (
        cosmossdk_io_math "cosmossdk.io/math"
        fmt "fmt"
        _ "github.com/cosmos/cosmos-proto"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines the parameters for the module.
type Params struct {
        MinStakeAmount cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=minStakeAmount,proto3,customtype=cosmossdk.io/math.Int" json:"minStakeAmount" yaml:"min_stake_amount"`
}

func (m *Params) Reset()      <span class="cov0" title="0">{ *m = Params{} }</span>
func (*Params) ProtoMessage() {<span class="cov0" title="0">}</span>
func (*Params) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_ac0e3bcb871977fd, []int{0}
}</span>
func (m *Params) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Params.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Params) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Params.Merge(m, src)
}</span>
func (m *Params) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Params) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Params.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Params proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Params)(nil), "layer.oracle.Params")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/oracle/params.proto", fileDescriptor_ac0e3bcb871977fd) }</span>

var fileDescriptor_ac0e3bcb871977fd = []byte{
        // 251 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0xcc, 0x49, 0xac, 0x4c,
        0x2d, 0xd2, 0xcf, 0x2f, 0x4a, 0x4c, 0xce, 0x49, 0xd5, 0x2f, 0x48, 0x2c, 0x4a, 0xcc, 0x2d, 0xd6,
        0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x01, 0x4b, 0xe9, 0x41, 0xa4, 0xa4, 0x24, 0x93, 0xf3,
        0x8b, 0x73, 0xf3, 0x8b, 0xe3, 0xc1, 0x72, 0xfa, 0x10, 0x0e, 0x44, 0xa1, 0x94, 0x48, 0x7a, 0x7e,
        0x7a, 0x3e, 0x44, 0x1c, 0xc4, 0x82, 0x88, 0x2a, 0xd5, 0x71, 0xb1, 0x05, 0x80, 0x8d, 0x13, 0xca,
        0xe3, 0xe2, 0xcb, 0xcd, 0xcc, 0x0b, 0x2e, 0x49, 0xcc, 0x4e, 0x75, 0xcc, 0xcd, 0x2f, 0xcd, 0x2b,
        0x91, 0x60, 0x54, 0x60, 0xd4, 0xe0, 0x74, 0x72, 0x3b, 0x71, 0x4f, 0x9e, 0xe1, 0xd6, 0x3d, 0x79,
        0x51, 0x88, 0x69, 0xc5, 0x29, 0xd9, 0x7a, 0x99, 0xf9, 0xfa, 0xb9, 0x89, 0x25, 0x19, 0x7a, 0x9e,
        0x79, 0x25, 0x9f, 0xee, 0xc9, 0x8b, 0x57, 0x26, 0xe6, 0xe6, 0x58, 0x29, 0xe5, 0x66, 0xe6, 0xc5,
        0x17, 0x83, 0x74, 0xc7, 0x27, 0x82, 0xb5, 0x2b, 0x5d, 0xda, 0xa2, 0xcb, 0x05, 0x75, 0x81, 0x67,
        0x5e, 0x49, 0x10, 0x9a, 0xe9, 0x56, 0x2c, 0x33, 0x16, 0xc8, 0x33, 0x38, 0x39, 0x9f, 0x78, 0x24,
        0xc7, 0x78, 0xe1, 0x91, 0x1c, 0xe3, 0x83, 0x47, 0x72, 0x8c, 0x13, 0x1e, 0xcb, 0x31, 0x5c, 0x78,
        0x2c, 0xc7, 0x70, 0xe3, 0xb1, 0x1c, 0x43, 0x94, 0x66, 0x7a, 0x66, 0x49, 0x46, 0x69, 0x92, 0x5e,
        0x72, 0x7e, 0xae, 0x7e, 0x49, 0x6a, 0x4e, 0x4e, 0x7e, 0x91, 0x6e, 0x66, 0xbe, 0x3e, 0x24, 0x20,
        0x2a, 0x60, 0x41, 0x51, 0x52, 0x59, 0x90, 0x5a, 0x9c, 0xc4, 0x06, 0xf6, 0x8b, 0x31, 0x20, 0x00,
        0x00, 0xff, 0xff, 0x56, 0x75, 0x93, 0x84, 0x27, 0x01, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size := m.MinStakeAmount.Size()
                i -= size
                if _, err := m.MinStakeAmount.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintParams(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func encodeVarintParams(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovParams(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Params) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.MinStakeAmount.Size()
        n += 1 + l + sovParams(uint64(l))
        return n</span>
}

func sovParams(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozParams(x uint64) (n int) <span class="cov0" title="0">{
        return sovParams(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Params) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Params: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MinStakeAmount", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.MinStakeAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipParams(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipParams(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupParams
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthParams
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthParams        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowParams          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupParams = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file121" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/oracle/query.proto

package types

import (
        context "context"
        fmt "fmt"
        types "github.com/cosmos/cosmos-sdk/types"
        _ "github.com/cosmos/cosmos-sdk/types/query"
        _ "github.com/cosmos/cosmos-sdk/types/tx/amino"
        _ "github.com/cosmos/gogoproto/gogoproto"
        grpc1 "github.com/cosmos/gogoproto/grpc"
        proto "github.com/cosmos/gogoproto/proto"
        _ "google.golang.org/genproto/googleapis/api/annotations"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QueryParamsRequest is request type for the Query/Params RPC method.
type QueryParamsRequest struct {
}

func (m *QueryParamsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryParamsRequest{} }</span>
func (m *QueryParamsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryParamsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryParamsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bb27caa9d264c5c4, []int{0}
}</span>
func (m *QueryParamsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryParamsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryParamsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsRequest.Merge(m, src)
}</span>
func (m *QueryParamsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryParamsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryParamsRequest proto.InternalMessageInfo

// QueryParamsResponse is response type for the Query/Params RPC method.
type QueryParamsResponse struct {
        // params holds all the parameters of this module.
        Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
}

func (m *QueryParamsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryParamsResponse{} }</span>
func (m *QueryParamsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryParamsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryParamsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bb27caa9d264c5c4, []int{1}
}</span>
func (m *QueryParamsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryParamsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryParamsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsResponse.Merge(m, src)
}</span>
func (m *QueryParamsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryParamsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryParamsResponse proto.InternalMessageInfo

func (m *QueryParamsResponse) GetParams() Params <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Params
        }</span>
        <span class="cov0" title="0">return Params{}</span>
}

type QueryGetReportsbyQidRequest struct {
        QueryId []byte `protobuf:"bytes,1,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
}

func (m *QueryGetReportsbyQidRequest) Reset()         <span class="cov0" title="0">{ *m = QueryGetReportsbyQidRequest{} }</span>
func (m *QueryGetReportsbyQidRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetReportsbyQidRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetReportsbyQidRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bb27caa9d264c5c4, []int{2}
}</span>
func (m *QueryGetReportsbyQidRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetReportsbyQidRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetReportsbyQidRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetReportsbyQidRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetReportsbyQidRequest.Merge(m, src)
}</span>
func (m *QueryGetReportsbyQidRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetReportsbyQidRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetReportsbyQidRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetReportsbyQidRequest proto.InternalMessageInfo

func (m *QueryGetReportsbyQidRequest) GetQueryId() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryId
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type QueryGetReportsbyQidResponse struct {
        Reports Reports `protobuf:"bytes,1,opt,name=reports,proto3" json:"reports"`
}

func (m *QueryGetReportsbyQidResponse) Reset()         <span class="cov0" title="0">{ *m = QueryGetReportsbyQidResponse{} }</span>
func (m *QueryGetReportsbyQidResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetReportsbyQidResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetReportsbyQidResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bb27caa9d264c5c4, []int{3}
}</span>
func (m *QueryGetReportsbyQidResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetReportsbyQidResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetReportsbyQidResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetReportsbyQidResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetReportsbyQidResponse.Merge(m, src)
}</span>
func (m *QueryGetReportsbyQidResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetReportsbyQidResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetReportsbyQidResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetReportsbyQidResponse proto.InternalMessageInfo

func (m *QueryGetReportsbyQidResponse) GetReports() Reports <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Reports
        }</span>
        <span class="cov0" title="0">return Reports{}</span>
}

type QueryGetReportsbyReporterRequest struct {
        Reporter string `protobuf:"bytes,1,opt,name=reporter,proto3" json:"reporter,omitempty"`
}

func (m *QueryGetReportsbyReporterRequest) Reset()         <span class="cov0" title="0">{ *m = QueryGetReportsbyReporterRequest{} }</span>
func (m *QueryGetReportsbyReporterRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetReportsbyReporterRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetReportsbyReporterRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bb27caa9d264c5c4, []int{4}
}</span>
func (m *QueryGetReportsbyReporterRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetReportsbyReporterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetReportsbyReporterRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetReportsbyReporterRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetReportsbyReporterRequest.Merge(m, src)
}</span>
func (m *QueryGetReportsbyReporterRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetReportsbyReporterRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetReportsbyReporterRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetReportsbyReporterRequest proto.InternalMessageInfo

func (m *QueryGetReportsbyReporterRequest) GetReporter() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Reporter
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type QueryGetReportsbyReporterResponse struct {
        MicroReports []MicroReport `protobuf:"bytes,1,rep,name=microReports,proto3" json:"microReports"`
}

func (m *QueryGetReportsbyReporterResponse) Reset()         <span class="cov0" title="0">{ *m = QueryGetReportsbyReporterResponse{} }</span>
func (m *QueryGetReportsbyReporterResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetReportsbyReporterResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetReportsbyReporterResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bb27caa9d264c5c4, []int{5}
}</span>
func (m *QueryGetReportsbyReporterResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetReportsbyReporterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetReportsbyReporterResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetReportsbyReporterResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetReportsbyReporterResponse.Merge(m, src)
}</span>
func (m *QueryGetReportsbyReporterResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetReportsbyReporterResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetReportsbyReporterResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetReportsbyReporterResponse proto.InternalMessageInfo

func (m *QueryGetReportsbyReporterResponse) GetMicroReports() []MicroReport <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MicroReports
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type QueryGetReportsbyReporterQidRequest struct {
        Reporter string `protobuf:"bytes,1,opt,name=reporter,proto3" json:"reporter,omitempty"`
        QueryId  []byte `protobuf:"bytes,2,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
}

func (m *QueryGetReportsbyReporterQidRequest) Reset()         <span class="cov0" title="0">{ *m = QueryGetReportsbyReporterQidRequest{} }</span>
func (m *QueryGetReportsbyReporterQidRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetReportsbyReporterQidRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetReportsbyReporterQidRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bb27caa9d264c5c4, []int{6}
}</span>
func (m *QueryGetReportsbyReporterQidRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetReportsbyReporterQidRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetReportsbyReporterQidRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetReportsbyReporterQidRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetReportsbyReporterQidRequest.Merge(m, src)
}</span>
func (m *QueryGetReportsbyReporterQidRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetReportsbyReporterQidRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetReportsbyReporterQidRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetReportsbyReporterQidRequest proto.InternalMessageInfo

func (m *QueryGetReportsbyReporterQidRequest) GetReporter() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Reporter
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *QueryGetReportsbyReporterQidRequest) GetQueryId() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryId
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type QueryGetCurrentTipRequest struct {
        QueryData []byte `protobuf:"bytes,1,opt,name=query_data,json=queryData,proto3" json:"query_data,omitempty"`
}

func (m *QueryGetCurrentTipRequest) Reset()         <span class="cov0" title="0">{ *m = QueryGetCurrentTipRequest{} }</span>
func (m *QueryGetCurrentTipRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetCurrentTipRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetCurrentTipRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bb27caa9d264c5c4, []int{7}
}</span>
func (m *QueryGetCurrentTipRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetCurrentTipRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetCurrentTipRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetCurrentTipRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetCurrentTipRequest.Merge(m, src)
}</span>
func (m *QueryGetCurrentTipRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetCurrentTipRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetCurrentTipRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetCurrentTipRequest proto.InternalMessageInfo

func (m *QueryGetCurrentTipRequest) GetQueryData() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryData
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type QueryGetCurrentTipResponse struct {
        Tips *Tips `protobuf:"bytes,1,opt,name=tips,proto3" json:"tips,omitempty"`
}

func (m *QueryGetCurrentTipResponse) Reset()         <span class="cov0" title="0">{ *m = QueryGetCurrentTipResponse{} }</span>
func (m *QueryGetCurrentTipResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetCurrentTipResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetCurrentTipResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bb27caa9d264c5c4, []int{8}
}</span>
func (m *QueryGetCurrentTipResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetCurrentTipResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetCurrentTipResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetCurrentTipResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetCurrentTipResponse.Merge(m, src)
}</span>
func (m *QueryGetCurrentTipResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetCurrentTipResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetCurrentTipResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetCurrentTipResponse proto.InternalMessageInfo

func (m *QueryGetCurrentTipResponse) GetTips() *Tips <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tips
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type QueryGetUserTipTotalRequest struct {
        Tipper    string `protobuf:"bytes,1,opt,name=tipper,proto3" json:"tipper,omitempty"`
        QueryData []byte `protobuf:"bytes,2,opt,name=query_data,json=queryData,proto3" json:"query_data,omitempty"`
}

func (m *QueryGetUserTipTotalRequest) Reset()         <span class="cov0" title="0">{ *m = QueryGetUserTipTotalRequest{} }</span>
func (m *QueryGetUserTipTotalRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetUserTipTotalRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetUserTipTotalRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bb27caa9d264c5c4, []int{9}
}</span>
func (m *QueryGetUserTipTotalRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetUserTipTotalRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetUserTipTotalRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetUserTipTotalRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetUserTipTotalRequest.Merge(m, src)
}</span>
func (m *QueryGetUserTipTotalRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetUserTipTotalRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetUserTipTotalRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetUserTipTotalRequest proto.InternalMessageInfo

func (m *QueryGetUserTipTotalRequest) GetTipper() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tipper
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *QueryGetUserTipTotalRequest) GetQueryData() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryData
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type QueryGetUserTipTotalResponse struct {
        TotalTips *UserTipTotal `protobuf:"bytes,1,opt,name=totalTips,proto3" json:"totalTips,omitempty"`
}

func (m *QueryGetUserTipTotalResponse) Reset()         <span class="cov0" title="0">{ *m = QueryGetUserTipTotalResponse{} }</span>
func (m *QueryGetUserTipTotalResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetUserTipTotalResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetUserTipTotalResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bb27caa9d264c5c4, []int{10}
}</span>
func (m *QueryGetUserTipTotalResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetUserTipTotalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetUserTipTotalResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetUserTipTotalResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetUserTipTotalResponse.Merge(m, src)
}</span>
func (m *QueryGetUserTipTotalResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetUserTipTotalResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetUserTipTotalResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetUserTipTotalResponse proto.InternalMessageInfo

func (m *QueryGetUserTipTotalResponse) GetTotalTips() *UserTipTotal <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TotalTips
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type QueryGetCurrentAggregatedReportRequest struct {
        QueryId []byte `protobuf:"bytes,1,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
}

func (m *QueryGetCurrentAggregatedReportRequest) Reset() <span class="cov0" title="0">{
        *m = QueryGetCurrentAggregatedReportRequest{}
}</span>
func (m *QueryGetCurrentAggregatedReportRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetCurrentAggregatedReportRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetCurrentAggregatedReportRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bb27caa9d264c5c4, []int{11}
}</span>
func (m *QueryGetCurrentAggregatedReportRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetCurrentAggregatedReportRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetCurrentAggregatedReportRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetCurrentAggregatedReportRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetCurrentAggregatedReportRequest.Merge(m, src)
}</span>
func (m *QueryGetCurrentAggregatedReportRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetCurrentAggregatedReportRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetCurrentAggregatedReportRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetCurrentAggregatedReportRequest proto.InternalMessageInfo

func (m *QueryGetCurrentAggregatedReportRequest) GetQueryId() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryId
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type QueryGetAggregatedReportResponse struct {
        Report *Aggregate `protobuf:"bytes,1,opt,name=report,proto3" json:"report,omitempty"`
}

func (m *QueryGetAggregatedReportResponse) Reset()         <span class="cov0" title="0">{ *m = QueryGetAggregatedReportResponse{} }</span>
func (m *QueryGetAggregatedReportResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetAggregatedReportResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetAggregatedReportResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bb27caa9d264c5c4, []int{12}
}</span>
func (m *QueryGetAggregatedReportResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetAggregatedReportResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetAggregatedReportResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetAggregatedReportResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetAggregatedReportResponse.Merge(m, src)
}</span>
func (m *QueryGetAggregatedReportResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetAggregatedReportResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetAggregatedReportResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetAggregatedReportResponse proto.InternalMessageInfo

func (m *QueryGetAggregatedReportResponse) GetReport() *Aggregate <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Report
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type QueryGetDataBeforeRequest struct {
        QueryId   []byte `protobuf:"bytes,1,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
        Timestamp int64  `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *QueryGetDataBeforeRequest) Reset()         <span class="cov0" title="0">{ *m = QueryGetDataBeforeRequest{} }</span>
func (m *QueryGetDataBeforeRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetDataBeforeRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetDataBeforeRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bb27caa9d264c5c4, []int{13}
}</span>
func (m *QueryGetDataBeforeRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetDataBeforeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetDataBeforeRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetDataBeforeRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetDataBeforeRequest.Merge(m, src)
}</span>
func (m *QueryGetDataBeforeRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetDataBeforeRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetDataBeforeRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetDataBeforeRequest proto.InternalMessageInfo

func (m *QueryGetDataBeforeRequest) GetQueryId() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryId
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *QueryGetDataBeforeRequest) GetTimestamp() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Timestamp
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type QueryGetTimeBasedRewardsRequest struct {
}

func (m *QueryGetTimeBasedRewardsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryGetTimeBasedRewardsRequest{} }</span>
func (m *QueryGetTimeBasedRewardsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetTimeBasedRewardsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetTimeBasedRewardsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bb27caa9d264c5c4, []int{14}
}</span>
func (m *QueryGetTimeBasedRewardsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetTimeBasedRewardsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetTimeBasedRewardsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetTimeBasedRewardsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetTimeBasedRewardsRequest.Merge(m, src)
}</span>
func (m *QueryGetTimeBasedRewardsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetTimeBasedRewardsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetTimeBasedRewardsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetTimeBasedRewardsRequest proto.InternalMessageInfo

type QueryGetTimeBasedRewardsResponse struct {
        Reward types.Coin `protobuf:"bytes,1,opt,name=reward,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coin" json:"reward"`
}

func (m *QueryGetTimeBasedRewardsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryGetTimeBasedRewardsResponse{} }</span>
func (m *QueryGetTimeBasedRewardsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetTimeBasedRewardsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetTimeBasedRewardsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bb27caa9d264c5c4, []int{15}
}</span>
func (m *QueryGetTimeBasedRewardsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetTimeBasedRewardsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetTimeBasedRewardsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetTimeBasedRewardsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetTimeBasedRewardsResponse.Merge(m, src)
}</span>
func (m *QueryGetTimeBasedRewardsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetTimeBasedRewardsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetTimeBasedRewardsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetTimeBasedRewardsResponse proto.InternalMessageInfo

func (m *QueryGetTimeBasedRewardsResponse) GetReward() types.Coin <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Reward
        }</span>
        <span class="cov0" title="0">return types.Coin{}</span>
}

type QueryCurrentCyclelistQueryRequest struct {
}

func (m *QueryCurrentCyclelistQueryRequest) Reset()         <span class="cov0" title="0">{ *m = QueryCurrentCyclelistQueryRequest{} }</span>
func (m *QueryCurrentCyclelistQueryRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryCurrentCyclelistQueryRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryCurrentCyclelistQueryRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bb27caa9d264c5c4, []int{16}
}</span>
func (m *QueryCurrentCyclelistQueryRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryCurrentCyclelistQueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryCurrentCyclelistQueryRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryCurrentCyclelistQueryRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryCurrentCyclelistQueryRequest.Merge(m, src)
}</span>
func (m *QueryCurrentCyclelistQueryRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryCurrentCyclelistQueryRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryCurrentCyclelistQueryRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryCurrentCyclelistQueryRequest proto.InternalMessageInfo

type QueryCurrentCyclelistQueryResponse struct {
        QueryData []byte `protobuf:"bytes,1,opt,name=query_data,json=queryData,proto3" json:"query_data,omitempty"`
}

func (m *QueryCurrentCyclelistQueryResponse) Reset()         <span class="cov0" title="0">{ *m = QueryCurrentCyclelistQueryResponse{} }</span>
func (m *QueryCurrentCyclelistQueryResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryCurrentCyclelistQueryResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryCurrentCyclelistQueryResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bb27caa9d264c5c4, []int{17}
}</span>
func (m *QueryCurrentCyclelistQueryResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryCurrentCyclelistQueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryCurrentCyclelistQueryResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryCurrentCyclelistQueryResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryCurrentCyclelistQueryResponse.Merge(m, src)
}</span>
func (m *QueryCurrentCyclelistQueryResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryCurrentCyclelistQueryResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryCurrentCyclelistQueryResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryCurrentCyclelistQueryResponse proto.InternalMessageInfo

func (m *QueryCurrentCyclelistQueryResponse) GetQueryData() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryData
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*QueryParamsRequest)(nil), "layer.oracle.QueryParamsRequest")
        proto.RegisterType((*QueryParamsResponse)(nil), "layer.oracle.QueryParamsResponse")
        proto.RegisterType((*QueryGetReportsbyQidRequest)(nil), "layer.oracle.QueryGetReportsbyQidRequest")
        proto.RegisterType((*QueryGetReportsbyQidResponse)(nil), "layer.oracle.QueryGetReportsbyQidResponse")
        proto.RegisterType((*QueryGetReportsbyReporterRequest)(nil), "layer.oracle.QueryGetReportsbyReporterRequest")
        proto.RegisterType((*QueryGetReportsbyReporterResponse)(nil), "layer.oracle.QueryGetReportsbyReporterResponse")
        proto.RegisterType((*QueryGetReportsbyReporterQidRequest)(nil), "layer.oracle.QueryGetReportsbyReporterQidRequest")
        proto.RegisterType((*QueryGetCurrentTipRequest)(nil), "layer.oracle.QueryGetCurrentTipRequest")
        proto.RegisterType((*QueryGetCurrentTipResponse)(nil), "layer.oracle.QueryGetCurrentTipResponse")
        proto.RegisterType((*QueryGetUserTipTotalRequest)(nil), "layer.oracle.QueryGetUserTipTotalRequest")
        proto.RegisterType((*QueryGetUserTipTotalResponse)(nil), "layer.oracle.QueryGetUserTipTotalResponse")
        proto.RegisterType((*QueryGetCurrentAggregatedReportRequest)(nil), "layer.oracle.QueryGetCurrentAggregatedReportRequest")
        proto.RegisterType((*QueryGetAggregatedReportResponse)(nil), "layer.oracle.QueryGetAggregatedReportResponse")
        proto.RegisterType((*QueryGetDataBeforeRequest)(nil), "layer.oracle.QueryGetDataBeforeRequest")
        proto.RegisterType((*QueryGetTimeBasedRewardsRequest)(nil), "layer.oracle.QueryGetTimeBasedRewardsRequest")
        proto.RegisterType((*QueryGetTimeBasedRewardsResponse)(nil), "layer.oracle.QueryGetTimeBasedRewardsResponse")
        proto.RegisterType((*QueryCurrentCyclelistQueryRequest)(nil), "layer.oracle.QueryCurrentCyclelistQueryRequest")
        proto.RegisterType((*QueryCurrentCyclelistQueryResponse)(nil), "layer.oracle.QueryCurrentCyclelistQueryResponse")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/oracle/query.proto", fileDescriptor_bb27caa9d264c5c4) }</span>

var fileDescriptor_bb27caa9d264c5c4 = []byte{
        // 1106 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x97, 0xcf, 0x6f, 0x1b, 0xc5,
        0x17, 0xc0, 0xb3, 0x69, 0xbf, 0x69, 0x33, 0x4d, 0xf5, 0x15, 0xd3, 0xb4, 0xa9, 0xb7, 0xc1, 0x49,
        0xb6, 0x52, 0x9b, 0x46, 0x64, 0xb7, 0x31, 0xa1, 0x44, 0x55, 0x15, 0x05, 0x3b, 0x02, 0x7a, 0x40,
        0xa2, 0x8b, 0x2b, 0x21, 0x84, 0x64, 0x8d, 0xed, 0x61, 0x3b, 0xaa, 0xed, 0xd9, 0xec, 0x8e, 0x01,
        0x2b, 0xf2, 0x85, 0x2b, 0x17, 0x24, 0xae, 0x1c, 0x38, 0x22, 0x84, 0x50, 0x05, 0x07, 0x4e, 0x48,
        0x1c, 0x7b, 0xac, 0xc4, 0x85, 0x13, 0xa0, 0x04, 0x89, 0x7f, 0x03, 0xed, 0xcc, 0x1b, 0xaf, 0xc7,
        0xde, 0xdd, 0x18, 0x2e, 0xc9, 0xee, 0xbc, 0x1f, 0xf3, 0x79, 0x6f, 0xde, 0xbc, 0xb7, 0x46, 0xd7,
        0x3b, 0x64, 0x40, 0x23, 0x8f, 0x47, 0xa4, 0xd5, 0xa1, 0xde, 0x51, 0x9f, 0x46, 0x03, 0x37, 0x8c,
        0xb8, 0xe0, 0x78, 0x49, 0x4a, 0x5c, 0x25, 0xb1, 0x97, 0x03, 0x1e, 0x70, 0x29, 0xf0, 0x92, 0x27,
        0xa5, 0x63, 0xaf, 0x06, 0x9c, 0x07, 0x1d, 0xea, 0x91, 0x90, 0x79, 0xa4, 0xd7, 0xe3, 0x82, 0x08,
        0xc6, 0x7b, 0x31, 0x48, 0xb7, 0x5a, 0x3c, 0xee, 0xf2, 0xd8, 0x6b, 0x92, 0x18, 0x5c, 0x7b, 0x1f,
        0xef, 0x34, 0xa9, 0x20, 0x3b, 0x5e, 0x48, 0x02, 0xd6, 0x93, 0xca, 0xa0, 0x5b, 0x32, 0x38, 0x42,
        0x12, 0x91, 0xae, 0x76, 0x63, 0x1b, 0xa2, 0x88, 0x86, 0x3c, 0x12, 0x5a, 0xb6, 0x66, 0xc8, 0xba,
        0xac, 0x15, 0xf1, 0x86, 0xd2, 0x00, 0x85, 0x15, 0x43, 0x41, 0xb0, 0x50, 0x5b, 0xde, 0x30, 0x04,
        0xfd, 0x98, 0x46, 0x0d, 0xc1, 0x42, 0x1d, 0x97, 0x21, 0x24, 0x41, 0x10, 0xd1, 0x80, 0x08, 0x0a,
        0xd2, 0x97, 0x48, 0x97, 0xf5, 0xb8, 0x27, 0xff, 0xc2, 0x52, 0x79, 0x3c, 0x54, 0x1d, 0x64, 0x8b,
        0x33, 0x08, 0xcf, 0x59, 0x46, 0xf8, 0x51, 0x92, 0x80, 0x77, 0x65, 0x60, 0x3e, 0x3d, 0xea, 0xd3,
        0x58, 0x38, 0x0f, 0xd1, 0x15, 0x63, 0x35, 0x0e, 0x79, 0x2f, 0xa6, 0xb8, 0x82, 0x16, 0x54, 0x02,
        0xae, 0x5b, 0xeb, 0xd6, 0xe6, 0xa5, 0xca, 0xb2, 0x3b, 0x7e, 0x14, 0xae, 0xd2, 0xae, 0x9e, 0x7f,
        0xfe, 0xfb, 0xda, 0x9c, 0x0f, 0x9a, 0xce, 0x1e, 0xba, 0x21, 0x5d, 0xbd, 0x45, 0x85, 0xaf, 0x32,
        0xd4, 0x1c, 0x3c, 0x62, 0x6d, 0xd8, 0x09, 0x97, 0xd0, 0x45, 0x79, 0x00, 0x0d, 0xd6, 0x96, 0x4e,
        0x97, 0xfc, 0x0b, 0xf2, 0xfd, 0x61, 0xdb, 0x79, 0x8c, 0x56, 0xb3, 0x2d, 0x81, 0xe6, 0x35, 0x74,
        0x01, 0x72, 0x0e, 0x38, 0x57, 0x4d, 0x1c, 0x30, 0x02, 0x1e, 0xad, 0xeb, 0xec, 0xa3, 0xf5, 0x29,
        0xb7, 0xea, 0x81, 0x46, 0x9a, 0xca, 0x46, 0x17, 0x23, 0x58, 0x92, 0xbe, 0x17, 0xfd, 0xd1, 0xbb,
        0xf3, 0x04, 0x6d, 0x14, 0xd8, 0x03, 0x5b, 0x0d, 0x2d, 0xc9, 0x33, 0xf7, 0x47, 0x80, 0xe7, 0x36,
        0x2f, 0x55, 0x4a, 0x26, 0xe0, 0x3b, 0xa9, 0x06, 0x40, 0x1a, 0x46, 0xce, 0x87, 0xe8, 0x66, 0xee,
        0x4e, 0x63, 0x29, 0x2c, 0x80, 0x35, 0xd2, 0x3b, 0x6f, 0xa6, 0xf7, 0x3e, 0x2a, 0x69, 0xef, 0xb5,
        0x7e, 0x14, 0xd1, 0x9e, 0xa8, 0xb3, 0x50, 0xfb, 0x7c, 0x19, 0x21, 0x65, 0xd7, 0x26, 0x82, 0xc0,
        0xc1, 0x2c, 0xca, 0x95, 0x43, 0x22, 0x88, 0x73, 0x88, 0xec, 0x2c, 0x5b, 0x08, 0xfe, 0x16, 0x3a,
        0x9f, 0xd4, 0x33, 0x9c, 0x0a, 0x36, 0x83, 0xae, 0xb3, 0x30, 0xf6, 0xa5, 0xdc, 0xa9, 0xa7, 0xa5,
        0xf1, 0x38, 0xa6, 0x51, 0x9d, 0x85, 0x75, 0x2e, 0x48, 0x47, 0x33, 0x5c, 0x43, 0x0b, 0x82, 0x85,
        0xe1, 0x28, 0x2a, 0x78, 0x9b, 0x60, 0x9b, 0x9f, 0x64, 0x7b, 0x3f, 0x2d, 0x1b, 0xd3, 0x2b, 0xd0,
        0xed, 0xa1, 0x45, 0x91, 0x2c, 0xd4, 0x53, 0x44, 0xdb, 0x44, 0x34, 0xcc, 0x52, 0x65, 0xa7, 0x86,
        0x6e, 0x4d, 0x44, 0xfd, 0x86, 0xbe, 0x80, 0x6d, 0x75, 0x2e, 0x33, 0x54, 0xf5, 0x7b, 0x69, 0xf9,
        0x4d, 0x5b, 0x03, 0xa2, 0x87, 0x16, 0xd4, 0x09, 0x02, 0xdf, 0x8a, 0xc9, 0x37, 0xb2, 0xf3, 0x41,
        0xcd, 0xa9, 0xa7, 0x67, 0x99, 0xe4, 0xa0, 0x4a, 0x3f, 0xe2, 0x11, 0x3d, 0x1b, 0x06, 0xaf, 0xa2,
        0x45, 0xc1, 0xba, 0x34, 0x16, 0xa4, 0x1b, 0xca, 0x4c, 0x9e, 0xf3, 0xd3, 0x05, 0x67, 0x03, 0xad,
        0x69, 0xaf, 0x75, 0xd6, 0xa5, 0x55, 0x12, 0x27, 0xa4, 0x9f, 0x90, 0xa8, 0x3d, 0x6a, 0x14, 0x9f,
        0x5b, 0x69, 0x38, 0xd3, 0x3a, 0x10, 0x4e, 0x90, 0x84, 0x93, 0x2c, 0x41, 0x38, 0x25, 0x57, 0x35,
        0x25, 0x37, 0x69, 0x4a, 0x2e, 0x34, 0x25, 0xb7, 0xc6, 0x59, 0xaf, 0xba, 0x9b, 0x5c, 0x83, 0x6f,
        0xff, 0x58, 0xbb, 0x1d, 0x30, 0xf1, 0xa4, 0xdf, 0x74, 0x5b, 0xbc, 0xeb, 0x41, 0x07, 0x53, 0xff,
        0xb6, 0xe3, 0xf6, 0x53, 0x4f, 0x0c, 0x42, 0x1a, 0x4b, 0x83, 0x6f, 0xfe, 0x7e, 0xb6, 0x65, 0xf9,
        0xe0, 0xde, 0xb9, 0x09, 0x57, 0x13, 0x4e, 0xa7, 0x36, 0x68, 0x75, 0x68, 0x87, 0xc5, 0x42, 0x2e,
        0x6a, 0xe4, 0x1a, 0x72, 0x8a, 0x94, 0x80, 0xb9, 0xf8, 0x02, 0x54, 0x7e, 0xba, 0x8c, 0xfe, 0x27,
        0x0d, 0xf0, 0x53, 0xb4, 0xa0, 0xfa, 0x1e, 0x5e, 0x37, 0x4f, 0x69, 0xba, 0xad, 0xda, 0x1b, 0x05,
        0x1a, 0x6a, 0x5f, 0x67, 0xf5, 0xb3, 0x5f, 0xff, 0xfa, 0x72, 0xfe, 0x1a, 0x5e, 0xf6, 0x32, 0xe6,
        0x0e, 0xfe, 0xca, 0x42, 0xff, 0x9f, 0x68, 0x87, 0xf8, 0x4e, 0x86, 0xd3, 0xec, 0x66, 0x6b, 0x6f,
        0xcd, 0xa2, 0x0a, 0x20, 0x15, 0x09, 0xf2, 0x0a, 0xde, 0x32, 0x41, 0x02, 0x2a, 0x60, 0x8e, 0xc5,
        0xcd, 0x41, 0xe3, 0x88, 0xb5, 0xbd, 0x63, 0x5d, 0x5c, 0x43, 0xfc, 0xcc, 0x42, 0xcb, 0x59, 0xcd,
        0x0a, 0xbb, 0x67, 0x6c, 0x3c, 0xd1, 0x7f, 0x6d, 0x6f, 0x66, 0x7d, 0xa0, 0x7d, 0x5d, 0xd2, 0xee,
        0x60, 0xaf, 0x88, 0x56, 0x77, 0x45, 0xef, 0x58, 0x3f, 0x0d, 0xf1, 0x2f, 0x16, 0x5a, 0xc9, 0xe9,
        0xaf, 0x78, 0x67, 0x46, 0x8a, 0xff, 0x98, 0xe1, 0x37, 0x25, 0xf3, 0x01, 0xde, 0x9f, 0x85, 0x59,
        0xa5, 0x7a, 0xc4, 0x3d, 0x9e, 0xf5, 0xaf, 0x2d, 0x74, 0xd9, 0x68, 0xc4, 0xf8, 0x76, 0x36, 0xc5,
        0x54, 0x9b, 0xb7, 0x37, 0xcf, 0x56, 0x04, 0xd8, 0x07, 0x12, 0xf6, 0x1e, 0xde, 0xf5, 0x04, 0xed,
        0x74, 0x78, 0xb4, 0xcd, 0xf8, 0x34, 0x76, 0x4b, 0xd9, 0x25, 0xdf, 0x2b, 0x1a, 0x30, 0xb9, 0x3e,
        0x43, 0xfc, 0x83, 0xaa, 0xdb, 0xf1, 0xc6, 0x9a, 0x57, 0xb7, 0x19, 0x93, 0x20, 0x2f, 0xab, 0x59,
        0xed, 0xdd, 0x79, 0x5b, 0x82, 0x56, 0xf1, 0x41, 0x11, 0xa8, 0xfe, 0xaa, 0x6a, 0xc8, 0xe6, 0xee,
        0x1d, 0xab, 0xc9, 0x32, 0x34, 0xa1, 0x7f, 0xb6, 0xd0, 0x95, 0x8c, 0x2e, 0x8d, 0x77, 0x0b, 0x93,
        0x96, 0x33, 0x12, 0xec, 0x9c, 0x2b, 0x90, 0x37, 0x03, 0x9c, 0x03, 0x19, 0xc7, 0x7d, 0xbc, 0x57,
        0x14, 0xc7, 0xe8, 0x03, 0xb0, 0x0d, 0x85, 0x32, 0x5e, 0x17, 0xdf, 0xab, 0xba, 0x48, 0x07, 0x42,
        0x5e, 0x5d, 0x4c, 0x8d, 0x8c, 0x7f, 0x0d, 0x7b, 0x28, 0x61, 0xf7, 0xf1, 0x83, 0x3c, 0x58, 0x63,
        0x97, 0x31, 0xc8, 0x24, 0xf5, 0x30, 0x6e, 0x86, 0xf8, 0x3b, 0x95, 0xf0, 0xc9, 0x39, 0x82, 0xb7,
        0xb3, 0x69, 0x72, 0x66, 0x52, 0x1e, 0x7c, 0xde, 0x78, 0x72, 0xee, 0x49, 0xf8, 0xbb, 0xd8, 0x2d,
        0xca, 0x74, 0x82, 0xd9, 0x48, 0xe6, 0x55, 0x92, 0x69, 0x85, 0xf5, 0xa3, 0x85, 0xae, 0x66, 0x0e,
        0x11, 0x9c, 0xd5, 0xbe, 0x8a, 0x66, 0x92, 0x7d, 0x77, 0x76, 0x83, 0xa9, 0x86, 0x97, 0x03, 0xad,
        0xef, 0x62, 0x4b, 0xdb, 0x37, 0x64, 0xd2, 0xab, 0xb5, 0xe7, 0x27, 0x65, 0xeb, 0xc5, 0x49, 0xd9,
        0xfa, 0xf3, 0xa4, 0x6c, 0x7d, 0x71, 0x5a, 0x9e, 0x7b, 0x71, 0x5a, 0x9e, 0xfb, 0xed, 0xb4, 0x3c,
        0xf7, 0xc1, 0x9d, 0xb1, 0x99, 0x3b, 0xe9, 0xf4, 0xd3, 0xd1, 0x0f, 0x95, 0x64, 0xf4, 0x36, 0x17,
        0xe4, 0x8f, 0x87, 0x57, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0x61, 0xea, 0x1a, 0x1b, 0xa5, 0x0d,
        0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
        // Parameters queries the parameters of the module.
        Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error)
        // Queries a list of GetReportsbyQid items.
        GetReportsbyQid(ctx context.Context, in *QueryGetReportsbyQidRequest, opts ...grpc.CallOption) (*QueryGetReportsbyQidResponse, error)
        GetReportsbyReporter(ctx context.Context, in *QueryGetReportsbyReporterRequest, opts ...grpc.CallOption) (*QueryGetReportsbyReporterResponse, error)
        GetReportsbyReporterQid(ctx context.Context, in *QueryGetReportsbyReporterQidRequest, opts ...grpc.CallOption) (*QueryGetReportsbyQidResponse, error)
        // Queries a list of GetCurrentTip items.
        GetCurrentTip(ctx context.Context, in *QueryGetCurrentTipRequest, opts ...grpc.CallOption) (*QueryGetCurrentTipResponse, error)
        // Queries a list of GetUserTipTotal items.
        GetUserTipTotal(ctx context.Context, in *QueryGetUserTipTotalRequest, opts ...grpc.CallOption) (*QueryGetUserTipTotalResponse, error)
        // Queries a list of GetAggregatedReport items.
        GetAggregatedReport(ctx context.Context, in *QueryGetCurrentAggregatedReportRequest, opts ...grpc.CallOption) (*QueryGetAggregatedReportResponse, error)
        // Queries a list of GetAggregatedReport items.
        GetDataBefore(ctx context.Context, in *QueryGetDataBeforeRequest, opts ...grpc.CallOption) (*QueryGetAggregatedReportResponse, error)
        // Queries a list of GetTimeBasedRewards items.
        GetTimeBasedRewards(ctx context.Context, in *QueryGetTimeBasedRewardsRequest, opts ...grpc.CallOption) (*QueryGetTimeBasedRewardsResponse, error)
        // Queries a list of CurrentCyclelistQuery items.
        CurrentCyclelistQuery(ctx context.Context, in *QueryCurrentCyclelistQueryRequest, opts ...grpc.CallOption) (*QueryCurrentCyclelistQueryResponse, error)
}

type queryClient struct {
        cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient <span class="cov0" title="0">{
        return &amp;queryClient{cc}
}</span>

func (c *queryClient) Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error) <span class="cov0" title="0">{
        out := new(QueryParamsResponse)
        err := c.cc.Invoke(ctx, "/layer.oracle.Query/Params", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) GetReportsbyQid(ctx context.Context, in *QueryGetReportsbyQidRequest, opts ...grpc.CallOption) (*QueryGetReportsbyQidResponse, error) <span class="cov0" title="0">{
        out := new(QueryGetReportsbyQidResponse)
        err := c.cc.Invoke(ctx, "/layer.oracle.Query/GetReportsbyQid", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) GetReportsbyReporter(ctx context.Context, in *QueryGetReportsbyReporterRequest, opts ...grpc.CallOption) (*QueryGetReportsbyReporterResponse, error) <span class="cov0" title="0">{
        out := new(QueryGetReportsbyReporterResponse)
        err := c.cc.Invoke(ctx, "/layer.oracle.Query/GetReportsbyReporter", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) GetReportsbyReporterQid(ctx context.Context, in *QueryGetReportsbyReporterQidRequest, opts ...grpc.CallOption) (*QueryGetReportsbyQidResponse, error) <span class="cov0" title="0">{
        out := new(QueryGetReportsbyQidResponse)
        err := c.cc.Invoke(ctx, "/layer.oracle.Query/GetReportsbyReporterQid", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) GetCurrentTip(ctx context.Context, in *QueryGetCurrentTipRequest, opts ...grpc.CallOption) (*QueryGetCurrentTipResponse, error) <span class="cov0" title="0">{
        out := new(QueryGetCurrentTipResponse)
        err := c.cc.Invoke(ctx, "/layer.oracle.Query/GetCurrentTip", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) GetUserTipTotal(ctx context.Context, in *QueryGetUserTipTotalRequest, opts ...grpc.CallOption) (*QueryGetUserTipTotalResponse, error) <span class="cov0" title="0">{
        out := new(QueryGetUserTipTotalResponse)
        err := c.cc.Invoke(ctx, "/layer.oracle.Query/GetUserTipTotal", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) GetAggregatedReport(ctx context.Context, in *QueryGetCurrentAggregatedReportRequest, opts ...grpc.CallOption) (*QueryGetAggregatedReportResponse, error) <span class="cov0" title="0">{
        out := new(QueryGetAggregatedReportResponse)
        err := c.cc.Invoke(ctx, "/layer.oracle.Query/GetAggregatedReport", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) GetDataBefore(ctx context.Context, in *QueryGetDataBeforeRequest, opts ...grpc.CallOption) (*QueryGetAggregatedReportResponse, error) <span class="cov0" title="0">{
        out := new(QueryGetAggregatedReportResponse)
        err := c.cc.Invoke(ctx, "/layer.oracle.Query/GetDataBefore", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) GetTimeBasedRewards(ctx context.Context, in *QueryGetTimeBasedRewardsRequest, opts ...grpc.CallOption) (*QueryGetTimeBasedRewardsResponse, error) <span class="cov0" title="0">{
        out := new(QueryGetTimeBasedRewardsResponse)
        err := c.cc.Invoke(ctx, "/layer.oracle.Query/GetTimeBasedRewards", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) CurrentCyclelistQuery(ctx context.Context, in *QueryCurrentCyclelistQueryRequest, opts ...grpc.CallOption) (*QueryCurrentCyclelistQueryResponse, error) <span class="cov0" title="0">{
        out := new(QueryCurrentCyclelistQueryResponse)
        err := c.cc.Invoke(ctx, "/layer.oracle.Query/CurrentCyclelistQuery", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// QueryServer is the server API for Query service.
type QueryServer interface {
        // Parameters queries the parameters of the module.
        Params(context.Context, *QueryParamsRequest) (*QueryParamsResponse, error)
        // Queries a list of GetReportsbyQid items.
        GetReportsbyQid(context.Context, *QueryGetReportsbyQidRequest) (*QueryGetReportsbyQidResponse, error)
        GetReportsbyReporter(context.Context, *QueryGetReportsbyReporterRequest) (*QueryGetReportsbyReporterResponse, error)
        GetReportsbyReporterQid(context.Context, *QueryGetReportsbyReporterQidRequest) (*QueryGetReportsbyQidResponse, error)
        // Queries a list of GetCurrentTip items.
        GetCurrentTip(context.Context, *QueryGetCurrentTipRequest) (*QueryGetCurrentTipResponse, error)
        // Queries a list of GetUserTipTotal items.
        GetUserTipTotal(context.Context, *QueryGetUserTipTotalRequest) (*QueryGetUserTipTotalResponse, error)
        // Queries a list of GetAggregatedReport items.
        GetAggregatedReport(context.Context, *QueryGetCurrentAggregatedReportRequest) (*QueryGetAggregatedReportResponse, error)
        // Queries a list of GetAggregatedReport items.
        GetDataBefore(context.Context, *QueryGetDataBeforeRequest) (*QueryGetAggregatedReportResponse, error)
        // Queries a list of GetTimeBasedRewards items.
        GetTimeBasedRewards(context.Context, *QueryGetTimeBasedRewardsRequest) (*QueryGetTimeBasedRewardsResponse, error)
        // Queries a list of CurrentCyclelistQuery items.
        CurrentCyclelistQuery(context.Context, *QueryCurrentCyclelistQueryRequest) (*QueryCurrentCyclelistQueryResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) Params(ctx context.Context, req *QueryParamsRequest) (*QueryParamsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Params not implemented")
}</span>
func (*UnimplementedQueryServer) GetReportsbyQid(ctx context.Context, req *QueryGetReportsbyQidRequest) (*QueryGetReportsbyQidResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetReportsbyQid not implemented")
}</span>
func (*UnimplementedQueryServer) GetReportsbyReporter(ctx context.Context, req *QueryGetReportsbyReporterRequest) (*QueryGetReportsbyReporterResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetReportsbyReporter not implemented")
}</span>
func (*UnimplementedQueryServer) GetReportsbyReporterQid(ctx context.Context, req *QueryGetReportsbyReporterQidRequest) (*QueryGetReportsbyQidResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetReportsbyReporterQid not implemented")
}</span>
func (*UnimplementedQueryServer) GetCurrentTip(ctx context.Context, req *QueryGetCurrentTipRequest) (*QueryGetCurrentTipResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetCurrentTip not implemented")
}</span>
func (*UnimplementedQueryServer) GetUserTipTotal(ctx context.Context, req *QueryGetUserTipTotalRequest) (*QueryGetUserTipTotalResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUserTipTotal not implemented")
}</span>
func (*UnimplementedQueryServer) GetAggregatedReport(ctx context.Context, req *QueryGetCurrentAggregatedReportRequest) (*QueryGetAggregatedReportResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetAggregatedReport not implemented")
}</span>
func (*UnimplementedQueryServer) GetDataBefore(ctx context.Context, req *QueryGetDataBeforeRequest) (*QueryGetAggregatedReportResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetDataBefore not implemented")
}</span>
func (*UnimplementedQueryServer) GetTimeBasedRewards(ctx context.Context, req *QueryGetTimeBasedRewardsRequest) (*QueryGetTimeBasedRewardsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetTimeBasedRewards not implemented")
}</span>
func (*UnimplementedQueryServer) CurrentCyclelistQuery(ctx context.Context, req *QueryCurrentCyclelistQueryRequest) (*QueryCurrentCyclelistQueryResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CurrentCyclelistQuery not implemented")
}</span>

func RegisterQueryServer(s grpc1.Server, srv QueryServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;_Query_serviceDesc, srv)
}</span>

func _Query_Params_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryParamsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).Params(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.oracle.Query/Params",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).Params(ctx, req.(*QueryParamsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_GetReportsbyQid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryGetReportsbyQidRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetReportsbyQid(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.oracle.Query/GetReportsbyQid",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetReportsbyQid(ctx, req.(*QueryGetReportsbyQidRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_GetReportsbyReporter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryGetReportsbyReporterRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetReportsbyReporter(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.oracle.Query/GetReportsbyReporter",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetReportsbyReporter(ctx, req.(*QueryGetReportsbyReporterRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_GetReportsbyReporterQid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryGetReportsbyReporterQidRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetReportsbyReporterQid(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.oracle.Query/GetReportsbyReporterQid",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetReportsbyReporterQid(ctx, req.(*QueryGetReportsbyReporterQidRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_GetCurrentTip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryGetCurrentTipRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetCurrentTip(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.oracle.Query/GetCurrentTip",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetCurrentTip(ctx, req.(*QueryGetCurrentTipRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_GetUserTipTotal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryGetUserTipTotalRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetUserTipTotal(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.oracle.Query/GetUserTipTotal",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetUserTipTotal(ctx, req.(*QueryGetUserTipTotalRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_GetAggregatedReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryGetCurrentAggregatedReportRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetAggregatedReport(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.oracle.Query/GetAggregatedReport",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetAggregatedReport(ctx, req.(*QueryGetCurrentAggregatedReportRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_GetDataBefore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryGetDataBeforeRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetDataBefore(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.oracle.Query/GetDataBefore",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetDataBefore(ctx, req.(*QueryGetDataBeforeRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_GetTimeBasedRewards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryGetTimeBasedRewardsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetTimeBasedRewards(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.oracle.Query/GetTimeBasedRewards",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetTimeBasedRewards(ctx, req.(*QueryGetTimeBasedRewardsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_CurrentCyclelistQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryCurrentCyclelistQueryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).CurrentCyclelistQuery(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.oracle.Query/CurrentCyclelistQuery",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).CurrentCyclelistQuery(ctx, req.(*QueryCurrentCyclelistQueryRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _Query_serviceDesc = grpc.ServiceDesc{
        ServiceName: "layer.oracle.Query",
        HandlerType: (*QueryServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Params",
                        Handler:    _Query_Params_Handler,
                },
                {
                        MethodName: "GetReportsbyQid",
                        Handler:    _Query_GetReportsbyQid_Handler,
                },
                {
                        MethodName: "GetReportsbyReporter",
                        Handler:    _Query_GetReportsbyReporter_Handler,
                },
                {
                        MethodName: "GetReportsbyReporterQid",
                        Handler:    _Query_GetReportsbyReporterQid_Handler,
                },
                {
                        MethodName: "GetCurrentTip",
                        Handler:    _Query_GetCurrentTip_Handler,
                },
                {
                        MethodName: "GetUserTipTotal",
                        Handler:    _Query_GetUserTipTotal_Handler,
                },
                {
                        MethodName: "GetAggregatedReport",
                        Handler:    _Query_GetAggregatedReport_Handler,
                },
                {
                        MethodName: "GetDataBefore",
                        Handler:    _Query_GetDataBefore_Handler,
                },
                {
                        MethodName: "GetTimeBasedRewards",
                        Handler:    _Query_GetTimeBasedRewards_Handler,
                },
                {
                        MethodName: "CurrentCyclelistQuery",
                        Handler:    _Query_CurrentCyclelistQuery_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "layer/oracle/query.proto",
}

func (m *QueryParamsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryParamsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryParamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *QueryParamsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryParamsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func (m *QueryGetReportsbyQidRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetReportsbyQidRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetReportsbyQidRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.QueryId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryId)
                copy(dAtA[i:], m.QueryId)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.QueryId)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetReportsbyQidResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetReportsbyQidResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetReportsbyQidResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Reports.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func (m *QueryGetReportsbyReporterRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetReportsbyReporterRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetReportsbyReporterRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Reporter) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Reporter)
                copy(dAtA[i:], m.Reporter)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.Reporter)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetReportsbyReporterResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetReportsbyReporterResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetReportsbyReporterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.MicroReports) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.MicroReports) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.MicroReports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetReportsbyReporterQidRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetReportsbyReporterQidRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetReportsbyReporterQidRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.QueryId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryId)
                copy(dAtA[i:], m.QueryId)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.QueryId)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Reporter) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Reporter)
                copy(dAtA[i:], m.Reporter)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.Reporter)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetCurrentTipRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetCurrentTipRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetCurrentTipRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.QueryData) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryData)
                copy(dAtA[i:], m.QueryData)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.QueryData)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetCurrentTipResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetCurrentTipResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetCurrentTipResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Tips != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Tips.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetUserTipTotalRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetUserTipTotalRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetUserTipTotalRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.QueryData) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryData)
                copy(dAtA[i:], m.QueryData)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.QueryData)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Tipper) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Tipper)
                copy(dAtA[i:], m.Tipper)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.Tipper)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetUserTipTotalResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetUserTipTotalResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetUserTipTotalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.TotalTips != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.TotalTips.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetCurrentAggregatedReportRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetCurrentAggregatedReportRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetCurrentAggregatedReportRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.QueryId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryId)
                copy(dAtA[i:], m.QueryId)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.QueryId)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetAggregatedReportResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetAggregatedReportResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetAggregatedReportResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Report != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Report.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetDataBeforeRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetDataBeforeRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetDataBeforeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Timestamp != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.Timestamp))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.QueryId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryId)
                copy(dAtA[i:], m.QueryId)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.QueryId)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetTimeBasedRewardsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetTimeBasedRewardsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetTimeBasedRewardsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *QueryGetTimeBasedRewardsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetTimeBasedRewardsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetTimeBasedRewardsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Reward.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func (m *QueryCurrentCyclelistQueryRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryCurrentCyclelistQueryRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryCurrentCyclelistQueryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *QueryCurrentCyclelistQueryResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryCurrentCyclelistQueryResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryCurrentCyclelistQueryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.QueryData) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryData)
                copy(dAtA[i:], m.QueryData)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.QueryData)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovQuery(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *QueryParamsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *QueryParamsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Params.Size()
        n += 1 + l + sovQuery(uint64(l))
        return n</span>
}

func (m *QueryGetReportsbyQidRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.QueryId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetReportsbyQidResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Reports.Size()
        n += 1 + l + sovQuery(uint64(l))
        return n</span>
}

func (m *QueryGetReportsbyReporterRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Reporter)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetReportsbyReporterResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.MicroReports) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.MicroReports </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovQuery(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetReportsbyReporterQidRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Reporter)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.QueryId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetCurrentTipRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.QueryData)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetCurrentTipResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Tips != nil </span><span class="cov0" title="0">{
                l = m.Tips.Size()
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetUserTipTotalRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Tipper)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.QueryData)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetUserTipTotalResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.TotalTips != nil </span><span class="cov0" title="0">{
                l = m.TotalTips.Size()
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetCurrentAggregatedReportRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.QueryId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetAggregatedReportResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Report != nil </span><span class="cov0" title="0">{
                l = m.Report.Size()
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetDataBeforeRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.QueryId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Timestamp != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.Timestamp))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetTimeBasedRewardsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *QueryGetTimeBasedRewardsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Reward.Size()
        n += 1 + l + sovQuery(uint64(l))
        return n</span>
}

func (m *QueryCurrentCyclelistQueryRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *QueryCurrentCyclelistQueryResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.QueryData)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovQuery(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozQuery(x uint64) (n int) <span class="cov0" title="0">{
        return sovQuery(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *QueryParamsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryParamsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetReportsbyQidRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetReportsbyQidRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetReportsbyQidRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryId = append(m.QueryId[:0], dAtA[iNdEx:postIndex]...)
                        if m.QueryId == nil </span><span class="cov0" title="0">{
                                m.QueryId = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetReportsbyQidResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetReportsbyQidResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetReportsbyQidResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Reports", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Reports.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetReportsbyReporterRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetReportsbyReporterRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetReportsbyReporterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Reporter = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetReportsbyReporterResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetReportsbyReporterResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetReportsbyReporterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MicroReports", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.MicroReports = append(m.MicroReports, MicroReport{})
                        if err := m.MicroReports[len(m.MicroReports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetReportsbyReporterQidRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetReportsbyReporterQidRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetReportsbyReporterQidRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Reporter = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryId = append(m.QueryId[:0], dAtA[iNdEx:postIndex]...)
                        if m.QueryId == nil </span><span class="cov0" title="0">{
                                m.QueryId = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetCurrentTipRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetCurrentTipRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetCurrentTipRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryData", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryData = append(m.QueryData[:0], dAtA[iNdEx:postIndex]...)
                        if m.QueryData == nil </span><span class="cov0" title="0">{
                                m.QueryData = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetCurrentTipResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetCurrentTipResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetCurrentTipResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Tips", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Tips == nil </span><span class="cov0" title="0">{
                                m.Tips = &amp;Tips{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Tips.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetUserTipTotalRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetUserTipTotalRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetUserTipTotalRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Tipper", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Tipper = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryData", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryData = append(m.QueryData[:0], dAtA[iNdEx:postIndex]...)
                        if m.QueryData == nil </span><span class="cov0" title="0">{
                                m.QueryData = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetUserTipTotalResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetUserTipTotalResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetUserTipTotalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field TotalTips", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.TotalTips == nil </span><span class="cov0" title="0">{
                                m.TotalTips = &amp;UserTipTotal{}
                        }</span>
                        <span class="cov0" title="0">if err := m.TotalTips.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetCurrentAggregatedReportRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetCurrentAggregatedReportRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetCurrentAggregatedReportRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryId = append(m.QueryId[:0], dAtA[iNdEx:postIndex]...)
                        if m.QueryId == nil </span><span class="cov0" title="0">{
                                m.QueryId = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetAggregatedReportResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetAggregatedReportResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetAggregatedReportResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Report", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Report == nil </span><span class="cov0" title="0">{
                                m.Report = &amp;Aggregate{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Report.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetDataBeforeRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetDataBeforeRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetDataBeforeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryId = append(m.QueryId[:0], dAtA[iNdEx:postIndex]...)
                        if m.QueryId == nil </span><span class="cov0" title="0">{
                                m.QueryId = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Timestamp = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Timestamp |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetTimeBasedRewardsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetTimeBasedRewardsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetTimeBasedRewardsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetTimeBasedRewardsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetTimeBasedRewardsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetTimeBasedRewardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Reward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryCurrentCyclelistQueryRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryCurrentCyclelistQueryRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryCurrentCyclelistQueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryCurrentCyclelistQueryResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryCurrentCyclelistQueryResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryCurrentCyclelistQueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryData", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryData = append(m.QueryData[:0], dAtA[iNdEx:postIndex]...)
                        if m.QueryData == nil </span><span class="cov0" title="0">{
                                m.QueryData = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipQuery(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupQuery
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthQuery
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file122" style="display: none">// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: layer/oracle/query.proto

/*
Package types is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package types

import (
        "context"
        "io"
        "net/http"

        "github.com/golang/protobuf/descriptor"
        "github.com/golang/protobuf/proto"
        "github.com/grpc-ecosystem/grpc-gateway/runtime"
        "github.com/grpc-ecosystem/grpc-gateway/utilities"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/grpclog"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// Suppress "imported and not used" errors
var _ codes.Code
var _ io.Reader
var _ status.Status
var _ = runtime.String
var _ = utilities.NewDoubleArray
var _ = descriptor.ForMessage
var _ = metadata.Join

func request_Query_Params_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryParamsRequest
        var metadata runtime.ServerMetadata

        msg, err := client.Params(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err

}</span>

func local_request_Query_Params_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryParamsRequest
        var metadata runtime.ServerMetadata

        msg, err := server.Params(ctx, &amp;protoReq)
        return msg, metadata, err

}</span>

func request_Query_GetReportsbyQid_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetReportsbyQidRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["query_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "query_id")
        }</span>

        <span class="cov0" title="0">protoReq.QueryId, err = runtime.Bytes(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "query_id", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.GetReportsbyQid(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_GetReportsbyQid_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetReportsbyQidRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["query_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "query_id")
        }</span>

        <span class="cov0" title="0">protoReq.QueryId, err = runtime.Bytes(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "query_id", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.GetReportsbyQid(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_GetReportsbyReporter_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetReportsbyReporterRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["reporter"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "reporter")
        }</span>

        <span class="cov0" title="0">protoReq.Reporter, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "reporter", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.GetReportsbyReporter(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_GetReportsbyReporter_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetReportsbyReporterRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["reporter"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "reporter")
        }</span>

        <span class="cov0" title="0">protoReq.Reporter, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "reporter", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.GetReportsbyReporter(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_GetReportsbyReporterQid_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetReportsbyReporterQidRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["reporter"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "reporter")
        }</span>

        <span class="cov0" title="0">protoReq.Reporter, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "reporter", err)
        }</span>

        <span class="cov0" title="0">val, ok = pathParams["query_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "query_id")
        }</span>

        <span class="cov0" title="0">protoReq.QueryId, err = runtime.Bytes(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "query_id", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.GetReportsbyReporterQid(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_GetReportsbyReporterQid_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetReportsbyReporterQidRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["reporter"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "reporter")
        }</span>

        <span class="cov0" title="0">protoReq.Reporter, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "reporter", err)
        }</span>

        <span class="cov0" title="0">val, ok = pathParams["query_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "query_id")
        }</span>

        <span class="cov0" title="0">protoReq.QueryId, err = runtime.Bytes(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "query_id", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.GetReportsbyReporterQid(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_GetCurrentTip_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetCurrentTipRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["query_data"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "query_data")
        }</span>

        <span class="cov0" title="0">protoReq.QueryData, err = runtime.Bytes(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "query_data", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.GetCurrentTip(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_GetCurrentTip_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetCurrentTipRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["query_data"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "query_data")
        }</span>

        <span class="cov0" title="0">protoReq.QueryData, err = runtime.Bytes(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "query_data", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.GetCurrentTip(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_GetUserTipTotal_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetUserTipTotalRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["tipper"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "tipper")
        }</span>

        <span class="cov0" title="0">protoReq.Tipper, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "tipper", err)
        }</span>

        <span class="cov0" title="0">val, ok = pathParams["query_data"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "query_data")
        }</span>

        <span class="cov0" title="0">protoReq.QueryData, err = runtime.Bytes(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "query_data", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.GetUserTipTotal(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_GetUserTipTotal_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetUserTipTotalRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["tipper"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "tipper")
        }</span>

        <span class="cov0" title="0">protoReq.Tipper, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "tipper", err)
        }</span>

        <span class="cov0" title="0">val, ok = pathParams["query_data"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "query_data")
        }</span>

        <span class="cov0" title="0">protoReq.QueryData, err = runtime.Bytes(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "query_data", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.GetUserTipTotal(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_GetAggregatedReport_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetCurrentAggregatedReportRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["query_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "query_id")
        }</span>

        <span class="cov0" title="0">protoReq.QueryId, err = runtime.Bytes(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "query_id", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.GetAggregatedReport(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_GetAggregatedReport_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetCurrentAggregatedReportRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["query_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "query_id")
        }</span>

        <span class="cov0" title="0">protoReq.QueryId, err = runtime.Bytes(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "query_id", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.GetAggregatedReport(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_GetDataBefore_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetDataBeforeRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["query_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "query_id")
        }</span>

        <span class="cov0" title="0">protoReq.QueryId, err = runtime.Bytes(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "query_id", err)
        }</span>

        <span class="cov0" title="0">val, ok = pathParams["timestamp"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "timestamp")
        }</span>

        <span class="cov0" title="0">protoReq.Timestamp, err = runtime.Int64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "timestamp", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.GetDataBefore(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_GetDataBefore_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetDataBeforeRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["query_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "query_id")
        }</span>

        <span class="cov0" title="0">protoReq.QueryId, err = runtime.Bytes(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "query_id", err)
        }</span>

        <span class="cov0" title="0">val, ok = pathParams["timestamp"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "timestamp")
        }</span>

        <span class="cov0" title="0">protoReq.Timestamp, err = runtime.Int64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "timestamp", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.GetDataBefore(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_GetTimeBasedRewards_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetTimeBasedRewardsRequest
        var metadata runtime.ServerMetadata

        msg, err := client.GetTimeBasedRewards(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err

}</span>

func local_request_Query_GetTimeBasedRewards_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetTimeBasedRewardsRequest
        var metadata runtime.ServerMetadata

        msg, err := server.GetTimeBasedRewards(ctx, &amp;protoReq)
        return msg, metadata, err

}</span>

func request_Query_CurrentCyclelistQuery_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryCurrentCyclelistQueryRequest
        var metadata runtime.ServerMetadata

        msg, err := client.CurrentCyclelistQuery(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err

}</span>

func local_request_Query_CurrentCyclelistQuery_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryCurrentCyclelistQueryRequest
        var metadata runtime.ServerMetadata

        msg, err := server.CurrentCyclelistQuery(ctx, &amp;protoReq)
        return msg, metadata, err

}</span>

// RegisterQueryHandlerServer registers the http handlers for service Query to "mux".
// UnaryRPC     :call QueryServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterQueryHandlerFromEndpoint instead.
func RegisterQueryHandlerServer(ctx context.Context, mux *runtime.ServeMux, server QueryServer) error <span class="cov0" title="0">{

        mux.Handle("GET", pattern_Query_Params_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_Params_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_Params_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetReportsbyQid_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_GetReportsbyQid_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetReportsbyQid_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetReportsbyReporter_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_GetReportsbyReporter_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetReportsbyReporter_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetReportsbyReporterQid_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_GetReportsbyReporterQid_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetReportsbyReporterQid_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetCurrentTip_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_GetCurrentTip_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetCurrentTip_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetUserTipTotal_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_GetUserTipTotal_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetUserTipTotal_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetAggregatedReport_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_GetAggregatedReport_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetAggregatedReport_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetDataBefore_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_GetDataBefore_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetDataBefore_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetTimeBasedRewards_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_GetTimeBasedRewards_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetTimeBasedRewards_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_CurrentCyclelistQuery_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_CurrentCyclelistQuery_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_CurrentCyclelistQuery_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

// RegisterQueryHandlerFromEndpoint is same as RegisterQueryHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterQueryHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) <span class="cov0" title="0">{
        conn, err := grpc.Dial(endpoint, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                }()
        }()

        <span class="cov0" title="0">return RegisterQueryHandler(ctx, mux, conn)</span>
}

// RegisterQueryHandler registers the http handlers for service Query to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterQueryHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error <span class="cov0" title="0">{
        return RegisterQueryHandlerClient(ctx, mux, NewQueryClient(conn))
}</span>

// RegisterQueryHandlerClient registers the http handlers for service Query
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "QueryClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "QueryClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "QueryClient" to call the correct interceptors.
func RegisterQueryHandlerClient(ctx context.Context, mux *runtime.ServeMux, client QueryClient) error <span class="cov0" title="0">{

        mux.Handle("GET", pattern_Query_Params_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_Params_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_Params_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetReportsbyQid_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_GetReportsbyQid_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetReportsbyQid_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetReportsbyReporter_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_GetReportsbyReporter_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetReportsbyReporter_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetReportsbyReporterQid_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_GetReportsbyReporterQid_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetReportsbyReporterQid_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetCurrentTip_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_GetCurrentTip_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetCurrentTip_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetUserTipTotal_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_GetUserTipTotal_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetUserTipTotal_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetAggregatedReport_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_GetAggregatedReport_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetAggregatedReport_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetDataBefore_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_GetDataBefore_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetDataBefore_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetTimeBasedRewards_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_GetTimeBasedRewards_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetTimeBasedRewards_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_CurrentCyclelistQuery_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_CurrentCyclelistQuery_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_CurrentCyclelistQuery_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

var (
        pattern_Query_Params_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"layer", "oracle", "params"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_GetReportsbyQid_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"layer", "oracle", "get_reportsby_qid", "query_id"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_GetReportsbyReporter_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"layer", "oracle", "get_reportsby_reporter", "reporter"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_GetReportsbyReporterQid_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 1, 0, 4, 1, 5, 4}, []string{"layer", "oracle", "get_reportsby_reporter_qid", "reporter", "query_id"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_GetCurrentTip_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3, 1, 0, 4, 1, 5, 4}, []string{"tellor-io", "layer", "oracle", "get_current_tip", "query_data"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_GetUserTipTotal_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3, 1, 0, 4, 1, 5, 4, 1, 0, 4, 1, 5, 5}, []string{"tellor-io", "layer", "oracle", "get_user_tip_total", "tipper", "query_data"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_GetAggregatedReport_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3, 1, 0, 4, 1, 5, 4}, []string{"tellor-io", "layer", "oracle", "get_aggregated_report", "query_id"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_GetDataBefore_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3, 1, 0, 4, 1, 5, 4, 1, 0, 4, 1, 5, 5}, []string{"tellor-io", "layer", "oracle", "GetDataBefore", "query_id", "timestamp"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_GetTimeBasedRewards_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"tellor-io", "layer", "oracle", "get_time_based_rewards"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_CurrentCyclelistQuery_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"tellor-io", "layer", "oracle", "current_cyclelist_query"}, "", runtime.AssumeColonVerbOpt(false)))
)

var (
        forward_Query_Params_0 = runtime.ForwardResponseMessage

        forward_Query_GetReportsbyQid_0 = runtime.ForwardResponseMessage

        forward_Query_GetReportsbyReporter_0 = runtime.ForwardResponseMessage

        forward_Query_GetReportsbyReporterQid_0 = runtime.ForwardResponseMessage

        forward_Query_GetCurrentTip_0 = runtime.ForwardResponseMessage

        forward_Query_GetUserTipTotal_0 = runtime.ForwardResponseMessage

        forward_Query_GetAggregatedReport_0 = runtime.ForwardResponseMessage

        forward_Query_GetDataBefore_0 = runtime.ForwardResponseMessage

        forward_Query_GetTimeBasedRewards_0 = runtime.ForwardResponseMessage

        forward_Query_CurrentCyclelistQuery_0 = runtime.ForwardResponseMessage
)
</pre>
		
		<pre class="file" id="file123" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/oracle/query_id_timestamp_pair.proto

package types

import (
        fmt "fmt"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type QueryIdTimestampPair struct {
        QueryId   []byte `protobuf:"bytes,1,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
        Timestamp int64  `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *QueryIdTimestampPair) Reset()         <span class="cov0" title="0">{ *m = QueryIdTimestampPair{} }</span>
func (m *QueryIdTimestampPair) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryIdTimestampPair) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryIdTimestampPair) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bb8bf6d5c3138e5d, []int{0}
}</span>
func (m *QueryIdTimestampPair) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryIdTimestampPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryIdTimestampPair.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryIdTimestampPair) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryIdTimestampPair.Merge(m, src)
}</span>
func (m *QueryIdTimestampPair) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryIdTimestampPair) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryIdTimestampPair.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryIdTimestampPair proto.InternalMessageInfo

func (m *QueryIdTimestampPair) GetQueryId() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryId
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *QueryIdTimestampPair) GetTimestamp() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Timestamp
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type QueryIdTimestampPairsArray struct {
        Pairs []*QueryIdTimestampPair `protobuf:"bytes,1,rep,name=pairs,proto3" json:"pairs,omitempty"`
}

func (m *QueryIdTimestampPairsArray) Reset()         <span class="cov0" title="0">{ *m = QueryIdTimestampPairsArray{} }</span>
func (m *QueryIdTimestampPairsArray) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryIdTimestampPairsArray) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryIdTimestampPairsArray) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bb8bf6d5c3138e5d, []int{1}
}</span>
func (m *QueryIdTimestampPairsArray) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryIdTimestampPairsArray) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryIdTimestampPairsArray.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryIdTimestampPairsArray) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryIdTimestampPairsArray.Merge(m, src)
}</span>
func (m *QueryIdTimestampPairsArray) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryIdTimestampPairsArray) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryIdTimestampPairsArray.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryIdTimestampPairsArray proto.InternalMessageInfo

func (m *QueryIdTimestampPairsArray) GetPairs() []*QueryIdTimestampPair <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Pairs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*QueryIdTimestampPair)(nil), "layer.oracle.QueryIdTimestampPair")
        proto.RegisterType((*QueryIdTimestampPairsArray)(nil), "layer.oracle.QueryIdTimestampPairsArray")
}</span>

func init() <span class="cov8" title="1">{
        proto.RegisterFile("layer/oracle/query_id_timestamp_pair.proto", fileDescriptor_bb8bf6d5c3138e5d)
}</span>

var fileDescriptor_bb8bf6d5c3138e5d = []byte{
        // 227 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xd2, 0xca, 0x49, 0xac, 0x4c,
        0x2d, 0xd2, 0xcf, 0x2f, 0x4a, 0x4c, 0xce, 0x49, 0xd5, 0x2f, 0x2c, 0x4d, 0x2d, 0xaa, 0x8c, 0xcf,
        0x4c, 0x89, 0x2f, 0xc9, 0xcc, 0x4d, 0x2d, 0x2e, 0x49, 0xcc, 0x2d, 0x88, 0x2f, 0x48, 0xcc, 0x2c,
        0xd2, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x01, 0xab, 0xd5, 0x83, 0xa8, 0x55, 0xf2, 0xe7,
        0x12, 0x09, 0x04, 0x29, 0xf7, 0x4c, 0x09, 0x81, 0x29, 0x0e, 0x48, 0xcc, 0x2c, 0x12, 0x92, 0xe4,
        0xe2, 0x80, 0x19, 0x23, 0xc1, 0xa8, 0xc0, 0xa8, 0xc1, 0x13, 0xc4, 0x5e, 0x08, 0x51, 0x27, 0x24,
        0xc3, 0xc5, 0x09, 0x37, 0x58, 0x82, 0x49, 0x81, 0x51, 0x83, 0x39, 0x08, 0x21, 0xa0, 0x14, 0xc6,
        0x25, 0x85, 0xcd, 0xc0, 0x62, 0xc7, 0xa2, 0xa2, 0xc4, 0x4a, 0x21, 0x0b, 0x2e, 0x56, 0x90, 0x53,
        0x8a, 0x25, 0x18, 0x15, 0x98, 0x35, 0xb8, 0x8d, 0x94, 0xf4, 0x90, 0x1d, 0xa3, 0x87, 0x4d, 0x63,
        0x10, 0x44, 0x83, 0x93, 0xf3, 0x89, 0x47, 0x72, 0x8c, 0x17, 0x1e, 0xc9, 0x31, 0x3e, 0x78, 0x24,
        0xc7, 0x38, 0xe1, 0xb1, 0x1c, 0xc3, 0x85, 0xc7, 0x72, 0x0c, 0x37, 0x1e, 0xcb, 0x31, 0x44, 0x69,
        0xa6, 0x67, 0x96, 0x64, 0x94, 0x26, 0xe9, 0x25, 0xe7, 0xe7, 0xea, 0x97, 0xa4, 0xe6, 0xe4, 0xe4,
        0x17, 0xe9, 0x66, 0xe6, 0xeb, 0x43, 0x42, 0xa4, 0x02, 0x16, 0x26, 0x25, 0x95, 0x05, 0xa9, 0xc5,
        0x49, 0x6c, 0xe0, 0x20, 0x30, 0x06, 0x04, 0x00, 0x00, 0xff, 0xff, 0x72, 0x28, 0xdd, 0xca, 0x30,
        0x01, 0x00, 0x00,
}

func (m *QueryIdTimestampPair) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryIdTimestampPair) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryIdTimestampPair) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Timestamp != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQueryIdTimestampPair(dAtA, i, uint64(m.Timestamp))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.QueryId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryId)
                copy(dAtA[i:], m.QueryId)
                i = encodeVarintQueryIdTimestampPair(dAtA, i, uint64(len(m.QueryId)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryIdTimestampPairsArray) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryIdTimestampPairsArray) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryIdTimestampPairsArray) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Pairs) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Pairs) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Pairs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintQueryIdTimestampPair(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintQueryIdTimestampPair(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovQueryIdTimestampPair(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *QueryIdTimestampPair) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.QueryId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQueryIdTimestampPair(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Timestamp != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQueryIdTimestampPair(uint64(m.Timestamp))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryIdTimestampPairsArray) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Pairs) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Pairs </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovQueryIdTimestampPair(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func sovQueryIdTimestampPair(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozQueryIdTimestampPair(x uint64) (n int) <span class="cov0" title="0">{
        return sovQueryIdTimestampPair(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *QueryIdTimestampPair) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQueryIdTimestampPair
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryIdTimestampPair: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryIdTimestampPair: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQueryIdTimestampPair
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQueryIdTimestampPair
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQueryIdTimestampPair
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryId = append(m.QueryId[:0], dAtA[iNdEx:postIndex]...)
                        if m.QueryId == nil </span><span class="cov0" title="0">{
                                m.QueryId = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Timestamp = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQueryIdTimestampPair
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Timestamp |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQueryIdTimestampPair(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQueryIdTimestampPair
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryIdTimestampPairsArray) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQueryIdTimestampPair
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryIdTimestampPairsArray: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryIdTimestampPairsArray: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pairs", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQueryIdTimestampPair
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQueryIdTimestampPair
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQueryIdTimestampPair
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Pairs = append(m.Pairs, &amp;QueryIdTimestampPair{})
                        if err := m.Pairs[len(m.Pairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQueryIdTimestampPair(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQueryIdTimestampPair
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipQueryIdTimestampPair(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowQueryIdTimestampPair
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQueryIdTimestampPair
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQueryIdTimestampPair
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthQueryIdTimestampPair
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupQueryIdTimestampPair
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthQueryIdTimestampPair
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthQueryIdTimestampPair        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowQueryIdTimestampPair          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupQueryIdTimestampPair = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file124" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/oracle/query_meta.proto

package types

import (
        cosmossdk_io_math "cosmossdk.io/math"
        fmt "fmt"
        _ "github.com/cosmos/cosmos-proto"
        _ "github.com/cosmos/cosmos-sdk/types/tx/amino"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
        _ "google.golang.org/protobuf/types/known/durationpb"
        _ "google.golang.org/protobuf/types/known/timestamppb"
        io "io"
        math "math"
        math_bits "math/bits"
        time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QueryMeta represents the metadata of a query
type QueryMeta struct {
        // unique id of the query that changes after query's lifecycle ends
        Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        // amount of tokens that was tipped
        Amount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
        // expiration time of the query
        Expiration time.Time `protobuf:"bytes,3,opt,name=expiration,proto3,stdtime" json:"expiration"`
        // timeframe of the query according to the data spec
        RegistrySpecTimeframe time.Duration `protobuf:"bytes,4,opt,name=registry_spec_timeframe,json=registrySpecTimeframe,proto3,stdduration" json:"registry_spec_timeframe"`
        // indicates whether query has revealed reports
        HasRevealedReports bool `protobuf:"varint,5,opt,name=has_revealed_reports,json=hasRevealedReports,proto3" json:"has_revealed_reports,omitempty"`
        // unique id of the query according to the data spec
        QueryId []byte `protobuf:"bytes,6,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
        // string identifier of the data spec
        QueryType string `protobuf:"bytes,7,opt,name=query_type,json=queryType,proto3" json:"query_type,omitempty"`
}

func (m *QueryMeta) Reset()         <span class="cov0" title="0">{ *m = QueryMeta{} }</span>
func (m *QueryMeta) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryMeta) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryMeta) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_072f14e329c22246, []int{0}
}</span>
func (m *QueryMeta) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryMeta.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryMeta) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryMeta.Merge(m, src)
}</span>
func (m *QueryMeta) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryMeta) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryMeta.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryMeta proto.InternalMessageInfo

func (m *QueryMeta) GetId() uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *QueryMeta) GetExpiration() time.Time <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Expiration
        }</span>
        <span class="cov0" title="0">return time.Time{}</span>
}

func (m *QueryMeta) GetRegistrySpecTimeframe() time.Duration <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.RegistrySpecTimeframe
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *QueryMeta) GetHasRevealedReports() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.HasRevealedReports
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *QueryMeta) GetQueryId() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryId
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *QueryMeta) GetQueryType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*QueryMeta)(nil), "layer.oracle.QueryMeta")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/oracle/query_meta.proto", fileDescriptor_072f14e329c22246) }</span>

var fileDescriptor_072f14e329c22246 = []byte{
        // 447 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x92, 0xc1, 0x6e, 0xd3, 0x30,
        0x18, 0xc7, 0xeb, 0x32, 0xba, 0xd6, 0x0c, 0x24, 0xac, 0x4d, 0xa4, 0x95, 0x96, 0x46, 0x9c, 0x02,
        0x68, 0x31, 0x82, 0x37, 0xe8, 0x76, 0xe9, 0x81, 0x03, 0xa6, 0x27, 0x2e, 0xc1, 0x4d, 0xbe, 0xa5,
        0x16, 0x71, 0x1c, 0x6c, 0x07, 0x2d, 0x6f, 0xb1, 0x23, 0x8f, 0xc0, 0x91, 0x03, 0x0f, 0xb1, 0xe3,
        0xc4, 0x09, 0x71, 0xd8, 0x50, 0x7b, 0xe0, 0x05, 0x78, 0x00, 0x94, 0x38, 0x91, 0x10, 0x5c, 0xa2,
        0xfc, 0xbf, 0x9f, 0xfd, 0xcf, 0xff, 0xfb, 0xf2, 0xe1, 0xe3, 0x9c, 0xd7, 0xa0, 0xa9, 0xd2, 0x3c,
        0xc9, 0x81, 0x7e, 0xa8, 0x40, 0xd7, 0xb1, 0x04, 0xcb, 0xa3, 0x52, 0x2b, 0xab, 0xc8, 0x41, 0x8b,
        0x23, 0x87, 0x67, 0x0f, 0xb9, 0x14, 0x85, 0xa2, 0xed, 0xd3, 0x1d, 0x98, 0x4d, 0x13, 0x65, 0xa4,
        0x32, 0x71, 0xab, 0xa8, 0x13, 0x1d, 0x3a, 0xcc, 0x54, 0xa6, 0x5c, 0xbd, 0x79, 0xeb, 0xaa, 0x7e,
        0xa6, 0x54, 0x96, 0x03, 0x6d, 0xd5, 0xba, 0x3a, 0xa7, 0x69, 0xa5, 0xb9, 0x15, 0xaa, 0xe8, 0xf8,
        0xfc, 0x5f, 0x6e, 0x85, 0x04, 0x63, 0xb9, 0x2c, 0xdd, 0x81, 0xc7, 0xbf, 0x87, 0x78, 0xf2, 0xba,
        0xc9, 0xf9, 0x0a, 0x2c, 0x27, 0x0f, 0xf0, 0x50, 0xa4, 0x1e, 0x0a, 0x50, 0xb8, 0xc7, 0x86, 0x22,
        0x25, 0xa7, 0x78, 0xc4, 0xa5, 0xaa, 0x0a, 0xeb, 0x0d, 0x03, 0x14, 0x4e, 0x16, 0xcf, 0xae, 0x6e,
        0xe6, 0x83, 0x1f, 0x37, 0xf3, 0x23, 0x17, 0xcd, 0xa4, 0xef, 0x23, 0xa1, 0xa8, 0xe4, 0x76, 0x13,
        0x2d, 0x0b, 0xfb, 0xed, 0xeb, 0x09, 0xee, 0x32, 0x2f, 0x0b, 0xcb, 0xba, 0xab, 0xe4, 0x0c, 0x63,
        0xb8, 0x28, 0x85, 0xcb, 0xe5, 0xdd, 0x09, 0x50, 0x78, 0xef, 0xc5, 0x2c, 0x72, 0xc1, 0xa2, 0x3e,
        0x58, 0xb4, 0xea, 0x83, 0x2d, 0xc6, 0xcd, 0x47, 0x2e, 0x6f, 0xe7, 0x88, 0xfd, 0x75, 0x8f, 0xbc,
        0xc3, 0x8f, 0x34, 0x64, 0xc2, 0x58, 0x5d, 0xc7, 0xa6, 0x84, 0x24, 0x6e, 0x3a, 0x39, 0xd7, 0x5c,
        0x82, 0xb7, 0xd7, 0x5a, 0x4e, 0xff, 0xb3, 0x3c, 0xeb, 0x66, 0xb1, 0xb8, 0xdf, 0x38, 0x7e, 0xba,
        0x9d, 0xa3, 0xcf, 0xbf, 0xbe, 0x3c, 0x45, 0xec, 0xa8, 0x37, 0x7a, 0x53, 0x42, 0xb2, 0xea, 0x6d,
        0xc8, 0x73, 0x7c, 0xb8, 0xe1, 0x26, 0xd6, 0xf0, 0x11, 0x78, 0x0e, 0x69, 0xac, 0xa1, 0x54, 0xda,
        0x1a, 0xef, 0x6e, 0x80, 0xc2, 0x31, 0x23, 0x1b, 0x6e, 0x58, 0x87, 0x98, 0x23, 0x64, 0x8a, 0xc7,
        0xee, 0x1f, 0x8b, 0xd4, 0x1b, 0x05, 0x28, 0x3c, 0x60, 0xfb, 0xad, 0x5e, 0xa6, 0xe4, 0x18, 0x63,
        0x87, 0x6c, 0x5d, 0x82, 0xb7, 0xdf, 0x4c, 0x8f, 0x4d, 0xda, 0xca, 0xaa, 0x2e, 0x61, 0x71, 0x7a,
        0xb5, 0xf5, 0xd1, 0xf5, 0xd6, 0x47, 0x3f, 0xb7, 0x3e, 0xba, 0xdc, 0xf9, 0x83, 0xeb, 0x9d, 0x3f,
        0xf8, 0xbe, 0xf3, 0x07, 0x6f, 0x9f, 0x64, 0xc2, 0x6e, 0xaa, 0x75, 0x94, 0x28, 0x49, 0x2d, 0xe4,
        0xb9, 0xd2, 0x27, 0x42, 0x51, 0xb7, 0x57, 0x17, 0xfd, 0x66, 0x35, 0xa6, 0x66, 0x3d, 0x6a, 0x3b,
        0x7d, 0xf9, 0x27, 0x00, 0x00, 0xff, 0xff, 0x7e, 0x76, 0x6b, 0x63, 0x76, 0x02, 0x00, 0x00,
}

func (m *QueryMeta) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryMeta) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.QueryType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryType)
                copy(dAtA[i:], m.QueryType)
                i = encodeVarintQueryMeta(dAtA, i, uint64(len(m.QueryType)))
                i--
                dAtA[i] = 0x3a
        }</span>
        <span class="cov0" title="0">if len(m.QueryId) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryId)
                copy(dAtA[i:], m.QueryId)
                i = encodeVarintQueryMeta(dAtA, i, uint64(len(m.QueryId)))
                i--
                dAtA[i] = 0x32
        }</span>
        <span class="cov0" title="0">if m.HasRevealedReports </span><span class="cov0" title="0">{
                i--
                if m.HasRevealedReports </span><span class="cov0" title="0">{
                        dAtA[i] = 1
                }</span> else<span class="cov0" title="0"> {
                        dAtA[i] = 0
                }</span>
                <span class="cov0" title="0">i--
                dAtA[i] = 0x28</span>
        }
        <span class="cov0" title="0">n1, err1 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(m.RegistrySpecTimeframe, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.RegistrySpecTimeframe):])
        if err1 != nil </span><span class="cov0" title="0">{
                return 0, err1
        }</span>
        <span class="cov0" title="0">i -= n1
        i = encodeVarintQueryMeta(dAtA, i, uint64(n1))
        i--
        dAtA[i] = 0x22
        n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Expiration, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Expiration):])
        if err2 != nil </span><span class="cov0" title="0">{
                return 0, err2
        }</span>
        <span class="cov0" title="0">i -= n2
        i = encodeVarintQueryMeta(dAtA, i, uint64(n2))
        i--
        dAtA[i] = 0x1a
        </span><span class="cov0" title="0">{
                size := m.Amount.Size()
                i -= size
                if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintQueryMeta(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x12
        if m.Id != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQueryMeta(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintQueryMeta(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovQueryMeta(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *QueryMeta) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Id != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQueryMeta(uint64(m.Id))
        }</span>
        <span class="cov0" title="0">l = m.Amount.Size()
        n += 1 + l + sovQueryMeta(uint64(l))
        l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Expiration)
        n += 1 + l + sovQueryMeta(uint64(l))
        l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.RegistrySpecTimeframe)
        n += 1 + l + sovQueryMeta(uint64(l))
        if m.HasRevealedReports </span><span class="cov0" title="0">{
                n += 2
        }</span>
        <span class="cov0" title="0">l = len(m.QueryId)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQueryMeta(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.QueryType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQueryMeta(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovQueryMeta(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozQueryMeta(x uint64) (n int) <span class="cov0" title="0">{
        return sovQueryMeta(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *QueryMeta) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQueryMeta
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryMeta: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryMeta: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQueryMeta
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQueryMeta
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQueryMeta
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQueryMeta
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQueryMeta
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQueryMeta
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQueryMeta
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&amp;m.Expiration, dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field RegistrySpecTimeframe", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQueryMeta
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQueryMeta
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQueryMeta
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(&amp;m.RegistrySpecTimeframe, dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 5:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field HasRevealedReports", wireType)
                        }</span>
                        <span class="cov0" title="0">var v int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQueryMeta
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                v |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">m.HasRevealedReports = bool(v != 0)</span>
                case 6:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQueryMeta
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQueryMeta
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQueryMeta
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryId = append(m.QueryId[:0], dAtA[iNdEx:postIndex]...)
                        if m.QueryId == nil </span><span class="cov0" title="0">{
                                m.QueryId = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 7:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQueryMeta
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQueryMeta
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQueryMeta
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQueryMeta(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQueryMeta
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipQueryMeta(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowQueryMeta
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQueryMeta
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQueryMeta
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthQueryMeta
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupQueryMeta
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthQueryMeta
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthQueryMeta        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowQueryMeta          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupQueryMeta = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file125" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/oracle/reports.proto

package types

import (
        fmt "fmt"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Reports struct {
        MicroReports []*MicroReport `protobuf:"bytes,1,rep,name=microReports,proto3" json:"microReports,omitempty"`
}

func (m *Reports) Reset()         <span class="cov0" title="0">{ *m = Reports{} }</span>
func (m *Reports) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Reports) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Reports) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_654245c0746b2b04, []int{0}
}</span>
func (m *Reports) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Reports) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Reports.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Reports) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Reports.Merge(m, src)
}</span>
func (m *Reports) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Reports) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Reports.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Reports proto.InternalMessageInfo

func (m *Reports) GetMicroReports() []*MicroReport <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MicroReports
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Reports)(nil), "layer.oracle.Reports")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/oracle/reports.proto", fileDescriptor_654245c0746b2b04) }</span>

var fileDescriptor_654245c0746b2b04 = []byte{
        // 172 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0xca, 0x49, 0xac, 0x4c,
        0x2d, 0xd2, 0xcf, 0x2f, 0x4a, 0x4c, 0xce, 0x49, 0xd5, 0x2f, 0x4a, 0x2d, 0xc8, 0x2f, 0x2a, 0x29,
        0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x01, 0xcb, 0xe9, 0x41, 0xe4, 0xa4, 0xe4, 0x51,
        0x54, 0xe6, 0x66, 0x26, 0x17, 0xe5, 0xc7, 0x43, 0xd4, 0x43, 0x94, 0x2b, 0x79, 0x70, 0xb1, 0x07,
        0x41, 0xf4, 0x0b, 0xd9, 0x72, 0xf1, 0x80, 0x15, 0x40, 0xf9, 0x12, 0x8c, 0x0a, 0xcc, 0x1a, 0xdc,
        0x46, 0x92, 0x7a, 0xc8, 0x06, 0xea, 0xf9, 0x22, 0x54, 0x04, 0xa1, 0x28, 0x77, 0x72, 0x3e, 0xf1,
        0x48, 0x8e, 0xf1, 0xc2, 0x23, 0x39, 0xc6, 0x07, 0x8f, 0xe4, 0x18, 0x27, 0x3c, 0x96, 0x63, 0xb8,
        0xf0, 0x58, 0x8e, 0xe1, 0xc6, 0x63, 0x39, 0x86, 0x28, 0xcd, 0xf4, 0xcc, 0x92, 0x8c, 0xd2, 0x24,
        0xbd, 0xe4, 0xfc, 0x5c, 0xfd, 0x92, 0xd4, 0x9c, 0x9c, 0xfc, 0x22, 0xdd, 0xcc, 0x7c, 0x7d, 0x88,
        0xcb, 0x2a, 0x60, 0x6e, 0x2b, 0xa9, 0x2c, 0x48, 0x2d, 0x4e, 0x62, 0x03, 0xbb, 0xca, 0x18, 0x10,
        0x00, 0x00, 0xff, 0xff, 0xa6, 0x49, 0x08, 0x1e, 0xe2, 0x00, 0x00, 0x00,
}

func (m *Reports) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Reports) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Reports) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.MicroReports) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.MicroReports) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.MicroReports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintReports(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintReports(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovReports(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Reports) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.MicroReports) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.MicroReports </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovReports(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func sovReports(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozReports(x uint64) (n int) <span class="cov0" title="0">{
        return sovReports(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Reports) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowReports
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Reports: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Reports: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MicroReports", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowReports
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthReports
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthReports
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.MicroReports = append(m.MicroReports, &amp;MicroReport{})
                        if err := m.MicroReports[len(m.MicroReports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipReports(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthReports
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipReports(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowReports
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowReports
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowReports
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthReports
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupReports
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthReports
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthReports        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowReports          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupReports = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file126" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/oracle/tips.proto

package types

import (
        cosmossdk_io_math "cosmossdk.io/math"
        fmt "fmt"
        _ "github.com/cosmos/cosmos-proto"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Tips is a struct that contains the query data and the amount it was tipped
type Tips struct {
        // query_data is the query data that was tipped
        QueryData []byte `protobuf:"bytes,1,opt,name=query_data,json=queryData,proto3" json:"query_data,omitempty"`
        // the amount that was tipped
        Amount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
        // totalTips is the total amount of tips for this query data so far
        TotalTips cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_tips,json=totalTips,proto3,customtype=cosmossdk.io/math.Int" json:"total_tips"`
}

func (m *Tips) Reset()         <span class="cov0" title="0">{ *m = Tips{} }</span>
func (m *Tips) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Tips) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Tips) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_1dd649bc410cbcce, []int{0}
}</span>
func (m *Tips) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Tips) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Tips.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Tips) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Tips.Merge(m, src)
}</span>
func (m *Tips) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Tips) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Tips.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Tips proto.InternalMessageInfo

func (m *Tips) GetQueryData() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryData
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Tips)(nil), "layer.oracle.Tips")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/oracle/tips.proto", fileDescriptor_1dd649bc410cbcce) }</span>

var fileDescriptor_1dd649bc410cbcce = []byte{
        // 264 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0xcf, 0x49, 0xac, 0x4c,
        0x2d, 0xd2, 0xcf, 0x2f, 0x4a, 0x4c, 0xce, 0x49, 0xd5, 0x2f, 0xc9, 0x2c, 0x28, 0xd6, 0x2b, 0x28,
        0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x01, 0x4b, 0xe8, 0x41, 0x24, 0xa4, 0x24, 0x93, 0xf3, 0x8b, 0x73,
        0xf3, 0x8b, 0xe3, 0xc1, 0x72, 0xfa, 0x10, 0x0e, 0x44, 0xa1, 0x94, 0x48, 0x7a, 0x7e, 0x7a, 0x3e,
        0x44, 0x1c, 0xc4, 0x82, 0x88, 0x2a, 0x6d, 0x63, 0xe4, 0x62, 0x09, 0xc9, 0x2c, 0x28, 0x16, 0x92,
        0xe5, 0xe2, 0x2a, 0x2c, 0x4d, 0x2d, 0xaa, 0x8c, 0x4f, 0x49, 0x2c, 0x49, 0x94, 0x60, 0x54, 0x60,
        0xd4, 0xe0, 0x09, 0xe2, 0x04, 0x8b, 0xb8, 0x24, 0x96, 0x24, 0x0a, 0x39, 0x73, 0xb1, 0x25, 0xe6,
        0xe6, 0x97, 0xe6, 0x95, 0x48, 0x30, 0x29, 0x30, 0x6a, 0x70, 0x3a, 0x69, 0x9f, 0xb8, 0x27, 0xcf,
        0x70, 0xeb, 0x9e, 0xbc, 0x28, 0xc4, 0x8e, 0xe2, 0x94, 0x6c, 0xbd, 0xcc, 0x7c, 0xfd, 0xdc, 0xc4,
        0x92, 0x0c, 0x3d, 0xcf, 0xbc, 0x92, 0x4b, 0x5b, 0x74, 0xb9, 0xa0, 0x96, 0x7b, 0xe6, 0x95, 0x04,
        0x41, 0xb5, 0x0a, 0x79, 0x71, 0x71, 0x95, 0xe4, 0x97, 0x24, 0xe6, 0xc4, 0x83, 0xdc, 0x2f, 0xc1,
        0x4c, 0xba, 0x41, 0x9c, 0x60, 0xed, 0x20, 0xf7, 0x3a, 0x39, 0x9f, 0x78, 0x24, 0xc7, 0x78, 0xe1,
        0x91, 0x1c, 0xe3, 0x83, 0x47, 0x72, 0x8c, 0x13, 0x1e, 0xcb, 0x31, 0x5c, 0x78, 0x2c, 0xc7, 0x70,
        0xe3, 0xb1, 0x1c, 0x43, 0x94, 0x66, 0x7a, 0x66, 0x49, 0x46, 0x69, 0x92, 0x5e, 0x72, 0x7e, 0xae,
        0x7e, 0x49, 0x6a, 0x4e, 0x4e, 0x7e, 0x91, 0x6e, 0x66, 0xbe, 0x3e, 0x24, 0xfc, 0x2a, 0xe0, 0x21,
        0x58, 0x59, 0x90, 0x5a, 0x9c, 0xc4, 0x06, 0x0e, 0x04, 0x63, 0x40, 0x00, 0x00, 0x00, 0xff, 0xff,
        0xca, 0x9f, 0x2a, 0xd6, 0x5e, 0x01, 0x00, 0x00,
}

func (m *Tips) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Tips) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Tips) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size := m.TotalTips.Size()
                i -= size
                if _, err := m.TotalTips.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintTips(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x1a
        </span><span class="cov0" title="0">{
                size := m.Amount.Size()
                i -= size
                if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintTips(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x12
        if len(m.QueryData) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryData)
                copy(dAtA[i:], m.QueryData)
                i = encodeVarintTips(dAtA, i, uint64(len(m.QueryData)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintTips(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovTips(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Tips) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.QueryData)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTips(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Amount.Size()
        n += 1 + l + sovTips(uint64(l))
        l = m.TotalTips.Size()
        n += 1 + l + sovTips(uint64(l))
        return n</span>
}

func sovTips(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozTips(x uint64) (n int) <span class="cov0" title="0">{
        return sovTips(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Tips) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTips
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Tips: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Tips: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryData", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTips
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTips
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTips
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryData = append(m.QueryData[:0], dAtA[iNdEx:postIndex]...)
                        if m.QueryData == nil </span><span class="cov0" title="0">{
                                m.QueryData = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTips
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTips
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTips
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field TotalTips", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTips
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTips
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTips
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.TotalTips.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTips(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTips
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipTips(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowTips
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowTips
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowTips
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthTips
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupTips
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthTips
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthTips        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowTips          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupTips = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file127" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/oracle/tx.proto

package types

import (
        context "context"
        fmt "fmt"
        _ "github.com/cosmos/cosmos-proto"
        types "github.com/cosmos/cosmos-sdk/types"
        _ "github.com/cosmos/cosmos-sdk/types/msgservice"
        _ "github.com/cosmos/cosmos-sdk/types/tx/amino"
        _ "github.com/cosmos/gogoproto/gogoproto"
        grpc1 "github.com/cosmos/gogoproto/grpc"
        proto "github.com/cosmos/gogoproto/proto"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgUpdateParams is the Msg/UpdateParams request type.
type MsgUpdateParams struct {
        // authority is the address that controls the module (defaults to x/gov unless overwritten).
        Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
        // params defines the module parameters to update.
        //
        // NOTE: All parameters must be supplied.
        Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateParams) Reset()         <span class="cov0" title="0">{ *m = MsgUpdateParams{} }</span>
func (m *MsgUpdateParams) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgUpdateParams) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgUpdateParams) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_85ff275c542a231a, []int{0}
}</span>
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}</span>
func (m *MsgUpdateParams) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdateParams) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

func (m *MsgUpdateParams) GetAuthority() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Authority
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgUpdateParams) GetParams() Params <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Params
        }</span>
        <span class="cov0" title="0">return Params{}</span>
}

type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse) Reset()         <span class="cov0" title="0">{ *m = MsgUpdateParamsResponse{} }</span>
func (m *MsgUpdateParamsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgUpdateParamsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_85ff275c542a231a, []int{1}
}</span>
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}</span>
func (m *MsgUpdateParamsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

type MsgSubmitValue struct {
        Creator   string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
        QueryData []byte `protobuf:"bytes,2,opt,name=query_data,json=queryData,proto3" json:"query_data,omitempty"`
        Value     string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
        Salt      string `protobuf:"bytes,4,opt,name=salt,proto3" json:"salt,omitempty"`
}

func (m *MsgSubmitValue) Reset()         <span class="cov0" title="0">{ *m = MsgSubmitValue{} }</span>
func (m *MsgSubmitValue) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgSubmitValue) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgSubmitValue) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_85ff275c542a231a, []int{2}
}</span>
func (m *MsgSubmitValue) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgSubmitValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgSubmitValue.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgSubmitValue) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgSubmitValue.Merge(m, src)
}</span>
func (m *MsgSubmitValue) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgSubmitValue) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgSubmitValue.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgSubmitValue proto.InternalMessageInfo

func (m *MsgSubmitValue) GetCreator() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Creator
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgSubmitValue) GetQueryData() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryData
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *MsgSubmitValue) GetValue() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Value
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgSubmitValue) GetSalt() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Salt
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type MsgSubmitValueResponse struct {
}

func (m *MsgSubmitValueResponse) Reset()         <span class="cov0" title="0">{ *m = MsgSubmitValueResponse{} }</span>
func (m *MsgSubmitValueResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgSubmitValueResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgSubmitValueResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_85ff275c542a231a, []int{3}
}</span>
func (m *MsgSubmitValueResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgSubmitValueResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgSubmitValueResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgSubmitValueResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgSubmitValueResponse.Merge(m, src)
}</span>
func (m *MsgSubmitValueResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgSubmitValueResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgSubmitValueResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgSubmitValueResponse proto.InternalMessageInfo

type MsgCommitReport struct {
        Creator   string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
        QueryData []byte `protobuf:"bytes,2,opt,name=query_data,json=queryData,proto3" json:"query_data,omitempty"`
        Hash      string `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *MsgCommitReport) Reset()         <span class="cov0" title="0">{ *m = MsgCommitReport{} }</span>
func (m *MsgCommitReport) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgCommitReport) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgCommitReport) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_85ff275c542a231a, []int{4}
}</span>
func (m *MsgCommitReport) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgCommitReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgCommitReport.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgCommitReport) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgCommitReport.Merge(m, src)
}</span>
func (m *MsgCommitReport) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgCommitReport) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgCommitReport.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgCommitReport proto.InternalMessageInfo

func (m *MsgCommitReport) GetCreator() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Creator
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgCommitReport) GetQueryData() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryData
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *MsgCommitReport) GetHash() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Hash
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type MsgCommitReportResponse struct {
}

func (m *MsgCommitReportResponse) Reset()         <span class="cov0" title="0">{ *m = MsgCommitReportResponse{} }</span>
func (m *MsgCommitReportResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgCommitReportResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgCommitReportResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_85ff275c542a231a, []int{5}
}</span>
func (m *MsgCommitReportResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgCommitReportResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgCommitReportResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgCommitReportResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgCommitReportResponse.Merge(m, src)
}</span>
func (m *MsgCommitReportResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgCommitReportResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgCommitReportResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgCommitReportResponse proto.InternalMessageInfo

type MsgTip struct {
        Tipper    string     `protobuf:"bytes,1,opt,name=tipper,proto3" json:"tipper,omitempty"`
        QueryData []byte     `protobuf:"bytes,2,opt,name=query_data,json=queryData,proto3" json:"query_data,omitempty"`
        Amount    types.Coin `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount"`
}

func (m *MsgTip) Reset()         <span class="cov0" title="0">{ *m = MsgTip{} }</span>
func (m *MsgTip) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgTip) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgTip) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_85ff275c542a231a, []int{6}
}</span>
func (m *MsgTip) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgTip) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgTip.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgTip) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgTip.Merge(m, src)
}</span>
func (m *MsgTip) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgTip) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgTip.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgTip proto.InternalMessageInfo

func (m *MsgTip) GetTipper() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tipper
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgTip) GetQueryData() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryData
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *MsgTip) GetAmount() types.Coin <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Amount
        }</span>
        <span class="cov0" title="0">return types.Coin{}</span>
}

type MsgTipResponse struct {
}

func (m *MsgTipResponse) Reset()         <span class="cov0" title="0">{ *m = MsgTipResponse{} }</span>
func (m *MsgTipResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgTipResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgTipResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_85ff275c542a231a, []int{7}
}</span>
func (m *MsgTipResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgTipResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgTipResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgTipResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgTipResponse.Merge(m, src)
}</span>
func (m *MsgTipResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgTipResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgTipResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgTipResponse proto.InternalMessageInfo

// MsgUpdateCycleRequest is the Msg/UpdateCycle request type.
type MsgUpdateCyclelist struct {
        // authority is the address that controls the module (defaults to x/gov unless overwritten).
        Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
        // list of query data hex strings
        Cyclelist [][]byte `protobuf:"bytes,2,rep,name=cyclelist,proto3" json:"cyclelist,omitempty"`
}

func (m *MsgUpdateCyclelist) Reset()         <span class="cov0" title="0">{ *m = MsgUpdateCyclelist{} }</span>
func (m *MsgUpdateCyclelist) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgUpdateCyclelist) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgUpdateCyclelist) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_85ff275c542a231a, []int{8}
}</span>
func (m *MsgUpdateCyclelist) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdateCyclelist) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdateCyclelist.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdateCyclelist) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateCyclelist.Merge(m, src)
}</span>
func (m *MsgUpdateCyclelist) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdateCyclelist) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateCyclelist.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdateCyclelist proto.InternalMessageInfo

func (m *MsgUpdateCyclelist) GetAuthority() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Authority
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgUpdateCyclelist) GetCyclelist() [][]byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Cyclelist
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// MsgUpdateCycleResponse defines the Msg/UpdateCycle response type.
type MsgUpdateCyclelistResponse struct {
}

func (m *MsgUpdateCyclelistResponse) Reset()         <span class="cov0" title="0">{ *m = MsgUpdateCyclelistResponse{} }</span>
func (m *MsgUpdateCyclelistResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgUpdateCyclelistResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgUpdateCyclelistResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_85ff275c542a231a, []int{9}
}</span>
func (m *MsgUpdateCyclelistResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdateCyclelistResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdateCyclelistResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdateCyclelistResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateCyclelistResponse.Merge(m, src)
}</span>
func (m *MsgUpdateCyclelistResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdateCyclelistResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateCyclelistResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdateCyclelistResponse proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*MsgUpdateParams)(nil), "layer.oracle.MsgUpdateParams")
        proto.RegisterType((*MsgUpdateParamsResponse)(nil), "layer.oracle.MsgUpdateParamsResponse")
        proto.RegisterType((*MsgSubmitValue)(nil), "layer.oracle.MsgSubmitValue")
        proto.RegisterType((*MsgSubmitValueResponse)(nil), "layer.oracle.MsgSubmitValueResponse")
        proto.RegisterType((*MsgCommitReport)(nil), "layer.oracle.MsgCommitReport")
        proto.RegisterType((*MsgCommitReportResponse)(nil), "layer.oracle.MsgCommitReportResponse")
        proto.RegisterType((*MsgTip)(nil), "layer.oracle.MsgTip")
        proto.RegisterType((*MsgTipResponse)(nil), "layer.oracle.MsgTipResponse")
        proto.RegisterType((*MsgUpdateCyclelist)(nil), "layer.oracle.MsgUpdateCyclelist")
        proto.RegisterType((*MsgUpdateCyclelistResponse)(nil), "layer.oracle.MsgUpdateCyclelistResponse")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/oracle/tx.proto", fileDescriptor_85ff275c542a231a) }</span>

var fileDescriptor_85ff275c542a231a = []byte{
        // 670 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0x4d, 0x6f, 0xd3, 0x4a,
        0x14, 0x8d, 0x9b, 0x34, 0x4f, 0xb9, 0x89, 0x5e, 0xdf, 0x1b, 0xe5, 0xb5, 0xae, 0x95, 0xfa, 0x85,
        0x08, 0xa4, 0x52, 0xa9, 0xb6, 0x52, 0x10, 0x15, 0xd9, 0x91, 0xb0, 0x8d, 0x04, 0x6e, 0x60, 0x81,
        0x84, 0xaa, 0x89, 0x33, 0x72, 0x46, 0xb2, 0x33, 0xc6, 0x33, 0xa9, 0x9a, 0x1d, 0x20, 0xb1, 0x61,
        0xc5, 0x4f, 0x60, 0x83, 0xc4, 0xb2, 0x0b, 0xf8, 0x0f, 0x5d, 0x56, 0xac, 0x58, 0x21, 0xd4, 0x2e,
        0xfa, 0x37, 0x90, 0xc7, 0x63, 0x37, 0x1f, 0xfd, 0x90, 0xba, 0x49, 0xe6, 0xde, 0x73, 0xef, 0xb9,
        0x67, 0x66, 0x8e, 0x07, 0xfe, 0xf3, 0xf1, 0x84, 0x44, 0x36, 0x8b, 0xb0, 0xeb, 0x13, 0x5b, 0x1c,
        0x5a, 0x61, 0xc4, 0x04, 0x43, 0x15, 0x99, 0xb6, 0x92, 0xb4, 0xf1, 0x2f, 0x0e, 0xe8, 0x88, 0xd9,
        0xf2, 0x37, 0x29, 0x30, 0x4c, 0x97, 0xf1, 0x80, 0x71, 0xbb, 0x8f, 0x39, 0xb1, 0x0f, 0x9a, 0x7d,
        0x22, 0x70, 0xd3, 0x76, 0x19, 0x1d, 0x29, 0x7c, 0x4d, 0xe1, 0x01, 0xf7, 0xec, 0x83, 0x66, 0xfc,
        0xa7, 0x80, 0xf5, 0x04, 0xd8, 0x97, 0x91, 0x9d, 0x04, 0x0a, 0xaa, 0x7a, 0xcc, 0x63, 0x49, 0x3e,
        0x5e, 0xa5, 0x0d, 0x33, 0x0a, 0x43, 0x1c, 0xe1, 0x40, 0x35, 0x34, 0xbe, 0x6b, 0xb0, 0xd2, 0xe5,
        0xde, 0x8b, 0x70, 0x80, 0x05, 0x79, 0x26, 0x11, 0xf4, 0x08, 0x4a, 0x78, 0x2c, 0x86, 0x2c, 0xa2,
        0x62, 0xa2, 0x6b, 0x75, 0x6d, 0xb3, 0xd4, 0xd6, 0x7f, 0x7c, 0xdb, 0xae, 0xaa, 0x49, 0x4f, 0x06,
        0x83, 0x88, 0x70, 0xbe, 0x27, 0x22, 0x3a, 0xf2, 0x9c, 0x8b, 0x52, 0xb4, 0x0b, 0xc5, 0x84, 0x5b,
        0x5f, 0xaa, 0x6b, 0x9b, 0xe5, 0x9d, 0xaa, 0x35, 0x7d, 0x04, 0x56, 0xc2, 0xde, 0x2e, 0x1d, 0xff,
        0xfa, 0x3f, 0xf7, 0xf5, 0xfc, 0x68, 0x4b, 0x73, 0x54, 0x79, 0xab, 0xf9, 0xfe, 0xfc, 0x68, 0xeb,
        0x82, 0xe8, 0xe3, 0xf9, 0xd1, 0x96, 0x99, 0x48, 0x3e, 0x4c, 0x45, 0xcf, 0x69, 0x6c, 0xac, 0xc3,
        0xda, 0x5c, 0xca, 0x21, 0x3c, 0x64, 0x23, 0x4e, 0x1a, 0xef, 0x34, 0xf8, 0xbb, 0xcb, 0xbd, 0xbd,
        0x71, 0x3f, 0xa0, 0xe2, 0x25, 0xf6, 0xc7, 0x04, 0xe9, 0xf0, 0x97, 0x1b, 0x11, 0x2c, 0x58, 0x94,
        0xec, 0xc7, 0x49, 0x43, 0xb4, 0x01, 0xf0, 0x66, 0x4c, 0xa2, 0xc9, 0xfe, 0x00, 0x0b, 0x2c, 0x75,
        0x57, 0x9c, 0x92, 0xcc, 0x3c, 0xc5, 0x02, 0xa3, 0x2a, 0x2c, 0x1f, 0xc4, 0x0c, 0x7a, 0x5e, 0xb6,
        0x25, 0x01, 0x42, 0x50, 0xe0, 0xd8, 0x17, 0x7a, 0x41, 0x26, 0xe5, 0xba, 0x55, 0x89, 0xf7, 0x90,
        0xd2, 0x36, 0x74, 0x58, 0x9d, 0x95, 0x90, 0xa9, 0xf3, 0xe5, 0x79, 0x77, 0x58, 0x10, 0x50, 0xe1,
        0x90, 0x90, 0x45, 0xe2, 0xf6, 0xea, 0x10, 0x14, 0x86, 0x98, 0x0f, 0x95, 0x38, 0xb9, 0x9e, 0xd3,
        0x91, 0x1c, 0xd3, 0xf4, 0xb4, 0x4c, 0xc8, 0x07, 0x0d, 0x8a, 0x5d, 0xee, 0xf5, 0x68, 0x88, 0x56,
        0xa1, 0x28, 0x68, 0x18, 0x92, 0x74, 0xbe, 0x8a, 0x6e, 0x1a, 0xbf, 0x0b, 0x45, 0x1c, 0xb0, 0xf1,
        0x48, 0x48, 0x01, 0xe5, 0x9d, 0x75, 0x4b, 0x39, 0x24, 0x76, 0xb4, 0xa5, 0x1c, 0x6d, 0x75, 0x18,
        0x1d, 0xb5, 0x0b, 0xf1, 0xa5, 0x3b, 0xaa, 0xbc, 0x55, 0x8e, 0x35, 0xaa, 0x21, 0x8d, 0x7f, 0xe4,
        0x6d, 0xf5, 0x68, 0x98, 0x29, 0xfb, 0xac, 0x01, 0xca, 0x2e, 0xb7, 0x33, 0x71, 0x7d, 0xe2, 0x53,
        0x2e, 0x6e, 0x6d, 0xcb, 0x1a, 0x94, 0xdc, 0x94, 0x44, 0x5f, 0xaa, 0xe7, 0xe3, 0x4d, 0x64, 0x89,
        0xd6, 0xc3, 0x45, 0xef, 0xdd, 0xb9, 0xca, 0x7b, 0x99, 0x96, 0x46, 0x0d, 0x8c, 0xc5, 0x6c, 0xba,
        0x81, 0x9d, 0x2f, 0x79, 0xc8, 0x77, 0xb9, 0x87, 0x7a, 0x50, 0x99, 0xf9, 0xb0, 0x36, 0x66, 0x3f,
        0x88, 0x39, 0x03, 0x1b, 0xf7, 0xae, 0x85, 0x53, 0x76, 0xf4, 0x1c, 0xca, 0xd3, 0xde, 0xae, 0x2d,
        0x74, 0x4d, 0xa1, 0xc6, 0xdd, 0xeb, 0xd0, 0x8c, 0xb2, 0x07, 0x95, 0x19, 0x47, 0x2e, 0x0a, 0x9d,
        0x86, 0x2f, 0x11, 0x7a, 0x99, 0xc3, 0xd0, 0x63, 0xc8, 0xc7, 0xee, 0xaa, 0x2e, 0x54, 0xf7, 0x68,
        0x68, 0xd4, 0x2e, 0xcb, 0x66, 0xad, 0xaf, 0x61, 0x65, 0xfe, 0xfa, 0xeb, 0x57, 0x9c, 0x4e, 0x56,
        0x61, 0x6c, 0xde, 0x54, 0x91, 0xd2, 0x1b, 0xcb, 0x6f, 0xe3, 0xf7, 0xa7, 0xdd, 0x39, 0x3e, 0x35,
        0xb5, 0x93, 0x53, 0x53, 0xfb, 0x7d, 0x6a, 0x6a, 0x9f, 0xce, 0xcc, 0xdc, 0xc9, 0x99, 0x99, 0xfb,
        0x79, 0x66, 0xe6, 0x5e, 0xdd, 0xf7, 0xa8, 0x18, 0x8e, 0xfb, 0x96, 0xcb, 0x02, 0x5b, 0x10, 0xdf,
        0x67, 0xd1, 0x36, 0x65, 0xf6, 0x9c, 0x2f, 0xc4, 0x24, 0x24, 0xbc, 0x5f, 0x94, 0x0f, 0xe9, 0x83,
        0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x41, 0xd5, 0xf0, 0x86, 0x07, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
        // UpdateParams defines a (governance) operation for updating the module
        // parameters. The authority defaults to the x/gov module account.
        UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
        SubmitValue(ctx context.Context, in *MsgSubmitValue, opts ...grpc.CallOption) (*MsgSubmitValueResponse, error)
        CommitReport(ctx context.Context, in *MsgCommitReport, opts ...grpc.CallOption) (*MsgCommitReportResponse, error)
        Tip(ctx context.Context, in *MsgTip, opts ...grpc.CallOption) (*MsgTipResponse, error)
        UpdateCyclelist(ctx context.Context, in *MsgUpdateCyclelist, opts ...grpc.CallOption) (*MsgUpdateCyclelistResponse, error)
}

type msgClient struct {
        cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient <span class="cov0" title="0">{
        return &amp;msgClient{cc}
}</span>

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) <span class="cov0" title="0">{
        out := new(MsgUpdateParamsResponse)
        err := c.cc.Invoke(ctx, "/layer.oracle.Msg/UpdateParams", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgClient) SubmitValue(ctx context.Context, in *MsgSubmitValue, opts ...grpc.CallOption) (*MsgSubmitValueResponse, error) <span class="cov0" title="0">{
        out := new(MsgSubmitValueResponse)
        err := c.cc.Invoke(ctx, "/layer.oracle.Msg/SubmitValue", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgClient) CommitReport(ctx context.Context, in *MsgCommitReport, opts ...grpc.CallOption) (*MsgCommitReportResponse, error) <span class="cov0" title="0">{
        out := new(MsgCommitReportResponse)
        err := c.cc.Invoke(ctx, "/layer.oracle.Msg/CommitReport", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgClient) Tip(ctx context.Context, in *MsgTip, opts ...grpc.CallOption) (*MsgTipResponse, error) <span class="cov0" title="0">{
        out := new(MsgTipResponse)
        err := c.cc.Invoke(ctx, "/layer.oracle.Msg/Tip", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgClient) UpdateCyclelist(ctx context.Context, in *MsgUpdateCyclelist, opts ...grpc.CallOption) (*MsgUpdateCyclelistResponse, error) <span class="cov0" title="0">{
        out := new(MsgUpdateCyclelistResponse)
        err := c.cc.Invoke(ctx, "/layer.oracle.Msg/UpdateCyclelist", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
        // UpdateParams defines a (governance) operation for updating the module
        // parameters. The authority defaults to the x/gov module account.
        UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
        SubmitValue(context.Context, *MsgSubmitValue) (*MsgSubmitValueResponse, error)
        CommitReport(context.Context, *MsgCommitReport) (*MsgCommitReportResponse, error)
        Tip(context.Context, *MsgTip) (*MsgTipResponse, error)
        UpdateCyclelist(context.Context, *MsgUpdateCyclelist) (*MsgUpdateCyclelistResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}</span>
func (*UnimplementedMsgServer) SubmitValue(ctx context.Context, req *MsgSubmitValue) (*MsgSubmitValueResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SubmitValue not implemented")
}</span>
func (*UnimplementedMsgServer) CommitReport(ctx context.Context, req *MsgCommitReport) (*MsgCommitReportResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CommitReport not implemented")
}</span>
func (*UnimplementedMsgServer) Tip(ctx context.Context, req *MsgTip) (*MsgTipResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Tip not implemented")
}</span>
func (*UnimplementedMsgServer) UpdateCyclelist(ctx context.Context, req *MsgUpdateCyclelist) (*MsgUpdateCyclelistResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateCyclelist not implemented")
}</span>

func RegisterMsgServer(s grpc1.Server, srv MsgServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;_Msg_serviceDesc, srv)
}</span>

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgUpdateParams)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).UpdateParams(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.oracle.Msg/UpdateParams",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Msg_SubmitValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgSubmitValue)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).SubmitValue(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.oracle.Msg/SubmitValue",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).SubmitValue(ctx, req.(*MsgSubmitValue))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Msg_CommitReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgCommitReport)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).CommitReport(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.oracle.Msg/CommitReport",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).CommitReport(ctx, req.(*MsgCommitReport))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Msg_Tip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgTip)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).Tip(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.oracle.Msg/Tip",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).Tip(ctx, req.(*MsgTip))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Msg_UpdateCyclelist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgUpdateCyclelist)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).UpdateCyclelist(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.oracle.Msg/UpdateCyclelist",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).UpdateCyclelist(ctx, req.(*MsgUpdateCyclelist))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _Msg_serviceDesc = grpc.ServiceDesc{
        ServiceName: "layer.oracle.Msg",
        HandlerType: (*MsgServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "UpdateParams",
                        Handler:    _Msg_UpdateParams_Handler,
                },
                {
                        MethodName: "SubmitValue",
                        Handler:    _Msg_SubmitValue_Handler,
                },
                {
                        MethodName: "CommitReport",
                        Handler:    _Msg_CommitReport_Handler,
                },
                {
                        MethodName: "Tip",
                        Handler:    _Msg_Tip_Handler,
                },
                {
                        MethodName: "UpdateCyclelist",
                        Handler:    _Msg_UpdateCyclelist_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "layer/oracle/tx.proto",
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintTx(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x12
        if len(m.Authority) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Authority)
                copy(dAtA[i:], m.Authority)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgSubmitValue) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgSubmitValue) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgSubmitValue) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Salt) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Salt)
                copy(dAtA[i:], m.Salt)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Salt)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov0" title="0">if len(m.Value) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Value)
                copy(dAtA[i:], m.Value)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Value)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.QueryData) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryData)
                copy(dAtA[i:], m.QueryData)
                i = encodeVarintTx(dAtA, i, uint64(len(m.QueryData)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Creator) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Creator)
                copy(dAtA[i:], m.Creator)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgSubmitValueResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgSubmitValueResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgSubmitValueResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgCommitReport) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgCommitReport) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgCommitReport) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Hash) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Hash)
                copy(dAtA[i:], m.Hash)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Hash)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.QueryData) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryData)
                copy(dAtA[i:], m.QueryData)
                i = encodeVarintTx(dAtA, i, uint64(len(m.QueryData)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Creator) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Creator)
                copy(dAtA[i:], m.Creator)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgCommitReportResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgCommitReportResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgCommitReportResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgTip) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgTip) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgTip) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintTx(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x1a
        if len(m.QueryData) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryData)
                copy(dAtA[i:], m.QueryData)
                i = encodeVarintTx(dAtA, i, uint64(len(m.QueryData)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Tipper) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Tipper)
                copy(dAtA[i:], m.Tipper)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Tipper)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgTipResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgTipResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgTipResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgUpdateCyclelist) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdateCyclelist) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdateCyclelist) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Cyclelist) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Cyclelist) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        i -= len(m.Cyclelist[iNdEx])
                        copy(dAtA[i:], m.Cyclelist[iNdEx])
                        i = encodeVarintTx(dAtA, i, uint64(len(m.Cyclelist[iNdEx])))
                        i--
                        dAtA[i] = 0x12
                }</span>
        }
        <span class="cov0" title="0">if len(m.Authority) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Authority)
                copy(dAtA[i:], m.Authority)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgUpdateCyclelistResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdateCyclelistResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdateCyclelistResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func encodeVarintTx(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovTx(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *MsgUpdateParams) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Authority)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Params.Size()
        n += 1 + l + sovTx(uint64(l))
        return n</span>
}

func (m *MsgUpdateParamsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgSubmitValue) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Creator)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.QueryData)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Value)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Salt)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgSubmitValueResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgCommitReport) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Creator)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.QueryData)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Hash)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgCommitReportResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgTip) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Tipper)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.QueryData)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Amount.Size()
        n += 1 + l + sovTx(uint64(l))
        return n</span>
}

func (m *MsgTipResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgUpdateCyclelist) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Authority)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">if len(m.Cyclelist) &gt; 0 </span><span class="cov0" title="0">{
                for _, b := range m.Cyclelist </span><span class="cov0" title="0">{
                        l = len(b)
                        n += 1 + l + sovTx(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *MsgUpdateCyclelistResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func sovTx(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozTx(x uint64) (n int) <span class="cov0" title="0">{
        return sovTx(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Authority = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgSubmitValue) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgSubmitValue: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgSubmitValue: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Creator = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryData", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryData = append(m.QueryData[:0], dAtA[iNdEx:postIndex]...)
                        if m.QueryData == nil </span><span class="cov0" title="0">{
                                m.QueryData = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Value = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Salt = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgSubmitValueResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgSubmitValueResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgSubmitValueResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgCommitReport) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCommitReport: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCommitReport: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Creator = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryData", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryData = append(m.QueryData[:0], dAtA[iNdEx:postIndex]...)
                        if m.QueryData == nil </span><span class="cov0" title="0">{
                                m.QueryData = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Hash = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgCommitReportResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCommitReportResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCommitReportResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgTip) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgTip: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgTip: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Tipper", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Tipper = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryData", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryData = append(m.QueryData[:0], dAtA[iNdEx:postIndex]...)
                        if m.QueryData == nil </span><span class="cov0" title="0">{
                                m.QueryData = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgTipResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgTipResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgTipResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUpdateCyclelist) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateCyclelist: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateCyclelist: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Authority = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Cyclelist", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Cyclelist = append(m.Cyclelist, make([]byte, postIndex-iNdEx))
                        copy(m.Cyclelist[len(m.Cyclelist)-1], dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUpdateCyclelistResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateCyclelistResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateCyclelistResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipTx(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupTx
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthTx
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file128" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/oracle/user_tip.proto

package types

import (
        cosmossdk_io_math "cosmossdk.io/math"
        fmt "fmt"
        _ "github.com/cosmos/cosmos-proto"
        _ "github.com/cosmos/cosmos-sdk/types"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type UserTipTotal struct {
        Address string                `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
        Total   cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total,proto3,customtype=cosmossdk.io/math.Int" json:"total"`
}

func (m *UserTipTotal) Reset()         <span class="cov0" title="0">{ *m = UserTipTotal{} }</span>
func (m *UserTipTotal) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UserTipTotal) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*UserTipTotal) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_aa4312bb1dc0313d, []int{0}
}</span>
func (m *UserTipTotal) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *UserTipTotal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_UserTipTotal.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *UserTipTotal) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_UserTipTotal.Merge(m, src)
}</span>
func (m *UserTipTotal) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *UserTipTotal) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_UserTipTotal.DiscardUnknown(m)
}</span>

var xxx_messageInfo_UserTipTotal proto.InternalMessageInfo

func (m *UserTipTotal) GetAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Address
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*UserTipTotal)(nil), "layer.oracle.UserTipTotal")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/oracle/user_tip.proto", fileDescriptor_aa4312bb1dc0313d) }</span>

var fileDescriptor_aa4312bb1dc0313d = []byte{
        // 276 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x34, 0x90, 0xc1, 0x4a, 0xc3, 0x40,
        0x10, 0x86, 0xb3, 0x82, 0x8a, 0xa1, 0xa7, 0x52, 0x21, 0x56, 0xd8, 0x8a, 0x27, 0x45, 0x92, 0xa5,
        0xfa, 0x04, 0xad, 0xa7, 0x5e, 0x6b, 0xbd, 0x78, 0x29, 0x9b, 0x64, 0x49, 0x17, 0x37, 0x99, 0xb0,
        0x3b, 0x15, 0xfb, 0x00, 0xde, 0x7d, 0x98, 0x3e, 0x44, 0x8f, 0xa5, 0x27, 0xf1, 0x50, 0x24, 0x79,
        0x11, 0x69, 0x26, 0xbd, 0xed, 0xcc, 0x37, 0xdf, 0x0f, 0xfb, 0xfb, 0xd7, 0x46, 0xae, 0x94, 0x15,
        0x60, 0x65, 0x62, 0x94, 0x58, 0x3a, 0x65, 0xe7, 0xa8, 0xcb, 0xa8, 0xb4, 0x80, 0xd0, 0xed, 0x34,
        0x30, 0x22, 0xd8, 0xe7, 0x09, 0xb8, 0x1c, 0x9c, 0x88, 0xa5, 0x53, 0xe2, 0x63, 0x18, 0x2b, 0x94,
        0x43, 0x91, 0x80, 0x2e, 0xe8, 0xba, 0x7f, 0x45, 0x7c, 0xde, 0x4c, 0x82, 0x86, 0x16, 0xf5, 0x32,
        0xc8, 0x80, 0xf6, 0x87, 0x17, 0x6d, 0x6f, 0xbf, 0x98, 0xdf, 0x79, 0x75, 0xca, 0xce, 0x74, 0x39,
        0x03, 0x94, 0xa6, 0xfb, 0xe8, 0x9f, 0xcb, 0x34, 0xb5, 0xca, 0xb9, 0x80, 0xdd, 0xb0, 0xbb, 0x8b,
        0x71, 0xb0, 0x5b, 0x87, 0xbd, 0x36, 0x69, 0x44, 0xe4, 0x05, 0xad, 0x2e, 0xb2, 0xe9, 0xf1, 0xb0,
        0x3b, 0xf2, 0x4f, 0xf1, 0x20, 0x07, 0x27, 0x8d, 0xf1, 0xb0, 0xd9, 0x0f, 0xbc, 0xdf, 0xfd, 0xe0,
        0x92, 0x2c, 0x97, 0xbe, 0x47, 0x1a, 0x44, 0x2e, 0x71, 0x11, 0x4d, 0x0a, 0xdc, 0xad, 0x43, 0xbf,
        0x8d, 0x9b, 0x14, 0x38, 0x25, 0x73, 0xfc, 0xbc, 0xa9, 0x38, 0xdb, 0x56, 0x9c, 0xfd, 0x55, 0x9c,
        0x7d, 0xd7, 0xdc, 0xdb, 0xd6, 0xdc, 0xfb, 0xa9, 0xb9, 0xf7, 0x76, 0x9f, 0x69, 0x5c, 0x2c, 0xe3,
        0x28, 0x81, 0x5c, 0xa0, 0x32, 0x06, 0x6c, 0xa8, 0x41, 0x50, 0x65, 0x9f, 0xc7, 0xd2, 0x70, 0x55,
        0x2a, 0x17, 0x9f, 0x35, 0x7f, 0x7a, 0xfa, 0x0f, 0x00, 0x00, 0xff, 0xff, 0xac, 0xd3, 0x66, 0xc9,
        0x51, 0x01, 0x00, 0x00,
}

func (m *UserTipTotal) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *UserTipTotal) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *UserTipTotal) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size := m.Total.Size()
                i -= size
                if _, err := m.Total.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintUserTip(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x12
        if len(m.Address) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Address)
                copy(dAtA[i:], m.Address)
                i = encodeVarintUserTip(dAtA, i, uint64(len(m.Address)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintUserTip(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovUserTip(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *UserTipTotal) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Address)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovUserTip(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Total.Size()
        n += 1 + l + sovUserTip(uint64(l))
        return n</span>
}

func sovUserTip(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozUserTip(x uint64) (n int) <span class="cov0" title="0">{
        return sovUserTip(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *UserTipTotal) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowUserTip
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: UserTipTotal: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: UserTipTotal: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowUserTip
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthUserTip
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthUserTip
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Address = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowUserTip
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthUserTip
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthUserTip
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Total.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipUserTip(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthUserTip
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipUserTip(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowUserTip
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowUserTip
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowUserTip
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthUserTip
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupUserTip
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthUserTip
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthUserTip        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowUserTip          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupUserTip = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file129" style="display: none">package keeper

import (
        "context"
        "strings"

        sdk "github.com/cosmos/cosmos-sdk/types"

        "github.com/tellor-io/layer/x/registry/types"
)

// SetDataSpec sets the data specification for a given query type.
// It converts the query type to lowercase and then calls the Set method of the SpecRegistry to store the data specification.
func (k Keeper) SetDataSpec(ctx sdk.Context, querytype string, dataspec types.DataSpec) error <span class="cov8" title="1">{
        querytype = strings.ToLower(querytype)
        return k.SpecRegistry.Set(ctx, querytype, dataspec)
}</span>

// GetSpec retrieves a DataSpec from the registry based on the provided query type.
// It converts the query type to lowercase before performing the retrieval.
// If the DataSpec is found, it is returned along with a nil error.
// If the DataSpec is not found, an empty DataSpec and an error are returned.
func (k Keeper) GetSpec(ctx context.Context, querytype string) (types.DataSpec, error) <span class="cov8" title="1">{
        querytype = strings.ToLower(querytype)
        return k.SpecRegistry.Get(ctx, querytype)
}</span>

// HasSpec checks if a data specification with the given query type exists in the registry.
// It returns true if the data specification exists, otherwise false.
// It converts the query type parameter to lower case before, for keeping things consistent.
// Returns an error if there was an issue checking the registry.
func (k Keeper) HasSpec(ctx context.Context, querytype string) (bool, error) <span class="cov8" title="1">{
        querytype = strings.ToLower(querytype)
        return k.SpecRegistry.Has(ctx, querytype)
}</span>
</pre>
		
		<pre class="file" id="file130" style="display: none">package keeper

import (
        "fmt"

        "cosmossdk.io/collections"
        "cosmossdk.io/core/store"
        "cosmossdk.io/log"

        "github.com/cosmos/cosmos-sdk/codec"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/registry/types"
)

type (
        Keeper struct {
                cdc          codec.BinaryCodec
                storeService store.KVStoreService
                // Params key: ParamsKeyPrefix | value: Params
                Params       collections.Item[types.Params]
                SpecRegistry collections.Map[string, types.DataSpec]
                Schema       collections.Schema
                hooks        types.RegistryHooks

                authority string
        }
)

func NewKeeper(
        cdc codec.BinaryCodec,
        storeService store.KVStoreService,
        authority string,

) Keeper <span class="cov8" title="1">{
        if _, err := sdk.AccAddressFromBech32(authority); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("invalid authority address: %s", authority))</span>
        }

        <span class="cov8" title="1">sb := collections.NewSchemaBuilder(storeService)
        k := Keeper{
                cdc:          cdc,
                storeService: storeService,

                Params:       collections.NewItem(sb, types.ParamsKey, "params", codec.CollValue[types.Params](cdc)),
                SpecRegistry: collections.NewMap(sb, types.SpecRegistryKey, "specRegistry", collections.StringKey, codec.CollValue[types.DataSpec](cdc)),
                authority:    authority,
        }
        schema, err := sb.Build()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">k.Schema = schema
        return k</span>
}

// GetAuthority returns the module's authority.
func (k Keeper) GetAuthority() string <span class="cov8" title="1">{
        return k.authority
}</span>

func (k Keeper) Logger(ctx sdk.Context) log.Logger <span class="cov8" title="1">{
        return ctx.Logger().With("module", fmt.Sprintf("x/%s", types.ModuleName))
}</span>

func (k *Keeper) SetHooks(rh types.RegistryHooks) <span class="cov0" title="0">{
        if k.hooks != nil </span><span class="cov0" title="0">{
                panic("cannot set registry hooks twice")</span>
        }

        <span class="cov0" title="0">k.hooks = rh</span>
}

func (k *Keeper) Hooks() types.RegistryHooks <span class="cov8" title="1">{
        if k.hooks == nil </span><span class="cov8" title="1">{
                // return a no-op implementation if no hooks are set
                return types.MultiRegistryHooks{}
        }</span>

        <span class="cov0" title="0">return k.hooks</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">package keeper

import (
        "github.com/tellor-io/layer/x/registry/types"
)

type msgServer struct {
        Keeper
}

// NewMsgServerImpl returns an implementation of the MsgServer interface
// for the provided Keeper.
func NewMsgServerImpl(keeper Keeper) types.MsgServer <span class="cov8" title="1">{
        return &amp;msgServer{Keeper: keeper}
}</span>

var _ types.MsgServer = msgServer{}
</pre>
		
		<pre class="file" id="file132" style="display: none">package keeper

import (
        "context"
        "fmt"
        "strings"

        sdk "github.com/cosmos/cosmos-sdk/types"

        "github.com/tellor-io/layer/x/registry/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k msgServer) RegisterSpec(goCtx context.Context, msg *types.MsgRegisterSpec) (*types.MsgRegisterSpecResponse, error) <span class="cov8" title="1">{
        ctx := sdk.UnwrapSDKContext(goCtx)
        specExists, _ := k.Keeper.HasSpec(ctx, msg.QueryType)
        if specExists </span><span class="cov8" title="1">{
                return nil, status.Error(codes.AlreadyExists, "data spec previously registered")
        }</span>
        <span class="cov8" title="1">msg.Spec.ResponseValueType = strings.ToLower(msg.Spec.ResponseValueType)
        msg.Spec.AggregationMethod = strings.ToLower(msg.Spec.AggregationMethod)
        msg.Spec.Registrar = msg.Registrar

        if !types.SupportedType(msg.Spec.ResponseValueType) </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("value type not supported: %s", msg.Spec.ResponseValueType))
        }</span>
        // TODO: assert the aggregation can be handled
        <span class="cov8" title="1">if !types.SupportedAggregationMethod[msg.Spec.AggregationMethod] </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("aggregation method not supported: %s", msg.Spec.AggregationMethod))
        }</span>

        <span class="cov8" title="1">if err := k.Keeper.SetDataSpec(ctx, msg.QueryType, msg.Spec); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;types.MsgRegisterSpecResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file133" style="display: none">package keeper

import (
        "context"
        "strings"

        errorsmod "cosmossdk.io/errors"
        sdk "github.com/cosmos/cosmos-sdk/types"

        "github.com/tellor-io/layer/x/registry/types"
)

func (k msgServer) UpdateDataSpec(goCtx context.Context, req *types.MsgUpdateDataSpec) (*types.MsgUpdateDataSpecResponse, error) <span class="cov8" title="1">{
        if k.GetAuthority() != req.Authority </span><span class="cov8" title="1">{
                return nil, errorsmod.Wrapf(types.ErrInvalidSigner, "invalid authority; expected %s, got %s", k.GetAuthority(), req.Authority)
        }</span>

        <span class="cov8" title="1">ctx := sdk.UnwrapSDKContext(goCtx)
        // normalize query type
        req.QueryType = strings.ToLower(req.QueryType)
        // check if the query type exists
        querytypeExists, err := k.Keeper.HasSpec(ctx, req.QueryType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !querytypeExists </span><span class="cov0" title="0">{
                return nil, errorsmod.Wrapf(types.ErrInvalidSpec, "data spec not registered for query type: %s", req.QueryType)
        }</span>
        <span class="cov8" title="1">if err := k.Keeper.SetDataSpec(ctx, req.QueryType, req.Spec); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := k.Keeper.Hooks().AfterDataSpecUpdated(ctx, req.QueryType, req.Spec); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;types.MsgUpdateDataSpecResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file134" style="display: none">package keeper

import (
        sdk "github.com/cosmos/cosmos-sdk/types"

        "github.com/tellor-io/layer/x/registry/types"
)

// SetParams sets the x/registry module parameters.
func (k Keeper) SetParams(ctx sdk.Context, params types.Params) error <span class="cov8" title="1">{
        return k.Params.Set(ctx, params)
}</span>

// GetParams sets the x/registry module parameters.
func (k Keeper) GetParams(ctx sdk.Context) (types.Params, error) <span class="cov8" title="1">{
        params, err := k.Params.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return types.Params{}, err
        }</span>
        <span class="cov8" title="1">return params, nil</span>
}
</pre>
		
		<pre class="file" id="file135" style="display: none">package keeper

import (
        "github.com/tellor-io/layer/x/registry/types"
)

type Querier struct {
        Keeper
}

var _ types.QueryServer = Querier{}

func NewQuerier(keeper Keeper) Querier <span class="cov8" title="1">{
        return Querier{Keeper: keeper}
}</span>
</pre>
		
		<pre class="file" id="file136" style="display: none">package keeper

import (
        "context"
        "fmt"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/registry/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Querier) DecodeQuerydata(goCtx context.Context, req *types.QueryDecodeQuerydataRequest) (*types.QueryDecodeQuerydataResponse, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov8" title="1">queryType, fieldBytes, err := types.DecodeQueryType(req.QueryData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("failed to decode query data: %v", err))
        }</span>
        <span class="cov8" title="1">ctx := sdk.UnwrapSDKContext(goCtx)
        // fetch data spec from store
        exists, err := k.Keeper.HasSpec(ctx, queryType)
        if !exists </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("can't decode query data for query type which doesn't exist in store: %v", queryType))
        }</span>
        <span class="cov8" title="1">dataSpec, err := k.Keeper.GetSpec(ctx, queryType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("failed to get data spec: %v", err))
        }</span>
        // convert field bytes to string
        <span class="cov8" title="1">fields, err := types.DecodeParamtypes(fieldBytes, dataSpec.AbiComponents)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("failed to decode query data fields: %v", err))
        }</span>

        <span class="cov8" title="1">return &amp;types.QueryDecodeQuerydataResponse{Spec: fmt.Sprintf("%s: %s", queryType, fields)}, nil</span>
}
</pre>
		
		<pre class="file" id="file137" style="display: none">package keeper

import (
        "context"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/registry/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Keeper) DecodeValue(goCtx context.Context, req *types.QueryDecodeValueRequest) (*types.QueryDecodeValueResponse, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>
        <span class="cov8" title="1">ctx := sdk.UnwrapSDKContext(goCtx)
        // get spec from store
        spec, err := k.GetSpec(ctx, req.QueryType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.NotFound, "data spec not found")
        }</span>

        <span class="cov8" title="1">value, err := spec.DecodeValue(req.Value)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "failed to decode value")
        }</span>

        <span class="cov8" title="1">return &amp;types.QueryDecodeValueResponse{DecodedValue: value}, nil</span>
}
</pre>
		
		<pre class="file" id="file138" style="display: none">package keeper

import (
        "context"
        "fmt"

        "github.com/tellor-io/layer/x/registry/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Keeper) GenerateQuerydata(ctx context.Context, req *types.QueryGenerateQuerydataRequest) (*types.QueryGenerateQuerydataResponse, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        // fetch data spec from store
        <span class="cov8" title="1">exists, err := k.HasSpec(ctx, req.Querytype)
        if !exists </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("can't generate query data for query type which doesn't exist in store: %v", err))
        }</span>
        <span class="cov8" title="1">dataSpec, err := k.GetSpec(ctx, req.Querytype)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("failed to get data spec: %v", err))
        }</span>

        <span class="cov8" title="1">querydata, err := dataSpec.EncodeData(req.Querytype, req.Parameters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("failed to encode query data: %v", err))
        }</span>

        <span class="cov8" title="1">return &amp;types.QueryGenerateQuerydataResponse{QueryData: querydata}, nil</span>
}
</pre>
		
		<pre class="file" id="file139" style="display: none">package keeper

import (
        "context"

        "github.com/tellor-io/layer/x/registry/types"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Querier) GetDataSpec(goCtx context.Context, req *types.QueryGetDataSpecRequest) (*types.QueryGetDataSpecResponse, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov8" title="1">ctx := sdk.UnwrapSDKContext(goCtx)
        if req.QueryType == "" </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "invalid request; query type cannot be empty")
        }</span>

        <span class="cov8" title="1">exists, err := k.Keeper.HasSpec(ctx, req.QueryType)
        if !exists </span><span class="cov8" title="1">{
                return nil, status.Error(codes.NotFound, "data spec not registered")
        }</span>
        <span class="cov8" title="1">dataSpec, err := k.Keeper.GetSpec(ctx, req.QueryType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;types.QueryGetDataSpecResponse{Spec: &amp;dataSpec}, nil</span>
}
</pre>
		
		<pre class="file" id="file140" style="display: none">package keeper

import (
        "context"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/registry/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (k Querier) Params(goCtx context.Context, req *types.QueryParamsRequest) (*types.QueryParamsResponse, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>
        <span class="cov8" title="1">ctx := sdk.UnwrapSDKContext(goCtx)
        params, err := k.GetParams(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;types.QueryParamsResponse{Params: params}, nil</span>
}
</pre>
		
		<pre class="file" id="file141" style="display: none">package registry

import (
        autocliv1 "cosmossdk.io/api/cosmos/autocli/v1"

        modulev1 "github.com/tellor-io/layer/api/layer/registry"
)

// AutoCLIOptions implements the autocli.HasAutoCLIConfig interface.
func (am AppModule) AutoCLIOptions() *autocliv1.ModuleOptions <span class="cov0" title="0">{
        return &amp;autocliv1.ModuleOptions{
                Query: &amp;autocliv1.ServiceCommandDescriptor{
                        Service: modulev1.Query_ServiceDesc.ServiceName,
                        RpcCommandOptions: []*autocliv1.RpcCommandOptions{
                                {
                                        RpcMethod: "Params",
                                        Use:       "params",
                                        Short:     "Shows the parameters of the module",
                                },
                                {
                                        RpcMethod:      "GetDataSpec",
                                        Use:            "data-spec [query-type]",
                                        Short:          "Shows the data spec for the given query type",
                                        PositionalArgs: []*autocliv1.PositionalArgDescriptor{{ProtoField: "query_type"}},
                                },
                                {
                                        RpcMethod:      "DecodeQuerydata",
                                        Use:            "decode-querydata [query_data]",
                                        Short:          "Decode the query data into human readable format",
                                        PositionalArgs: []*autocliv1.PositionalArgDescriptor{{ProtoField: "query_data"}},
                                },

                                {
                                        RpcMethod:      "GenerateQuerydata",
                                        Use:            "generate-querydata [querytype] [parameters]",
                                        Short:          "Encode query data hex given query type and parameters",
                                        PositionalArgs: []*autocliv1.PositionalArgDescriptor{{ProtoField: "querytype"}, {ProtoField: "parameters"}},
                                },

                                {
                                        RpcMethod:      "DecodeValue",
                                        Use:            "decode-value [query-type] [value]",
                                        Short:          "Decode the value given query type",
                                        PositionalArgs: []*autocliv1.PositionalArgDescriptor{{ProtoField: "queryType"}, {ProtoField: "value"}},
                                },

                                // this line is used by ignite scaffolding # autocli/query
                        },
                },
                Tx: &amp;autocliv1.ServiceCommandDescriptor{
                        Service: modulev1.Msg_ServiceDesc.ServiceName,
                        RpcCommandOptions: []*autocliv1.RpcCommandOptions{
                                {
                                        RpcMethod: "UpdateDataSpec",
                                        Skip:      true, // skipped because authority gated
                                },
                                {
                                        RpcMethod:      "RegisterSpec",
                                        Use:            "register-spec [query-type] [spec]",
                                        Short:          "Broadcast message RegisterSpec",
                                        PositionalArgs: []*autocliv1.PositionalArgDescriptor{{ProtoField: "query_type"}, {ProtoField: "spec"}},
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file142" style="display: none">package registry

import (
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/registry/keeper"
        "github.com/tellor-io/layer/x/registry/types"
)

const (
        genQuerytype = "spotprice"
)

// InitGenesis initializes the module's state from a provided genesis state.
func InitGenesis(ctx sdk.Context, k keeper.Keeper, genState types.GenesisState) <span class="cov8" title="1">{
        // this line is used by starport scaffolding # genesis/module/init
        k.SetParams(ctx, genState.Params)
        k.SetDataSpec(ctx, genQuerytype, genState.Dataspec)
}</span>

// ExportGenesis returns the module's exported genesis
func ExportGenesis(ctx sdk.Context, k keeper.Keeper) *types.GenesisState <span class="cov8" title="1">{
        params, err := k.GetParams(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">dataspec, err := k.GetSpec(ctx, genQuerytype)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">genesis := types.DefaultGenesis()
        genesis.Params = params
        genesis.Dataspec = dataspec

        // this line is used by starport scaffolding # genesis/module/export

        return genesis</span>
}
</pre>
		
		<pre class="file" id="file143" style="display: none">package registry

import (
        "context"
        "encoding/json"
        "fmt"

        // this line is used by starport scaffolding # 1
        "cosmossdk.io/core/appmodule"
        "cosmossdk.io/core/store"
        "cosmossdk.io/depinject"

        "github.com/grpc-ecosystem/grpc-gateway/runtime"
        registrymodulev1 "github.com/tellor-io/layer/api/layer/registry/module"

        "github.com/cosmos/cosmos-sdk/client"
        "github.com/cosmos/cosmos-sdk/codec"
        cdctypes "github.com/cosmos/cosmos-sdk/codec/types"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/module"
        authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
        govtypes "github.com/cosmos/cosmos-sdk/x/gov/types"

        "github.com/tellor-io/layer/x/registry/keeper"
        "github.com/tellor-io/layer/x/registry/types"
)

var (
        _ module.AppModule      = AppModule{}
        _ module.AppModuleBasic = AppModuleBasic{}
)

// ----------------------------------------------------------------------------
// AppModuleBasic
// ----------------------------------------------------------------------------

// AppModuleBasic implements the AppModuleBasic interface that defines the independent methods a Cosmos SDK module needs to implement.
type AppModuleBasic struct {
        cdc codec.BinaryCodec
}

// IsOnePerModuleType implements the depinject.OnePerModuleType interface.
func (AppModuleBasic) IsOnePerModuleType() {<span class="cov0" title="0">}</span>

// IsAppModule implements the appmodule.AppModule interface.
func (AppModuleBasic) IsAppModule() {<span class="cov0" title="0">}</span>

func NewAppModuleBasic(cdc codec.BinaryCodec) AppModuleBasic <span class="cov0" title="0">{
        return AppModuleBasic{cdc: cdc}
}</span>

// Name returns the name of the module as a string
func (AppModuleBasic) Name() string <span class="cov0" title="0">{
        return types.ModuleName
}</span>

// RegisterLegacyAminoCodec registers the amino codec for the module, which is used to marshal and unmarshal structs to/from []byte in order to persist them in the module's KVStore
func (AppModuleBasic) RegisterLegacyAminoCodec(cdc *codec.LegacyAmino) {<span class="cov0" title="0">}</span>

// RegisterInterfaces registers a module's interface types and their concrete implementations as proto.Message
func (a AppModuleBasic) RegisterInterfaces(reg cdctypes.InterfaceRegistry) <span class="cov0" title="0">{
        types.RegisterInterfaces(reg)
}</span>

// DefaultGenesis returns a default GenesisState for the module, marshalled to json.RawMessage. The default GenesisState need to be defined by the module developer and is primarily used for testing
func (AppModuleBasic) DefaultGenesis(cdc codec.JSONCodec) json.RawMessage <span class="cov0" title="0">{
        return cdc.MustMarshalJSON(types.DefaultGenesis())
}</span>

// ValidateGenesis used to validate the GenesisState, given in its json.RawMessage form
func (AppModuleBasic) ValidateGenesis(cdc codec.JSONCodec, config client.TxEncodingConfig, bz json.RawMessage) error <span class="cov0" title="0">{
        var genState types.GenesisState
        if err := cdc.UnmarshalJSON(bz, &amp;genState); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal %s genesis state: %w", types.ModuleName, err)
        }</span>
        <span class="cov0" title="0">return genState.Validate()</span>
}

// RegisterGRPCGatewayRoutes registers the gRPC Gateway routes for the module
func (AppModuleBasic) RegisterGRPCGatewayRoutes(clientCtx client.Context, mux *runtime.ServeMux) <span class="cov0" title="0">{
        types.RegisterQueryHandlerClient(context.Background(), mux, types.NewQueryClient(clientCtx))
}</span>

// ----------------------------------------------------------------------------
// AppModule
// ----------------------------------------------------------------------------

// AppModule implements the AppModule interface that defines the inter-dependent methods that modules need to implement
type AppModule struct {
        AppModuleBasic

        keeper        keeper.Keeper
        accountKeeper types.AccountKeeper
        bankKeeper    types.BankKeeper
}

func NewAppModule(
        cdc codec.Codec,
        keeper keeper.Keeper,
        accountKeeper types.AccountKeeper,
        bankKeeper types.BankKeeper,
) AppModule <span class="cov0" title="0">{
        return AppModule{
                AppModuleBasic: NewAppModuleBasic(cdc),
                keeper:         keeper,
                accountKeeper:  accountKeeper,
                bankKeeper:     bankKeeper,
        }
}</span>

// RegisterServices registers a gRPC query service to respond to the module-specific gRPC queries
func (am AppModule) RegisterServices(cfg module.Configurator) <span class="cov0" title="0">{
        types.RegisterMsgServer(cfg.MsgServer(), keeper.NewMsgServerImpl(am.keeper))
        types.RegisterQueryServer(cfg.QueryServer(), keeper.NewQuerier(am.keeper))
}</span>

// RegisterInvariants registers the invariants of the module. If an invariant deviates from its predicted value, the InvariantRegistry triggers appropriate logic (most often the chain will be halted)
func (am AppModule) RegisterInvariants(_ sdk.InvariantRegistry) {<span class="cov0" title="0">}</span>

// InitGenesis performs the module's genesis initialization. It returns no validator updates.
func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, gs json.RawMessage) <span class="cov0" title="0">{
        var genState types.GenesisState
        // Initialize global index to index in genesis state
        cdc.MustUnmarshalJSON(gs, &amp;genState)

        InitGenesis(ctx, am.keeper, genState)
}</span>

// ExportGenesis returns the module's exported genesis state as raw JSON bytes.
func (am AppModule) ExportGenesis(ctx sdk.Context, cdc codec.JSONCodec) json.RawMessage <span class="cov0" title="0">{
        genState := ExportGenesis(ctx, am.keeper)
        return cdc.MustMarshalJSON(genState)
}</span>

// ConsensusVersion is a sequence number for state-breaking change of the module. It should be incremented on each consensus-breaking change introduced by the module. To avoid wrong/empty versions, the initial version should be set to 1
func (AppModule) ConsensusVersion() uint64 <span class="cov0" title="0">{ return 1 }</span>

// ----------------------------------------------------------------------------
// App Wiring Setup
// ----------------------------------------------------------------------------

func init() <span class="cov8" title="1">{
        appmodule.Register(&amp;registrymodulev1.Module{},
                appmodule.Provide(ProvideModule))
}</span>

type RegistryInputs struct {
        depinject.In

        KvStoreKey store.KVStoreService
        Cdc        codec.Codec
        Config     *registrymodulev1.Module

        AccountKeeper types.AccountKeeper
        BankKeeper    types.BankKeeper
}

type RegistryOutputs struct {
        depinject.Out

        RegistryKeeper keeper.Keeper
        Module         appmodule.AppModule
}

func ProvideModule(in RegistryInputs) RegistryOutputs <span class="cov0" title="0">{
        // default to governance authority if not provided
        authority := authtypes.NewModuleAddress(govtypes.ModuleName)
        if in.Config.Authority != "" </span><span class="cov0" title="0">{
                authority = authtypes.NewModuleAddressOrBech32Address(in.Config.Authority)
        }</span>

        <span class="cov0" title="0">k := keeper.NewKeeper(
                in.Cdc,
                in.KvStoreKey,
                authority.String(),
        )
        m := NewAppModule(
                in.Cdc,
                k,
                in.AccountKeeper,
                in.BankKeeper,
        )

        return RegistryOutputs{RegistryKeeper: k, Module: m}</span>
}
</pre>
		
		<pre class="file" id="file144" style="display: none">package registry

import (
        "math/rand"

        "github.com/cosmos/cosmos-sdk/baseapp"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/module"
        simtypes "github.com/cosmos/cosmos-sdk/types/simulation"
        "github.com/cosmos/cosmos-sdk/x/simulation"
        "github.com/tellor-io/layer/testutil/sample"
        registrysimulation "github.com/tellor-io/layer/x/registry/simulation"
        "github.com/tellor-io/layer/x/registry/types"
)

// avoid unused import issue
var (
        _ = sample.AccAddress
        _ = registrysimulation.FindAccount
        _ = simulation.MsgEntryKind
        _ = baseapp.Paramspace
        _ = rand.Rand{}
)

const (
        opWeightMsgRegisterQuery = "op_weight_msg_register_query"
        // TODO: Determine the simulation weight value
        defaultWeightMsgRegisterQuery int = 100

        opWeightMsgRegisterSpec = "op_weight_msg_register_spec"
        // TODO: Determine the simulation weight value
        defaultWeightMsgRegisterSpec int = 100

        // this line is used by starport scaffolding # simapp/module/const
)

// GenerateGenesisState creates a randomized GenState of the module.
func (AppModule) GenerateGenesisState(simState *module.SimulationState) <span class="cov0" title="0">{
        accs := make([]string, len(simState.Accounts))
        for i, acc := range simState.Accounts </span><span class="cov0" title="0">{
                accs[i] = acc.Address.String()
        }</span>
        <span class="cov0" title="0">registryGenesis := types.GenesisState{
                Params: types.DefaultParams(),
                // this line is used by starport scaffolding # simapp/module/genesisState
        }
        simState.GenState[types.ModuleName] = simState.Cdc.MustMarshalJSON(&amp;registryGenesis)</span>
}

// RegisterStoreDecoder registers a decoder.
func (am AppModule) RegisterStoreDecoder(_ simtypes.StoreDecoderRegistry) {<span class="cov0" title="0">}</span>

// ProposalContents doesn't return any content functions for governance proposals.
func (AppModule) ProposalContents(_ module.SimulationState) []simtypes.WeightedProposalContent <span class="cov0" title="0">{
        return nil
}</span>

// WeightedOperations returns the all the gov module operations with their respective weights.
func (am AppModule) WeightedOperations(simState module.SimulationState) []simtypes.WeightedOperation <span class="cov0" title="0">{
        operations := make([]simtypes.WeightedOperation, 0)

        var weightMsgRegisterSpec int
        simState.AppParams.GetOrGenerate(opWeightMsgRegisterSpec, &amp;weightMsgRegisterSpec, nil,
                func(_ *rand.Rand) </span><span class="cov0" title="0">{
                        weightMsgRegisterSpec = defaultWeightMsgRegisterSpec
                }</span>,
        )
        <span class="cov0" title="0">operations = append(operations, simulation.NewWeightedOperation(
                weightMsgRegisterSpec,
                registrysimulation.SimulateMsgRegisterSpec(am.accountKeeper, am.bankKeeper, am.keeper),
        ))

        // this line is used by starport scaffolding # simapp/module/operation

        return operations</span>
}

// ProposalMsgs returns msgs used for governance proposals for simulations.
func (am AppModule) ProposalMsgs(simState module.SimulationState) []simtypes.WeightedProposalMsg <span class="cov0" title="0">{
        return []simtypes.WeightedProposalMsg{
                simulation.NewWeightedProposalMsg(
                        opWeightMsgRegisterSpec,
                        defaultWeightMsgRegisterSpec,
                        func(r *rand.Rand, ctx sdk.Context, accs []simtypes.Account) sdk.Msg </span><span class="cov0" title="0">{
                                registrysimulation.SimulateMsgRegisterSpec(am.accountKeeper, am.bankKeeper, am.keeper)
                                return nil
                        }</span>,
                ),
                // this line is used by starport scaffolding # simapp/module/OpMsg
        }
}
</pre>
		
		<pre class="file" id="file145" style="display: none">package types

import (
        // "github.com/cosmos/cosmos-sdk/codec"
        cdctypes "github.com/cosmos/cosmos-sdk/codec/types"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/msgservice"
)

func RegisterInterfaces(registry cdctypes.InterfaceRegistry) <span class="cov0" title="0">{
        registry.RegisterImplementations((*sdk.Msg)(nil),
                &amp;MsgRegisterSpec{},
                &amp;MsgUpdateDataSpec{},
        )
        // this line is used by starport scaffolding # 3

        msgservice.RegisterMsgServiceDesc(registry, &amp;_Msg_serviceDesc)
}</span>
</pre>
		
		<pre class="file" id="file146" style="display: none">package types

import (
        "encoding/hex"
        "fmt"
        "math/big"
        "reflect"
        "regexp"
        "strconv"
        "strings"

        "github.com/ethereum/go-ethereum/common"
)

var (
        // Regular expression for parsing array types ...[size]
        reArray = regexp.MustCompile(`(.+)\[(\d*)\]$`)
        // Regular expression for parsing integer types, e.g. uint256,int8
        reInt = regexp.MustCompile(`(u?)int(\d*)`)
)

// ConvertABIToReflectType converts ABI type strings to reflect.Type
func ConvertTypeToReflectType(abiType string) (reflect.Type, error) <span class="cov8" title="1">{
        // Handling arrays
        if matches := reArray.FindStringSubmatch(abiType); matches != nil </span><span class="cov8" title="1">{
                elemType, err := ConvertTypeToReflectType(matches[1])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if matches[2] == "" </span><span class="cov8" title="1">{
                        return reflect.SliceOf(elemType), nil
                }</span> else<span class="cov8" title="1"> {
                        size, err := strconv.Atoi(matches[2])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid array size: %s", abiType)
                        }</span>

                        <span class="cov8" title="1">return reflect.ArrayOf(size, elemType), nil</span>
                }
        }
        // Handling integer types
        <span class="cov8" title="1">if matches := reInt.FindStringSubmatch(abiType); matches != nil </span><span class="cov8" title="1">{
                size := 256 // default size
                if matches[2] != "" </span><span class="cov8" title="1">{
                        var err error
                        size, err = strconv.Atoi(matches[2])
                        if err != nil || size &lt;= 0 || size &gt; 256 || size%8 != 0 </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("invalid integer size: %s", abiType)
                        }</span>
                }
                <span class="cov8" title="1">switch size </span>{
                case 8:<span class="cov8" title="1">
                        if matches[1] == "u" </span><span class="cov8" title="1">{
                                return reflect.TypeOf(uint8(0)), nil
                        }</span>
                        <span class="cov8" title="1">return reflect.TypeOf(int8(0)), nil</span>
                case 16:<span class="cov0" title="0">
                        if matches[1] == "u" </span><span class="cov0" title="0">{
                                return reflect.TypeOf(uint16(0)), nil
                        }</span>
                        <span class="cov0" title="0">return reflect.TypeOf(int16(0)), nil</span>
                case 32:<span class="cov0" title="0">
                        if matches[1] == "u" </span><span class="cov0" title="0">{

                                return reflect.TypeOf(uint32(0)), nil
                        }</span>
                        <span class="cov0" title="0">return reflect.TypeOf(int32(0)), nil</span>
                case 64:<span class="cov8" title="1">
                        if matches[1] == "u" </span><span class="cov0" title="0">{

                                return reflect.TypeOf(uint64(0)), nil
                        }</span>
                        <span class="cov8" title="1">return reflect.TypeOf(int64(0)), nil</span>
                default:<span class="cov8" title="1">
                        return reflect.TypeOf(new(big.Int)), nil</span>
                }
        }

        <span class="cov8" title="1">switch abiType </span>{
        case "string":<span class="cov8" title="1">
                return reflect.TypeOf(""), nil</span>
        case "address":<span class="cov8" title="1">
                return reflect.TypeOf(common.Address{}), nil</span>
        case "bool":<span class="cov8" title="1">
                return reflect.TypeOf(false), nil</span>
        case "bytes":<span class="cov8" title="1">
                return reflect.TypeOf([]byte{}), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported ABI type: %s", abiType)</span>
        }
}

func ConvertStringToType(dataType, dataField string) (interface{}, error) <span class="cov8" title="1">{
        // handle array types
        if matches := reArray.FindStringSubmatch(dataType); matches != nil </span><span class="cov8" title="1">{
                arrayType := matches[1]
                arraySize := matches[2]
                dataField = strings.Trim(dataField, "[]")
                fieldlist := strings.Split(dataField, ",")
                var arraySizeInt int
                if arraySize != "" </span><span class="cov8" title="1">{
                        var err error
                        arraySizeInt, err = strconv.Atoi(arraySize)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to convert string to integer for array size: %s", err)
                        }</span>
                        <span class="cov8" title="1">if len(fieldlist) != arraySizeInt </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("array size mismatch: expected %d, got %d", arraySizeInt, len(fieldlist))
                        }</span>
                } else<span class="cov8" title="1"> {
                        arraySizeInt = len(fieldlist)
                }</span>

                <span class="cov8" title="1">reflectype, err := ConvertTypeToReflectType(arrayType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to convert ABI type to reflect type: %s", err)
                }</span>
                <span class="cov8" title="1">slice := reflect.MakeSlice(reflect.SliceOf(reflectype), 0, arraySizeInt)

                for _, field := range fieldlist </span><span class="cov8" title="1">{
                        value, err := ConvertStringToType(arrayType, field)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to convert string to type: %s", err)
                        }</span>
                        <span class="cov8" title="1">slice = reflect.Append(slice, reflect.ValueOf(value))</span>
                }

                <span class="cov8" title="1">return slice.Interface(), nil</span>
        }

        // Handling integer types
        <span class="cov8" title="1">if matches := reInt.FindStringSubmatch(dataType); matches != nil </span><span class="cov8" title="1">{
                value, err := intValue(matches, dataField)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to convert string to integer, err: %v", err)
                }</span>
                <span class="cov8" title="1">return value, nil</span>
        }

        <span class="cov8" title="1">switch dataType </span>{
        case "string":<span class="cov8" title="1">
                return dataField, nil</span>
        case "bool":<span class="cov8" title="1">
                return strconv.ParseBool(dataField)</span>
        case "address":<span class="cov8" title="1">
                if !common.IsHexAddress(dataField) </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid address: %s", dataField)
                }</span>
                <span class="cov8" title="1">return common.HexToAddress(dataField), nil</span>
        case "bytes":<span class="cov8" title="1">
                if strings.HasPrefix(dataField, "0x") </span><span class="cov8" title="1">{
                        return hex.DecodeString(Remove0xPrefix(dataField))
                }</span>
                <span class="cov8" title="1">return []byte(dataField), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported data type: %s", dataType)</span>
        }
}

func sizeOfType(match string) (int, error) <span class="cov8" title="1">{
        if match == "" </span><span class="cov8" title="1">{
                return 256, nil
        }</span>
        <span class="cov8" title="1">num, err := strconv.Atoi(match)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to convert string to integer for data type: %s", err)
        }</span>

        <span class="cov8" title="1">return num, nil</span>
}

func intValue(matches []string, fieldValue string) (interface{}, error) <span class="cov8" title="1">{
        size, err := sizeOfType(matches[2])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert string to integer, err: %v", err)
        }</span>
        <span class="cov8" title="1">fieldValue = strings.TrimSpace(fieldValue)
        Uint := matches[1] == "u"
        switch size </span>{
        case 8, 16, 32, 64:<span class="cov8" title="1">
                if Uint </span><span class="cov8" title="1">{
                        // Use ParseUint for unsigned types
                        value, err := strconv.ParseUint(fieldValue, 10, size)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("failed to convert data field string to unsigned integer, err: %v", err)
                        }</span>
                        <span class="cov8" title="1">switch size </span>{
                        case 8:<span class="cov8" title="1">
                                return uint8(value), nil</span>
                        case 16:<span class="cov8" title="1">
                                return uint16(value), nil</span>
                        case 32:<span class="cov8" title="1">
                                return uint32(value), nil</span>
                        case 64:<span class="cov8" title="1">
                                return uint64(value), nil</span>
                        }
                } else<span class="cov8" title="1"> {
                        // Use ParseInt for signed types
                        value, err := strconv.ParseInt(fieldValue, 10, size)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("failed to convert data field string to integer, err: %v", err)
                        }</span>
                        <span class="cov8" title="1">switch size </span>{
                        case 8:<span class="cov8" title="1">
                                return int8(value), nil</span>
                        case 16:<span class="cov8" title="1">
                                return int16(value), nil</span>
                        case 32:<span class="cov8" title="1">
                                return int32(value), nil</span>
                        case 64:<span class="cov8" title="1">
                                return int64(value), nil</span>
                        }
                }
        default:<span class="cov8" title="1">
                // Handle as big.Int for sizes not matching 8, 16, 32, or 64
                value := new(big.Int)
                value, success := value.SetString(fieldValue, 10)
                if !success </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("could not set string to big.Int for value %s", fieldValue)
                }</span>
                <span class="cov8" title="1">return value, nil</span>
        }
        // This line is unreachable but included for completeness
        <span class="cov0" title="0">return nil, fmt.Errorf("unsupported data type size: %s", matches[2])</span>
}
</pre>
		
		<pre class="file" id="file147" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/registry/data_spec.proto

package types

import (
        fmt "fmt"
        _ "github.com/cosmos/cosmos-proto"
        _ "github.com/cosmos/cosmos-sdk/types/tx/amino"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
        _ "google.golang.org/protobuf/types/known/durationpb"
        io "io"
        math "math"
        math_bits "math/bits"
        time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ABIComponent is a specification for how to interpret abi_components
type ABIComponent struct {
        // name
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // type
        FieldType string `protobuf:"bytes,2,opt,name=field_type,json=fieldType,proto3" json:"field_type,omitempty"`
        // consider taking this recursion out and make it once only
        NestedComponent []*ABIComponent `protobuf:"bytes,3,rep,name=nested_component,json=nestedComponent,proto3" json:"nested_component,omitempty"`
}

func (m *ABIComponent) Reset()         <span class="cov0" title="0">{ *m = ABIComponent{} }</span>
func (m *ABIComponent) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ABIComponent) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ABIComponent) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_8c1d9edbb99f1378, []int{0}
}</span>
func (m *ABIComponent) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ABIComponent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ABIComponent.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ABIComponent) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ABIComponent.Merge(m, src)
}</span>
func (m *ABIComponent) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ABIComponent) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ABIComponent.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ABIComponent proto.InternalMessageInfo

func (m *ABIComponent) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ABIComponent) GetFieldType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.FieldType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ABIComponent) GetNestedComponent() []*ABIComponent <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.NestedComponent
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DataSpec is a specification for how to interpret and aggregate data
type DataSpec struct {
        // ipfs hash of the data spec
        DocumentHash string `protobuf:"bytes,1,opt,name=document_hash,json=documentHash,proto3" json:"document_hash,omitempty"`
        // the value's datatype for decoding the value
        ResponseValueType string `protobuf:"bytes,2,opt,name=response_value_type,json=responseValueType,proto3" json:"response_value_type,omitempty"`
        // the abi components for decoding
        AbiComponents []*ABIComponent `protobuf:"bytes,3,rep,name=abi_components,json=abiComponents,proto3" json:"abi_components,omitempty"`
        // how to aggregate the data (ie. average, median, mode, etc) for aggregating reports and arriving at final value
        AggregationMethod string `protobuf:"bytes,4,opt,name=aggregation_method,json=aggregationMethod,proto3" json:"aggregation_method,omitempty"`
        // address that originally registered the data spec
        Registrar string `protobuf:"bytes,5,opt,name=registrar,proto3" json:"registrar,omitempty"`
        // report_buffer_window specifies the duration of the time window following an initial report
        // during which additional reports can be submitted. This duration acts as a buffer, allowing
        // a collection of related reports in a defined time frame. The window ensures that all
        // pertinent reports are aggregated together before arriving at a final value. This defaults
        // to 0s if not specified.
        // extensions: treat as a golang time.duration, don't allow nil values, don't omit empty values
        ReportBufferWindow time.Duration `protobuf:"bytes,6,opt,name=report_buffer_window,json=reportBufferWindow,proto3,stdduration" json:"report_buffer_window"`
}

func (m *DataSpec) Reset()         <span class="cov0" title="0">{ *m = DataSpec{} }</span>
func (m *DataSpec) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DataSpec) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*DataSpec) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_8c1d9edbb99f1378, []int{1}
}</span>
func (m *DataSpec) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *DataSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_DataSpec.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *DataSpec) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_DataSpec.Merge(m, src)
}</span>
func (m *DataSpec) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *DataSpec) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_DataSpec.DiscardUnknown(m)
}</span>

var xxx_messageInfo_DataSpec proto.InternalMessageInfo

func (m *DataSpec) GetDocumentHash() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DocumentHash
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *DataSpec) GetResponseValueType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ResponseValueType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *DataSpec) GetAbiComponents() []*ABIComponent <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AbiComponents
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *DataSpec) GetAggregationMethod() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AggregationMethod
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *DataSpec) GetRegistrar() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Registrar
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *DataSpec) GetReportBufferWindow() time.Duration <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ReportBufferWindow
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*ABIComponent)(nil), "layer.registry.ABIComponent")
        proto.RegisterType((*DataSpec)(nil), "layer.registry.DataSpec")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/registry/data_spec.proto", fileDescriptor_8c1d9edbb99f1378) }</span>

var fileDescriptor_8c1d9edbb99f1378 = []byte{
        // 475 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x92, 0x31, 0x6f, 0xd3, 0x40,
        0x14, 0xc7, 0xe3, 0xb6, 0x54, 0xe4, 0xda, 0x14, 0x7a, 0x64, 0x70, 0x2b, 0x70, 0xa3, 0xb2, 0x44,
        0xa0, 0xd8, 0x52, 0x91, 0xd8, 0xeb, 0x16, 0x01, 0x03, 0x4b, 0x8a, 0x40, 0xea, 0x62, 0x9d, 0xed,
        0x97, 0xf3, 0x49, 0xf6, 0x3d, 0xeb, 0xee, 0x4c, 0xc9, 0x57, 0x60, 0x62, 0xe4, 0x23, 0x30, 0x32,
        0xf0, 0x21, 0x3a, 0x56, 0x4c, 0x4c, 0x80, 0x92, 0xa1, 0x5f, 0x03, 0xe5, 0x6c, 0x27, 0x61, 0x63,
        0x89, 0xee, 0xfd, 0x7f, 0x2f, 0xff, 0xf7, 0xf7, 0xbd, 0x23, 0x5e, 0xce, 0xa6, 0xa0, 0x02, 0x05,
        0x5c, 0x68, 0xa3, 0xa6, 0x41, 0xca, 0x0c, 0x8b, 0x74, 0x09, 0x89, 0x5f, 0x2a, 0x34, 0x48, 0xf7,
        0x2c, 0xf7, 0x5b, 0x7e, 0xb8, 0xcf, 0x0a, 0x21, 0x31, 0xb0, 0xbf, 0x75, 0xcb, 0xe1, 0x41, 0x82,
        0xba, 0x40, 0x1d, 0xd9, 0x2a, 0xa8, 0x8b, 0x06, 0xf5, 0x39, 0x72, 0xac, 0xf5, 0xc5, 0xa9, 0x51,
        0x3d, 0x8e, 0xc8, 0x73, 0x08, 0x6c, 0x15, 0x57, 0x93, 0x20, 0xad, 0x14, 0x33, 0x02, 0x65, 0xcd,
        0x8f, 0x3f, 0x39, 0x64, 0xf7, 0x34, 0x7c, 0x7d, 0x86, 0x45, 0x89, 0x12, 0xa4, 0xa1, 0x94, 0x6c,
        0x49, 0x56, 0x80, 0xeb, 0x0c, 0x9c, 0x61, 0x77, 0x6c, 0xcf, 0xf4, 0x11, 0x21, 0x13, 0x01, 0x79,
        0x1a, 0x99, 0x69, 0x09, 0xee, 0x86, 0x25, 0x5d, 0xab, 0xbc, 0x9d, 0x96, 0x40, 0x5f, 0x92, 0xfb,
        0x12, 0xb4, 0x81, 0x34, 0x4a, 0x5a, 0x1b, 0x77, 0x73, 0xb0, 0x39, 0xdc, 0x39, 0x79, 0xe8, 0xff,
        0xfb, 0x49, 0xfe, 0xfa, 0xa8, 0xf1, 0xbd, 0xfa, 0x5f, 0x4b, 0xe1, 0xf8, 0x76, 0x83, 0xdc, 0x3d,
        0x67, 0x86, 0x5d, 0x94, 0x90, 0xd0, 0xc7, 0xa4, 0x97, 0x62, 0x52, 0x15, 0x20, 0x4d, 0x94, 0x31,
        0x9d, 0x35, 0x89, 0x76, 0x5b, 0xf1, 0x15, 0xd3, 0x19, 0xf5, 0xc9, 0x03, 0x05, 0xba, 0x44, 0xa9,
        0x21, 0xfa, 0xc0, 0xf2, 0x0a, 0xd6, 0x23, 0xee, 0xb7, 0xe8, 0xdd, 0x82, 0xd8, 0xa8, 0x67, 0x64,
        0x8f, 0xc5, 0x62, 0x95, 0x53, 0xff, 0x57, 0xd0, 0x1e, 0x8b, 0xc5, 0xb2, 0xd2, 0x74, 0x44, 0x28,
        0xe3, 0x5c, 0x01, 0xb7, 0x17, 0x19, 0x15, 0x60, 0x32, 0x4c, 0xdd, 0xad, 0x7a, 0xe6, 0x1a, 0x79,
        0x63, 0x01, 0x7d, 0x4e, 0xba, 0x8d, 0x2d, 0x53, 0xee, 0x9d, 0x45, 0x57, 0xe8, 0xfe, 0xf8, 0x3e,
        0xea, 0x37, 0xdb, 0x3b, 0x4d, 0x53, 0x05, 0x5a, 0x5f, 0x18, 0x25, 0x24, 0x1f, 0xaf, 0x5a, 0xe9,
        0x25, 0xe9, 0x2b, 0x28, 0x51, 0x99, 0x28, 0xae, 0x26, 0x13, 0x50, 0xd1, 0x95, 0x90, 0x29, 0x5e,
        0xb9, 0xdb, 0x03, 0x67, 0xb8, 0x73, 0x72, 0xe0, 0xd7, 0x9b, 0xf5, 0xdb, 0xcd, 0xfa, 0xe7, 0xcd,
        0x66, 0xc3, 0xde, 0xf5, 0xaf, 0xa3, 0xce, 0x97, 0xdf, 0x47, 0xce, 0xd7, 0xdb, 0x6f, 0x4f, 0x9c,
        0x31, 0xad, 0x5d, 0x42, 0x6b, 0xf2, 0xde, 0x7a, 0x84, 0x2f, 0xae, 0x67, 0x9e, 0x73, 0x33, 0xf3,
        0x9c, 0x3f, 0x33, 0xcf, 0xf9, 0x3c, 0xf7, 0x3a, 0x37, 0x73, 0xaf, 0xf3, 0x73, 0xee, 0x75, 0x2e,
        0x9f, 0x72, 0x61, 0xb2, 0x2a, 0xf6, 0x13, 0x2c, 0x02, 0x03, 0x79, 0x8e, 0x6a, 0x24, 0x30, 0xa8,
        0x5f, 0xee, 0xc7, 0xd5, 0xdb, 0x5d, 0x5c, 0xb3, 0x8e, 0xb7, 0xed, 0xf0, 0x67, 0x7f, 0x03, 0x00,
        0x00, 0xff, 0xff, 0x44, 0x86, 0x5c, 0xb7, 0xda, 0x02, 0x00, 0x00,
}

func (m *ABIComponent) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *ABIComponent) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ABIComponent) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.NestedComponent) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.NestedComponent) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.NestedComponent[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintDataSpec(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x1a</span>
                }
        }
        <span class="cov0" title="0">if len(m.FieldType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.FieldType)
                copy(dAtA[i:], m.FieldType)
                i = encodeVarintDataSpec(dAtA, i, uint64(len(m.FieldType)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Name) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintDataSpec(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *DataSpec) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *DataSpec) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *DataSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        n1, err1 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(m.ReportBufferWindow, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.ReportBufferWindow):])
        if err1 != nil </span><span class="cov0" title="0">{
                return 0, err1
        }</span>
        <span class="cov0" title="0">i -= n1
        i = encodeVarintDataSpec(dAtA, i, uint64(n1))
        i--
        dAtA[i] = 0x32
        if len(m.Registrar) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Registrar)
                copy(dAtA[i:], m.Registrar)
                i = encodeVarintDataSpec(dAtA, i, uint64(len(m.Registrar)))
                i--
                dAtA[i] = 0x2a
        }</span>
        <span class="cov0" title="0">if len(m.AggregationMethod) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.AggregationMethod)
                copy(dAtA[i:], m.AggregationMethod)
                i = encodeVarintDataSpec(dAtA, i, uint64(len(m.AggregationMethod)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov0" title="0">if len(m.AbiComponents) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.AbiComponents) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.AbiComponents[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintDataSpec(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x1a</span>
                }
        }
        <span class="cov0" title="0">if len(m.ResponseValueType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ResponseValueType)
                copy(dAtA[i:], m.ResponseValueType)
                i = encodeVarintDataSpec(dAtA, i, uint64(len(m.ResponseValueType)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.DocumentHash) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.DocumentHash)
                copy(dAtA[i:], m.DocumentHash)
                i = encodeVarintDataSpec(dAtA, i, uint64(len(m.DocumentHash)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintDataSpec(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovDataSpec(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *ABIComponent) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Name)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovDataSpec(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.FieldType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovDataSpec(uint64(l))
        }</span>
        <span class="cov0" title="0">if len(m.NestedComponent) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.NestedComponent </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovDataSpec(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *DataSpec) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.DocumentHash)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovDataSpec(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.ResponseValueType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovDataSpec(uint64(l))
        }</span>
        <span class="cov0" title="0">if len(m.AbiComponents) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.AbiComponents </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovDataSpec(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">l = len(m.AggregationMethod)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovDataSpec(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Registrar)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovDataSpec(uint64(l))
        }</span>
        <span class="cov0" title="0">l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.ReportBufferWindow)
        n += 1 + l + sovDataSpec(uint64(l))
        return n</span>
}

func sovDataSpec(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozDataSpec(x uint64) (n int) <span class="cov0" title="0">{
        return sovDataSpec(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *ABIComponent) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowDataSpec
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ABIComponent: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ABIComponent: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDataSpec
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDataSpec
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDataSpec
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field FieldType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDataSpec
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDataSpec
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDataSpec
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.FieldType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field NestedComponent", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDataSpec
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDataSpec
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDataSpec
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.NestedComponent = append(m.NestedComponent, &amp;ABIComponent{})
                        if err := m.NestedComponent[len(m.NestedComponent)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipDataSpec(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDataSpec
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *DataSpec) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowDataSpec
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: DataSpec: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: DataSpec: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DocumentHash", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDataSpec
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDataSpec
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDataSpec
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.DocumentHash = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ResponseValueType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDataSpec
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDataSpec
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDataSpec
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ResponseValueType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AbiComponents", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDataSpec
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDataSpec
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDataSpec
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.AbiComponents = append(m.AbiComponents, &amp;ABIComponent{})
                        if err := m.AbiComponents[len(m.AbiComponents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AggregationMethod", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDataSpec
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDataSpec
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDataSpec
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.AggregationMethod = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 5:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Registrar", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDataSpec
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDataSpec
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDataSpec
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Registrar = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 6:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ReportBufferWindow", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDataSpec
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDataSpec
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDataSpec
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(&amp;m.ReportBufferWindow, dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipDataSpec(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDataSpec
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipDataSpec(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowDataSpec
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowDataSpec
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowDataSpec
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthDataSpec
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupDataSpec
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthDataSpec
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthDataSpec        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowDataSpec          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupDataSpec = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file148" style="display: none">package types

import (
        "encoding/json"
        "fmt"
        "reflect"
        "strings"

        "github.com/ethereum/go-ethereum/accounts/abi"
)

// genesis spot price data spec
func GenesisDataSpec() DataSpec <span class="cov8" title="1">{
        return DataSpec{
                DocumentHash:      "",
                ResponseValueType: "uint256",
                AbiComponents: []*ABIComponent{
                        {Name: "asset", FieldType: "string"},
                        {Name: "currency", FieldType: "string"},
                },
                AggregationMethod: "weighted-median",
                Registrar:         "genesis",
        }
}</span>

func (d DataSpec) EncodeData(querytype, datafields string) ([]byte, error) <span class="cov8" title="1">{
        argMarshller := d.MakeArgMarshaller()
        args := MakeArguments(argMarshller)
        interfacefields := MakePackdata(datafields, argMarshller)
        encodedBytes, err := args.Pack(interfacefields...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to pack arguments: %v", err)
        }</span>

        <span class="cov8" title="1">querydataBytes, err := EncodeWithQuerytype(querytype, encodedBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to encode arguments: %v", err)
        }</span>

        <span class="cov8" title="1">return querydataBytes, nil</span>
}

func (d DataSpec) ValidateValue(value string) error <span class="cov0" title="0">{
        return IsValueDecodable(value, d.ResponseValueType)
}</span>

func (d DataSpec) DecodeValue(value string) (string, error) <span class="cov0" title="0">{
        valueInterface, err := DecodeValue(value, d.ResponseValueType)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Failed to decode value: %v", err)
        }</span>
        <span class="cov0" title="0">valueBytes, err := convertToJSON(valueInterface)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Failed to convert to JSON: %v", err)
        }</span>
        <span class="cov0" title="0">return string(valueBytes), nil</span>
}

func (d DataSpec) MakeArgMarshaller() []abi.ArgumentMarshaling <span class="cov8" title="1">{
        argMrsh := []abi.ArgumentMarshaling{}
        for _, cmp := range d.AbiComponents </span><span class="cov8" title="1">{
                _argMrsh := abi.ArgumentMarshaling{
                        Name: cmp.Name,
                        Type: cmp.FieldType,
                }
                if cmp.FieldType == "tuple" || cmp.FieldType == "tuple[]" </span><span class="cov8" title="1">{
                        for _, cmp2 := range cmp.NestedComponent </span><span class="cov8" title="1">{
                                _argMrsh_ := abi.ArgumentMarshaling{
                                        Name: cmp2.Name,
                                        Type: cmp2.FieldType,
                                }
                                _argMrsh.Components = append(_argMrsh.Components, _argMrsh_)
                        }</span>
                }
                <span class="cov8" title="1">argMrsh = append(argMrsh, _argMrsh)</span>
        }
        <span class="cov8" title="1">return argMrsh</span>
}

func MakeArguments(argMrsh []abi.ArgumentMarshaling) abi.Arguments <span class="cov8" title="1">{
        var arguments abi.Arguments
        for _, arg := range argMrsh </span><span class="cov8" title="1">{
                // make struct for each
                argType, err := abi.NewType(arg.Type, arg.Type, arg.Components)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov8" title="1">arguments = append(arguments, abi.Argument{
                        Name: arg.Name,
                        Type: argType,
                })</span>
        }
        <span class="cov8" title="1">return arguments</span>
}

func MakePackdata(fields string, argMrsh []abi.ArgumentMarshaling) []interface{} <span class="cov8" title="1">{
        var data interface{}
        err := json.Unmarshal([]byte(fields), &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("Error unmarshalling JSON: %v", err))</span>
        }
        <span class="cov8" title="1">list, ok := data.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                panic(fmt.Errorf("Error asserting data to a slice of interfaces"))</span>
        }
        // check length should be the same
        <span class="cov8" title="1">if len(list) != len(argMrsh) </span><span class="cov0" title="0">{
                panic(fmt.Errorf("Length of fields and argMrsh should be the same"))</span>
        }
        <span class="cov8" title="1">var interfaceFields []interface{}
        for i, item := range argMrsh </span><span class="cov8" title="1">{
                if len(item.Components) == 0 </span><span class="cov8" title="1">{
                        interfaceField, err := ConvertStringToType(item.Type, list[i].(string))
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Errorf("Failed to create new ABI type: %v", err))</span>
                        }
                        <span class="cov8" title="1">interfaceFields = append(interfaceFields, interfaceField)</span>
                } else<span class="cov8" title="1"> {
                        // crete structs and populate
                        if item.Type == "tuple" </span><span class="cov8" title="1">{
                                interfaceField := createAndPopulateStruct(list[i].([]interface{}), item.Components)
                                interfaceFields = append(interfaceFields, interfaceField.Interface())
                        }</span>
                        <span class="cov8" title="1">if item.Type == "tuple[]" </span><span class="cov8" title="1">{
                                interfaceField := createAndPopulateStructSlice(list[i], item.Components)
                                interfaceFields = append(interfaceFields, interfaceField.Interface())

                        }</span>
                }
        }
        <span class="cov8" title="1">return interfaceFields</span>
}

// createAndPopulateStructSlice creates a slice of structs from interface fields and ABI components.
func createAndPopulateStructSlice(interfaceFields interface{}, components []abi.ArgumentMarshaling) reflect.Value <span class="cov8" title="1">{
        nestedInterface := interfaceFields.([]interface{})
        structType := reflect.TypeOf(createAndPopulateStruct([]interface{}{}, components).Interface())
        structSlice := reflect.MakeSlice(reflect.SliceOf(structType), 0, len(nestedInterface))

        for _, instanceFields := range nestedInterface </span><span class="cov8" title="1">{
                newStruct := createAndPopulateStruct(instanceFields.([]interface{}), components)
                structSlice = reflect.Append(structSlice, newStruct)
        }</span>

        <span class="cov8" title="1">return structSlice</span>
}

// Convert component names to title case and create a single struct populated with field values.
func createAndPopulateStruct(fields []interface{}, components []abi.ArgumentMarshaling) reflect.Value <span class="cov8" title="1">{
        structFields := make([]reflect.StructField, len(components))
        for i, c := range components </span><span class="cov8" title="1">{
                // Ensure component names are in title case
                compName := strings.Title(c.Name)
                fieldType, err := ConvertTypeToReflectType(c.Type)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("Failed to create new ABI type: %v", err))</span>
                }
                <span class="cov8" title="1">structFields[i] = reflect.StructField{
                        Name: compName,
                        Type: fieldType,
                }</span>
        }
        <span class="cov8" title="1">structType := reflect.StructOf(structFields)
        newStruct := reflect.New(structType).Elem()

        for i, fieldValue := range fields </span><span class="cov8" title="1">{
                fieldValue, err := ConvertStringToType(components[i].Type, fieldValue.(string))
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("Failed to convert string to type: %v", err))</span>
                }
                <span class="cov8" title="1">fieldVal := newStruct.Field(i)
                if !fieldVal.IsValid() </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("No such field: %s", components[i].Name))</span>
                }
                <span class="cov8" title="1">val := reflect.ValueOf(fieldValue)
                if !val.Type().AssignableTo(fieldVal.Type()) </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("Type mismatch for field: %s", components[i].Name))</span>
                }
                <span class="cov8" title="1">fieldVal.Set(val)</span>
        }
        <span class="cov8" title="1">return newStruct</span>
}
</pre>
		
		<pre class="file" id="file149" style="display: none">package types

import (
        "encoding/hex"
        "fmt"
        "strings"

        "github.com/ethereum/go-ethereum/accounts/abi"
)

func IsValueDecodable(value, datatype string) error <span class="cov0" title="0">{
        _, err := DecodeValue(value, datatype)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unpack value: %v", err)
        }</span>
        // fmt.Println("Decoded value: ", result[0]) todo: do we still need this ?
        <span class="cov0" title="0">return nil</span>
}

func DecodeValue(value, datatype string) ([]interface{}, error) <span class="cov8" title="1">{
        value = Remove0xPrefix(value)
        valueBytes, err := hex.DecodeString(value)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode value string: %v", err)
        }</span>

        <span class="cov8" title="1">comp := []abi.ArgumentMarshaling{}
        if strings.Contains(datatype, "(") &amp;&amp; strings.Contains(datatype, ")") </span><span class="cov8" title="1">{
                untrimmed := datatype
                if strings.HasSuffix(datatype, "[]") </span><span class="cov8" title="1">{
                        datatype = "tuple[]"
                        untrimmed = untrimmed[:len(untrimmed)-2]
                }</span> else<span class="cov8" title="1"> {
                        datatype = "tuple"
                }</span>
                <span class="cov8" title="1">types := strings.Split(strings.Trim(untrimmed, "()"), ",")

                _comp := abi.ArgumentMarshaling{Type: datatype, Name: "Main"}

                for i, element := range types </span><span class="cov8" title="1">{
                        _comp.Components = append(_comp.Components, abi.ArgumentMarshaling{
                                Type: element, Name: "Value" + fmt.Sprintf("%d", i),
                        })
                }</span>
                <span class="cov8" title="1">comp = append(comp, _comp)
                args := MakeArguments(comp)

                return args.Unpack(valueBytes)</span>
        }

        <span class="cov8" title="1">argType, err := abi.NewType(datatype, datatype, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create new ABI type when decoding value: %v", err)
        }</span>
        <span class="cov8" title="1">arg := abi.Argument{
                Type: argType,
        }

        args := abi.Arguments{arg}

        return args.Unpack(valueBytes)</span>
}

// Decodes query data bytes to query type and data fields
func DecodeQueryType(data []byte) (string, []byte, error) <span class="cov8" title="1">{
        // Create an ABI arguments object based on the types
        strArg, err := abi.NewType("string", "string", nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("failed to create string ABI type when decoding query type: %v", err)
        }</span>
        <span class="cov8" title="1">bytesArg, err := abi.NewType("bytes", "bytes", nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("failed to create bytes ABI type when decoding query type: %v", err)
        }</span>
        <span class="cov8" title="1">args := abi.Arguments{
                abi.Argument{Type: strArg},
                abi.Argument{Type: bytesArg},
        }
        result, err := args.Unpack(data)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("failed to unpack query type: %v", err)
        }</span>
        <span class="cov8" title="1">return result[0].(string), result[1].([]byte), nil</span>
}

func DecodeParamtypes(data []byte, component []*ABIComponent) (string, error) <span class="cov8" title="1">{
        var args abi.Arguments
        for _, comp := range component </span><span class="cov8" title="1">{
                marshaling := convertToArgumentMarshaling(*comp)
                argType, err := abi.NewType(marshaling.Type, marshaling.Type, marshaling.Components)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov8" title="1">args = append(args, abi.Argument{
                        Name: marshaling.Name,
                        Type: argType,
                })</span>
        }

        <span class="cov8" title="1">result, err := args.Unpack(data)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to unpack query data into its fields: %v", err)
        }</span>

        <span class="cov8" title="1">return convertToJSON(result)</span>

}

func convertToArgumentMarshaling(comp ABIComponent) abi.ArgumentMarshaling <span class="cov8" title="1">{
        var nestedArgMarshallings []abi.ArgumentMarshaling
        for _, nestedComp := range comp.NestedComponent </span><span class="cov8" title="1">{
                nestedArgMarshaling := convertToArgumentMarshaling(*nestedComp)
                nestedArgMarshallings = append(nestedArgMarshallings, nestedArgMarshaling)
        }</span>

        <span class="cov8" title="1">return abi.ArgumentMarshaling{
                Name:       comp.Name,
                Type:       comp.FieldType,
                Components: nestedArgMarshallings,
        }</span>
}
</pre>
		
		<pre class="file" id="file150" style="display: none">package types

import (
        "fmt"

        "github.com/ethereum/go-ethereum/accounts/abi"
)

func EncodeWithQuerytype(querytype string, databytes []byte) ([]byte, error) <span class="cov8" title="1">{
        strArg, err := abi.NewType("string", "string", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create new ABI type when encoding query type: %v", err)
        }</span>
        <span class="cov8" title="1">bytesArg, err := abi.NewType("bytes", "bytes", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create new ABI type when encoding with query type: %v", err)
        }</span>
        <span class="cov8" title="1">args := abi.Arguments{
                abi.Argument{Type: strArg},
                abi.Argument{Type: bytesArg},
        }
        return args.Pack(querytype, databytes)</span>
}
</pre>
		
		<pre class="file" id="file151" style="display: none">package types

// this line is used by starport scaffolding # genesis/types/import

// DefaultIndex is the default global index
const DefaultIndex uint64 = 1

// DefaultGenesis returns the default genesis state
func DefaultGenesis() *GenesisState <span class="cov8" title="1">{
        return &amp;GenesisState{
                // this line is used by starport scaffolding # genesis/types/default
                Params:   DefaultParams(),
                Dataspec: GenesisDataSpec(),
        }
}</span>

// Validate performs basic genesis state validation returning an error upon any
// failure.
func (gs GenesisState) Validate() error <span class="cov8" title="1">{
        // this line is used by starport scaffolding # genesis/types/validate

        return gs.Params.Validate()
}</span>
</pre>
		
		<pre class="file" id="file152" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/registry/genesis.proto

package types

import (
        fmt "fmt"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GenesisState defines the registry module's genesis state.
type GenesisState struct {
        // params defines all the paramaters of the registry module.
        Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
        // Initial data specs
        Dataspec DataSpec `protobuf:"bytes,2,opt,name=dataspec,proto3" json:"dataspec"`
}

func (m *GenesisState) Reset()         <span class="cov0" title="0">{ *m = GenesisState{} }</span>
func (m *GenesisState) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GenesisState) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GenesisState) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_405fedac4fcc0287, []int{0}
}</span>
func (m *GenesisState) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *GenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_GenesisState.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *GenesisState) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GenesisState.Merge(m, src)
}</span>
func (m *GenesisState) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *GenesisState) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GenesisState.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GenesisState proto.InternalMessageInfo

func (m *GenesisState) GetParams() Params <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Params
        }</span>
        <span class="cov0" title="0">return Params{}</span>
}

func (m *GenesisState) GetDataspec() DataSpec <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Dataspec
        }</span>
        <span class="cov0" title="0">return DataSpec{}</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*GenesisState)(nil), "layer.registry.GenesisState")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/registry/genesis.proto", fileDescriptor_405fedac4fcc0287) }</span>

var fileDescriptor_405fedac4fcc0287 = []byte{
        // 236 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0xc9, 0x49, 0xac, 0x4c,
        0x2d, 0xd2, 0x2f, 0x4a, 0x4d, 0xcf, 0x2c, 0x2e, 0x29, 0xaa, 0xd4, 0x4f, 0x4f, 0xcd, 0x4b, 0x2d,
        0xce, 0x2c, 0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x03, 0xcb, 0xea, 0xc1, 0x64, 0xa5,
        0x44, 0xd2, 0xf3, 0xd3, 0xf3, 0xc1, 0x52, 0xfa, 0x20, 0x16, 0x44, 0x95, 0x94, 0x1c, 0x9a, 0x19,
        0x29, 0x89, 0x25, 0x89, 0xf1, 0xc5, 0x05, 0xa9, 0xc9, 0x50, 0x79, 0x69, 0x34, 0xf9, 0x82, 0xc4,
        0xa2, 0xc4, 0x5c, 0xa8, 0x15, 0x4a, 0x0d, 0x8c, 0x5c, 0x3c, 0xee, 0x10, 0x4b, 0x83, 0x4b, 0x12,
        0x4b, 0x52, 0x85, 0x4c, 0xb8, 0xd8, 0x20, 0x0a, 0x24, 0x18, 0x15, 0x18, 0x35, 0xb8, 0x8d, 0xc4,
        0xf4, 0x50, 0x1d, 0xa1, 0x17, 0x00, 0x96, 0x75, 0x62, 0x39, 0x71, 0x4f, 0x9e, 0x21, 0x08, 0xaa,
        0x56, 0xc8, 0x8a, 0x8b, 0x03, 0x64, 0x2d, 0xc8, 0x56, 0x09, 0x26, 0xb0, 0x3e, 0x09, 0x74, 0x7d,
        0x2e, 0x89, 0x25, 0x89, 0xc1, 0x05, 0xa9, 0xc9, 0x50, 0x9d, 0x70, 0xf5, 0x4e, 0xae, 0x27, 0x1e,
        0xc9, 0x31, 0x5e, 0x78, 0x24, 0xc7, 0xf8, 0xe0, 0x91, 0x1c, 0xe3, 0x84, 0xc7, 0x72, 0x0c, 0x17,
        0x1e, 0xcb, 0x31, 0xdc, 0x78, 0x2c, 0xc7, 0x10, 0xa5, 0x9d, 0x9e, 0x59, 0x92, 0x51, 0x9a, 0xa4,
        0x97, 0x9c, 0x9f, 0xab, 0x5f, 0x92, 0x9a, 0x93, 0x93, 0x5f, 0xa4, 0x9b, 0x99, 0xaf, 0x0f, 0xf1,
        0x4e, 0x05, 0xc2, 0x43, 0x25, 0x95, 0x05, 0xa9, 0xc5, 0x49, 0x6c, 0x60, 0x0f, 0x19, 0x03, 0x02,
        0x00, 0x00, 0xff, 0xff, 0xd9, 0xee, 0x75, 0x9d, 0x53, 0x01, 0x00, 0x00,
}

func (m *GenesisState) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *GenesisState) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *GenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Dataspec.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintGenesis(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x12
        </span><span class="cov0" title="0">{
                size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintGenesis(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func encodeVarintGenesis(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovGenesis(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *GenesisState) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Params.Size()
        n += 1 + l + sovGenesis(uint64(l))
        l = m.Dataspec.Size()
        n += 1 + l + sovGenesis(uint64(l))
        return n</span>
}

func sovGenesis(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozGenesis(x uint64) (n int) <span class="cov0" title="0">{
        return sovGenesis(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *GenesisState) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowGenesis
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Dataspec", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Dataspec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipGenesis(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipGenesis(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowGenesis
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupGenesis
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthGenesis
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthGenesis        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowGenesis          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupGenesis = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file153" style="display: none">package types

import (
        "encoding/json"
)

func Remove0xPrefix(hexString string) string <span class="cov8" title="1">{
        if Has0xPrefix(hexString) </span><span class="cov8" title="1">{
                hexString = hexString[2:]
        }</span>
        <span class="cov8" title="1">return hexString</span>
}

// has0xPrefix validates str begins with '0x' or '0X'.
// From: https://github.com/ethereum/go-ethereum/blob/5c6f4b9f0d4270fcc56df681bf003e6a74f11a6b/common/bytes.go#L51
func Has0xPrefix(str string) bool <span class="cov8" title="1">{
        return len(str) &gt;= 2 &amp;&amp; str[0] == '0' &amp;&amp; (str[1] == 'x' || str[1] == 'X')
}</span>

// convertToJSON converts a slice of interfaces into a JSON string.
func convertToJSON(slice []interface{}) (string, error) <span class="cov8" title="1">{
        jsonResult, err := json.Marshal(slice)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return string(jsonResult), nil</span>
}

// check queryId is valid ie 32 bytes
func IsQueryId64chars(queryId string) bool <span class="cov8" title="1">{
        queryId = Remove0xPrefix(queryId)
        if len(queryId) != 64 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file154" style="display: none">package types

import (
        context "context"
)

// combine multiple registry hooks, all hook functions are run in array sequence
var _ RegistryHooks = &amp;MultiRegistryHooks{}

type MultiRegistryHooks []RegistryHooks

func NewMultiRegistryHooks(hooks ...RegistryHooks) MultiRegistryHooks <span class="cov0" title="0">{
        return hooks
}</span>

func (h MultiRegistryHooks) AfterDataSpecUpdated(ctx context.Context, querytype string, dataspec DataSpec) error <span class="cov0" title="0">{
        for i := range h </span><span class="cov0" title="0">{
                if err := h[i].AfterDataSpecUpdated(ctx, querytype, dataspec); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file155" style="display: none">package types

import (
        errorsmod "cosmossdk.io/errors"
        sdk "github.com/cosmos/cosmos-sdk/types"
        sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
)

const TypeMsgRegisterSpec = "register_spec"

var _ sdk.Msg = &amp;MsgRegisterSpec{}

func NewMsgRegisterSpec(registrar string, queryType string, spec *DataSpec) *MsgRegisterSpec <span class="cov0" title="0">{
        return &amp;MsgRegisterSpec{
                Registrar: registrar,
                QueryType: queryType,
                Spec:      *spec,
        }
}</span>

func (msg *MsgRegisterSpec) Route() string <span class="cov0" title="0">{
        return RouterKey
}</span>

func (msg *MsgRegisterSpec) Type() string <span class="cov0" title="0">{
        return TypeMsgRegisterSpec
}</span>

func (msg *MsgRegisterSpec) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        creator, err := sdk.AccAddressFromBech32(msg.Registrar)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return []sdk.AccAddress{creator}</span>
}

func (msg *MsgRegisterSpec) ValidateBasic() error <span class="cov8" title="1">{
        _, err := sdk.AccAddressFromBech32(msg.Registrar)
        if err != nil </span><span class="cov8" title="1">{
                return errorsmod.Wrapf(sdkerrors.ErrInvalidAddress, "invalid creator address (%s)", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file156" style="display: none">package types

import (
        paramtypes "github.com/cosmos/cosmos-sdk/x/params/types"
        "gopkg.in/yaml.v2"
)

var _ paramtypes.ParamSet = (*Params)(nil)

// ParamKeyTable the param key table for launch module
func ParamKeyTable() paramtypes.KeyTable <span class="cov0" title="0">{
        return paramtypes.NewKeyTable().RegisterParamSet(&amp;Params{})
}</span>

// NewParams creates a new Params instance
func NewParams() Params <span class="cov8" title="1">{
        return Params{}
}</span>

// DefaultParams returns a default set of parameters
func DefaultParams() Params <span class="cov8" title="1">{
        return NewParams()
}</span>

// ParamSetPairs get the params.ParamSet
func (p *Params) ParamSetPairs() paramtypes.ParamSetPairs <span class="cov0" title="0">{
        return paramtypes.ParamSetPairs{}
}</span>

// Validate validates the set of params
func (p Params) Validate() error <span class="cov8" title="1">{
        return nil
}</span>

// String implements the Stringer interface.
func (p Params) String() string <span class="cov0" title="0">{
        out, _ := yaml.Marshal(p)
        return string(out)
}</span>
</pre>
		
		<pre class="file" id="file157" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/registry/params.proto

package types

import (
        fmt "fmt"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines the parameters for the module.
type Params struct {
}

func (m *Params) Reset()      <span class="cov0" title="0">{ *m = Params{} }</span>
func (*Params) ProtoMessage() {<span class="cov0" title="0">}</span>
func (*Params) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_d18d5cb1646fc2f2, []int{0}
}</span>
func (m *Params) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Params.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Params) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Params.Merge(m, src)
}</span>
func (m *Params) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Params) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Params.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Params proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Params)(nil), "layer.registry.Params")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/registry/params.proto", fileDescriptor_d18d5cb1646fc2f2) }</span>

var fileDescriptor_d18d5cb1646fc2f2 = []byte{
        // 152 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0xce, 0x49, 0xac, 0x4c,
        0x2d, 0xd2, 0x2f, 0x4a, 0x4d, 0xcf, 0x2c, 0x2e, 0x29, 0xaa, 0xd4, 0x2f, 0x48, 0x2c, 0x4a, 0xcc,
        0x2d, 0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x03, 0x4b, 0xea, 0xc1, 0x24, 0xa5, 0x44,
        0xd2, 0xf3, 0xd3, 0xf3, 0xc1, 0x52, 0xfa, 0x20, 0x16, 0x44, 0x95, 0x12, 0x1f, 0x17, 0x5b, 0x00,
        0x58, 0x97, 0x15, 0xcb, 0x8c, 0x05, 0xf2, 0x0c, 0x4e, 0xae, 0x27, 0x1e, 0xc9, 0x31, 0x5e, 0x78,
        0x24, 0xc7, 0xf8, 0xe0, 0x91, 0x1c, 0xe3, 0x84, 0xc7, 0x72, 0x0c, 0x17, 0x1e, 0xcb, 0x31, 0xdc,
        0x78, 0x2c, 0xc7, 0x10, 0xa5, 0x9d, 0x9e, 0x59, 0x92, 0x51, 0x9a, 0xa4, 0x97, 0x9c, 0x9f, 0xab,
        0x5f, 0x92, 0x9a, 0x93, 0x93, 0x5f, 0xa4, 0x9b, 0x99, 0xaf, 0x0f, 0x71, 0x41, 0x05, 0xc2, 0x0d,
        0x25, 0x95, 0x05, 0xa9, 0xc5, 0x49, 0x6c, 0x60, 0xd3, 0x8d, 0x01, 0x01, 0x00, 0x00, 0xff, 0xff,
        0x4b, 0x97, 0xd9, 0x7b, 0xa2, 0x00, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func encodeVarintParams(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovParams(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Params) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func sovParams(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozParams(x uint64) (n int) <span class="cov0" title="0">{
        return sovParams(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Params) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Params: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipParams(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipParams(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupParams
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthParams
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthParams        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowParams          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupParams = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file158" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/registry/query.proto

package types

import (
        context "context"
        fmt "fmt"
        _ "github.com/cosmos/gogoproto/gogoproto"
        grpc1 "github.com/cosmos/gogoproto/grpc"
        proto "github.com/cosmos/gogoproto/proto"
        _ "google.golang.org/genproto/googleapis/api/annotations"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QueryParamsRequest is request type for the Query/Params RPC method.
type QueryParamsRequest struct {
}

func (m *QueryParamsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryParamsRequest{} }</span>
func (m *QueryParamsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryParamsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryParamsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6ea550dd9a444afe, []int{0}
}</span>
func (m *QueryParamsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryParamsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryParamsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsRequest.Merge(m, src)
}</span>
func (m *QueryParamsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryParamsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryParamsRequest proto.InternalMessageInfo

// QueryParamsResponse is response type for the Query/Params RPC method.
type QueryParamsResponse struct {
        // params holds all the parameters of this module.
        Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
}

func (m *QueryParamsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryParamsResponse{} }</span>
func (m *QueryParamsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryParamsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryParamsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6ea550dd9a444afe, []int{1}
}</span>
func (m *QueryParamsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryParamsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryParamsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsResponse.Merge(m, src)
}</span>
func (m *QueryParamsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryParamsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryParamsResponse proto.InternalMessageInfo

func (m *QueryParamsResponse) GetParams() Params <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Params
        }</span>
        <span class="cov0" title="0">return Params{}</span>
}

// QueryGetDataSpecRequest is request type for the Query/GetDataSpec RPC method.
type QueryGetDataSpecRequest struct {
        // queryType is the key to fetch a the corresponding data spec.
        QueryType string `protobuf:"bytes,1,opt,name=query_type,json=queryType,proto3" json:"query_type,omitempty"`
}

func (m *QueryGetDataSpecRequest) Reset()         <span class="cov0" title="0">{ *m = QueryGetDataSpecRequest{} }</span>
func (m *QueryGetDataSpecRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetDataSpecRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetDataSpecRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6ea550dd9a444afe, []int{2}
}</span>
func (m *QueryGetDataSpecRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetDataSpecRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetDataSpecRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetDataSpecRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetDataSpecRequest.Merge(m, src)
}</span>
func (m *QueryGetDataSpecRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetDataSpecRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetDataSpecRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetDataSpecRequest proto.InternalMessageInfo

func (m *QueryGetDataSpecRequest) GetQueryType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// QueryGetDataSpecResponse is response type for the Query/GetDataSpec RPC method.
type QueryGetDataSpecResponse struct {
        // spec is the data spec corresponding to the query type.
        Spec *DataSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
}

func (m *QueryGetDataSpecResponse) Reset()         <span class="cov0" title="0">{ *m = QueryGetDataSpecResponse{} }</span>
func (m *QueryGetDataSpecResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGetDataSpecResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGetDataSpecResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6ea550dd9a444afe, []int{3}
}</span>
func (m *QueryGetDataSpecResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGetDataSpecResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGetDataSpecResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGetDataSpecResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetDataSpecResponse.Merge(m, src)
}</span>
func (m *QueryGetDataSpecResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGetDataSpecResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGetDataSpecResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGetDataSpecResponse proto.InternalMessageInfo

func (m *QueryGetDataSpecResponse) GetSpec() *DataSpec <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Spec
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// QueryDecodeQuerydataRequest is request type for the Query/DecodeQuerydata RPC method.
type QueryDecodeQuerydataRequest struct {
        // query_data is the query data hex string to be decoded.
        QueryData []byte `protobuf:"bytes,1,opt,name=query_data,json=queryData,proto3" json:"query_data,omitempty"`
}

func (m *QueryDecodeQuerydataRequest) Reset()         <span class="cov0" title="0">{ *m = QueryDecodeQuerydataRequest{} }</span>
func (m *QueryDecodeQuerydataRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryDecodeQuerydataRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryDecodeQuerydataRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6ea550dd9a444afe, []int{4}
}</span>
func (m *QueryDecodeQuerydataRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryDecodeQuerydataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryDecodeQuerydataRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryDecodeQuerydataRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryDecodeQuerydataRequest.Merge(m, src)
}</span>
func (m *QueryDecodeQuerydataRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryDecodeQuerydataRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryDecodeQuerydataRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryDecodeQuerydataRequest proto.InternalMessageInfo

func (m *QueryDecodeQuerydataRequest) GetQueryData() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryData
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// QueryDecodeQuerydataResponse is response type for the Query/DecodeQuerydata RPC method.
type QueryDecodeQuerydataResponse struct {
        // spec is the decoded json represention of the query data hex string.
        Spec string `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
}

func (m *QueryDecodeQuerydataResponse) Reset()         <span class="cov0" title="0">{ *m = QueryDecodeQuerydataResponse{} }</span>
func (m *QueryDecodeQuerydataResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryDecodeQuerydataResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryDecodeQuerydataResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6ea550dd9a444afe, []int{5}
}</span>
func (m *QueryDecodeQuerydataResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryDecodeQuerydataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryDecodeQuerydataResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryDecodeQuerydataResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryDecodeQuerydataResponse.Merge(m, src)
}</span>
func (m *QueryDecodeQuerydataResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryDecodeQuerydataResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryDecodeQuerydataResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryDecodeQuerydataResponse proto.InternalMessageInfo

func (m *QueryDecodeQuerydataResponse) GetSpec() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Spec
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// QueryGenerateQuerydataRequest is request type for the Query/GenerateQuerydata RPC method.
type QueryGenerateQuerydataRequest struct {
        // querytype for which query_data is to be generated.
        Querytype string `protobuf:"bytes,1,opt,name=querytype,proto3" json:"querytype,omitempty"`
        // parameters for which query_data is to be generated.
        Parameters string `protobuf:"bytes,2,opt,name=parameters,proto3" json:"parameters,omitempty"`
}

func (m *QueryGenerateQuerydataRequest) Reset()         <span class="cov0" title="0">{ *m = QueryGenerateQuerydataRequest{} }</span>
func (m *QueryGenerateQuerydataRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGenerateQuerydataRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGenerateQuerydataRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6ea550dd9a444afe, []int{6}
}</span>
func (m *QueryGenerateQuerydataRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGenerateQuerydataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGenerateQuerydataRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGenerateQuerydataRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGenerateQuerydataRequest.Merge(m, src)
}</span>
func (m *QueryGenerateQuerydataRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGenerateQuerydataRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGenerateQuerydataRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGenerateQuerydataRequest proto.InternalMessageInfo

func (m *QueryGenerateQuerydataRequest) GetQuerytype() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Querytype
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *QueryGenerateQuerydataRequest) GetParameters() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Parameters
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// QueryGenerateQuerydataResponse is response type for the Query/GenerateQuerydata RPC method.
type QueryGenerateQuerydataResponse struct {
        // query_data is the generated query_data hex string.
        QueryData []byte `protobuf:"bytes,1,opt,name=query_data,json=queryData,proto3" json:"query_data,omitempty"`
}

func (m *QueryGenerateQuerydataResponse) Reset()         <span class="cov0" title="0">{ *m = QueryGenerateQuerydataResponse{} }</span>
func (m *QueryGenerateQuerydataResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryGenerateQuerydataResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryGenerateQuerydataResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6ea550dd9a444afe, []int{7}
}</span>
func (m *QueryGenerateQuerydataResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryGenerateQuerydataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryGenerateQuerydataResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryGenerateQuerydataResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryGenerateQuerydataResponse.Merge(m, src)
}</span>
func (m *QueryGenerateQuerydataResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryGenerateQuerydataResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryGenerateQuerydataResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryGenerateQuerydataResponse proto.InternalMessageInfo

func (m *QueryGenerateQuerydataResponse) GetQueryData() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryData
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// QueryDecodeValueRequest is request type for the Query/DecodeValue RPC method.
type QueryDecodeValueRequest struct {
        // queryType is the key to fetch a the corresponding data spec.
        QueryType string `protobuf:"bytes,1,opt,name=queryType,proto3" json:"queryType,omitempty"`
        // value is the value hex string to be decoded.
        Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *QueryDecodeValueRequest) Reset()         <span class="cov0" title="0">{ *m = QueryDecodeValueRequest{} }</span>
func (m *QueryDecodeValueRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryDecodeValueRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryDecodeValueRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6ea550dd9a444afe, []int{8}
}</span>
func (m *QueryDecodeValueRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryDecodeValueRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryDecodeValueRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryDecodeValueRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryDecodeValueRequest.Merge(m, src)
}</span>
func (m *QueryDecodeValueRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryDecodeValueRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryDecodeValueRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryDecodeValueRequest proto.InternalMessageInfo

func (m *QueryDecodeValueRequest) GetQueryType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *QueryDecodeValueRequest) GetValue() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Value
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// QueryDecodeValueResponse is response type for the Query/DecodeValue RPC method.
type QueryDecodeValueResponse struct {
        // decodedValue is the decoded value of the hex string.
        DecodedValue string `protobuf:"bytes,1,opt,name=decodedValue,proto3" json:"decodedValue,omitempty"`
}

func (m *QueryDecodeValueResponse) Reset()         <span class="cov0" title="0">{ *m = QueryDecodeValueResponse{} }</span>
func (m *QueryDecodeValueResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryDecodeValueResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryDecodeValueResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6ea550dd9a444afe, []int{9}
}</span>
func (m *QueryDecodeValueResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryDecodeValueResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryDecodeValueResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryDecodeValueResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryDecodeValueResponse.Merge(m, src)
}</span>
func (m *QueryDecodeValueResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryDecodeValueResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryDecodeValueResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryDecodeValueResponse proto.InternalMessageInfo

func (m *QueryDecodeValueResponse) GetDecodedValue() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DecodedValue
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*QueryParamsRequest)(nil), "layer.registry.QueryParamsRequest")
        proto.RegisterType((*QueryParamsResponse)(nil), "layer.registry.QueryParamsResponse")
        proto.RegisterType((*QueryGetDataSpecRequest)(nil), "layer.registry.QueryGetDataSpecRequest")
        proto.RegisterType((*QueryGetDataSpecResponse)(nil), "layer.registry.QueryGetDataSpecResponse")
        proto.RegisterType((*QueryDecodeQuerydataRequest)(nil), "layer.registry.QueryDecodeQuerydataRequest")
        proto.RegisterType((*QueryDecodeQuerydataResponse)(nil), "layer.registry.QueryDecodeQuerydataResponse")
        proto.RegisterType((*QueryGenerateQuerydataRequest)(nil), "layer.registry.QueryGenerateQuerydataRequest")
        proto.RegisterType((*QueryGenerateQuerydataResponse)(nil), "layer.registry.QueryGenerateQuerydataResponse")
        proto.RegisterType((*QueryDecodeValueRequest)(nil), "layer.registry.QueryDecodeValueRequest")
        proto.RegisterType((*QueryDecodeValueResponse)(nil), "layer.registry.QueryDecodeValueResponse")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/registry/query.proto", fileDescriptor_6ea550dd9a444afe) }</span>

var fileDescriptor_6ea550dd9a444afe = []byte{
        // 624 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x94, 0x4d, 0x6b, 0x13, 0x5d,
        0x14, 0xc7, 0x33, 0xa5, 0x0d, 0xf4, 0xb4, 0x3c, 0x0f, 0x5e, 0x43, 0x0d, 0xd3, 0x74, 0x94, 0xeb,
        0xc2, 0x62, 0x93, 0x19, 0x89, 0x0a, 0x05, 0xdf, 0xa0, 0x56, 0x14, 0x44, 0xd0, 0x18, 0x5c, 0x08,
        0x12, 0x6e, 0x93, 0xcb, 0x18, 0x48, 0x73, 0x27, 0x33, 0x37, 0x62, 0x28, 0xd9, 0xf8, 0x01, 0x44,
        0xd0, 0x95, 0x5b, 0x3f, 0x84, 0x5f, 0xa1, 0xcb, 0x82, 0x1b, 0x57, 0x22, 0x89, 0x1f, 0x44, 0xe6,
        0xdc, 0x93, 0x26, 0x99, 0x99, 0xd8, 0xee, 0x26, 0xe7, 0xe5, 0x7f, 0x7e, 0xf7, 0xbc, 0x04, 0xec,
        0x8e, 0x18, 0xc8, 0xd0, 0x0b, 0xa5, 0xdf, 0x8e, 0x74, 0x38, 0xf0, 0x7a, 0x7d, 0x19, 0x0e, 0xdc,
        0x20, 0x54, 0x5a, 0xb1, 0xff, 0xd0, 0xe7, 0x4e, 0x7c, 0x76, 0xc1, 0x57, 0xbe, 0x42, 0x97, 0x17,
        0x7f, 0x99, 0x28, 0xbb, 0xe4, 0x2b, 0xe5, 0x77, 0xa4, 0x27, 0x82, 0xb6, 0x27, 0xba, 0x5d, 0xa5,
        0x85, 0x6e, 0xab, 0x6e, 0x44, 0x5e, 0x27, 0xa1, 0xdf, 0x12, 0x5a, 0x34, 0xa2, 0x40, 0x36, 0xc9,
        0xbf, 0x99, 0xf0, 0x07, 0x22, 0x14, 0x87, 0x94, 0xcc, 0x0b, 0xc0, 0x5e, 0xc4, 0x3c, 0xcf, 0xd1,
        0x58, 0x93, 0xbd, 0xbe, 0x8c, 0x34, 0x7f, 0x0a, 0x17, 0xe7, 0xac, 0x51, 0xa0, 0xba, 0x91, 0x64,
        0xb7, 0x20, 0x6f, 0x92, 0x8b, 0xd6, 0x15, 0x6b, 0x7b, 0xad, 0xba, 0xe1, 0xce, 0xe3, 0xbb, 0x26,
        0x7e, 0x6f, 0xf9, 0xf8, 0xd7, 0xe5, 0x5c, 0x8d, 0x62, 0xf9, 0x2e, 0x5c, 0x42, 0xb1, 0xc7, 0x52,
        0xef, 0x0b, 0x2d, 0x5e, 0x06, 0xb2, 0x49, 0x75, 0xd8, 0x16, 0x00, 0x76, 0xa3, 0xa1, 0x07, 0x81,
        0x44, 0xd1, 0xd5, 0xda, 0x2a, 0x5a, 0xea, 0x83, 0x40, 0xf2, 0x27, 0x50, 0x4c, 0x67, 0x12, 0x4b,
        0x19, 0x96, 0xe3, 0x37, 0x12, 0x49, 0x31, 0x49, 0x72, 0x1a, 0x8f, 0x51, 0xfc, 0x2e, 0x6c, 0xa2,
        0xd2, 0xbe, 0x6c, 0xaa, 0x96, 0xc4, 0xcf, 0xb8, 0x4d, 0x29, 0x8e, 0xd8, 0x88, 0x92, 0xeb, 0xc4,
        0x11, 0xeb, 0xf0, 0x2a, 0x94, 0xb2, 0xb3, 0x89, 0x85, 0xcd, 0xb0, 0xac, 0x52, 0xc5, 0x37, 0xb0,
        0x45, 0xec, 0x5d, 0x19, 0x0a, 0x9d, 0xae, 0x59, 0x02, 0x53, 0x21, 0xf5, 0xf4, 0xd8, 0xc0, 0x1c,
        0x00, 0x6c, 0x9f, 0xd4, 0x32, 0x8c, 0x8a, 0x4b, 0xe8, 0x9e, 0xb1, 0xf0, 0x07, 0xe0, 0x2c, 0x92,
        0x27, 0xa8, 0x33, 0xde, 0xf4, 0x8c, 0xa6, 0x62, 0xde, 0xf4, 0x4a, 0x74, 0xfa, 0x32, 0x49, 0x56,
        0xcf, 0x1a, 0x0a, 0x2b, 0xc0, 0xca, 0xbb, 0x38, 0x9a, 0xa0, 0xcc, 0x0f, 0x7e, 0x9f, 0x46, 0x35,
        0x27, 0x47, 0x24, 0x1c, 0xd6, 0x5b, 0x68, 0x6e, 0xa1, 0x9d, 0x24, 0xe7, 0x6c, 0xd5, 0x8f, 0x79,
        0x58, 0x41, 0x01, 0xd6, 0x83, 0xbc, 0x59, 0x23, 0xc6, 0x93, 0x43, 0x4d, 0x6f, 0xaa, 0x7d, 0xf5,
        0x9f, 0x31, 0x06, 0x80, 0x3b, 0x1f, 0x7e, 0xfc, 0xf9, 0xbc, 0x54, 0x64, 0x1b, 0x5e, 0xe6, 0x29,
        0xb0, 0x2f, 0x16, 0xac, 0xcd, 0xec, 0x18, 0xbb, 0x96, 0x29, 0x9a, 0xde, 0x5f, 0x7b, 0xfb, 0xec,
        0x40, 0x42, 0xa8, 0x22, 0x42, 0x99, 0x5d, 0x4f, 0x22, 0xf8, 0x52, 0x37, 0x4e, 0x2f, 0xd6, 0x3b,
        0x9a, 0x9e, 0xc3, 0x90, 0x7d, 0xb3, 0xe0, 0xff, 0xc4, 0xca, 0xb1, 0x9d, 0xcc, 0x8a, 0xd9, 0x6b,
        0x6d, 0x97, 0xcf, 0x17, 0x4c, 0x88, 0xb7, 0x11, 0xd1, 0x63, 0x95, 0x24, 0xa2, 0x19, 0x54, 0xa3,
        0x37, 0xc9, 0x98, 0x50, 0xc6, 0xdf, 0x43, 0xf6, 0xdd, 0x82, 0x0b, 0xa9, 0x2d, 0x64, 0x95, 0x05,
        0x9d, 0xc9, 0x3e, 0x06, 0xdb, 0x3d, 0x6f, 0x38, 0xb1, 0x3e, 0x44, 0xd6, 0x7b, 0xec, 0x4e, 0xba,
        0x9d, 0x26, 0x25, 0x45, 0x8b, 0x2d, 0xf5, 0x8e, 0xa6, 0x27, 0x34, 0x64, 0x5f, 0x2d, 0x58, 0x9b,
        0xd9, 0xd7, 0x05, 0x63, 0x4f, 0x1f, 0xc8, 0x82, 0xb1, 0x67, 0xac, 0x3e, 0xdf, 0x45, 0xce, 0x2a,
        0xbb, 0xb1, 0xa0, 0xa7, 0x78, 0x3c, 0x44, 0x58, 0x37, 0x84, 0x68, 0x1a, 0xee, 0x3d, 0x3a, 0x1e,
        0x39, 0xd6, 0xc9, 0xc8, 0xb1, 0x7e, 0x8f, 0x1c, 0xeb, 0xd3, 0xd8, 0xc9, 0x9d, 0x8c, 0x9d, 0xdc,
        0xcf, 0xb1, 0x93, 0x7b, 0xbd, 0xe3, 0xb7, 0xf5, 0xdb, 0xfe, 0x81, 0xdb, 0x54, 0x87, 0x9e, 0x96,
        0x9d, 0x8e, 0x0a, 0x2b, 0x6d, 0x45, 0xfa, 0xef, 0xa7, 0x15, 0xe2, 0x07, 0x47, 0x07, 0x79, 0xfc,
        0x9b, 0xbf, 0xf9, 0x37, 0x00, 0x00, 0xff, 0xff, 0x62, 0xe3, 0x71, 0xd0, 0x85, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
        // Parameters queries the parameters of the module.
        Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error)
        // Queries a list of GetDataSpec items.
        GetDataSpec(ctx context.Context, in *QueryGetDataSpecRequest, opts ...grpc.CallOption) (*QueryGetDataSpecResponse, error)
        // Queries a list of DecodeQuerydata items.
        DecodeQuerydata(ctx context.Context, in *QueryDecodeQuerydataRequest, opts ...grpc.CallOption) (*QueryDecodeQuerydataResponse, error)
        // Queries a list of GenerateQuerydata items.
        GenerateQuerydata(ctx context.Context, in *QueryGenerateQuerydataRequest, opts ...grpc.CallOption) (*QueryGenerateQuerydataResponse, error)
        // Queries a list of DecodeValue items.
        DecodeValue(ctx context.Context, in *QueryDecodeValueRequest, opts ...grpc.CallOption) (*QueryDecodeValueResponse, error)
}

type queryClient struct {
        cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient <span class="cov0" title="0">{
        return &amp;queryClient{cc}
}</span>

func (c *queryClient) Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error) <span class="cov0" title="0">{
        out := new(QueryParamsResponse)
        err := c.cc.Invoke(ctx, "/layer.registry.Query/Params", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) GetDataSpec(ctx context.Context, in *QueryGetDataSpecRequest, opts ...grpc.CallOption) (*QueryGetDataSpecResponse, error) <span class="cov0" title="0">{
        out := new(QueryGetDataSpecResponse)
        err := c.cc.Invoke(ctx, "/layer.registry.Query/GetDataSpec", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) DecodeQuerydata(ctx context.Context, in *QueryDecodeQuerydataRequest, opts ...grpc.CallOption) (*QueryDecodeQuerydataResponse, error) <span class="cov0" title="0">{
        out := new(QueryDecodeQuerydataResponse)
        err := c.cc.Invoke(ctx, "/layer.registry.Query/DecodeQuerydata", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) GenerateQuerydata(ctx context.Context, in *QueryGenerateQuerydataRequest, opts ...grpc.CallOption) (*QueryGenerateQuerydataResponse, error) <span class="cov0" title="0">{
        out := new(QueryGenerateQuerydataResponse)
        err := c.cc.Invoke(ctx, "/layer.registry.Query/GenerateQuerydata", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) DecodeValue(ctx context.Context, in *QueryDecodeValueRequest, opts ...grpc.CallOption) (*QueryDecodeValueResponse, error) <span class="cov0" title="0">{
        out := new(QueryDecodeValueResponse)
        err := c.cc.Invoke(ctx, "/layer.registry.Query/DecodeValue", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// QueryServer is the server API for Query service.
type QueryServer interface {
        // Parameters queries the parameters of the module.
        Params(context.Context, *QueryParamsRequest) (*QueryParamsResponse, error)
        // Queries a list of GetDataSpec items.
        GetDataSpec(context.Context, *QueryGetDataSpecRequest) (*QueryGetDataSpecResponse, error)
        // Queries a list of DecodeQuerydata items.
        DecodeQuerydata(context.Context, *QueryDecodeQuerydataRequest) (*QueryDecodeQuerydataResponse, error)
        // Queries a list of GenerateQuerydata items.
        GenerateQuerydata(context.Context, *QueryGenerateQuerydataRequest) (*QueryGenerateQuerydataResponse, error)
        // Queries a list of DecodeValue items.
        DecodeValue(context.Context, *QueryDecodeValueRequest) (*QueryDecodeValueResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) Params(ctx context.Context, req *QueryParamsRequest) (*QueryParamsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Params not implemented")
}</span>
func (*UnimplementedQueryServer) GetDataSpec(ctx context.Context, req *QueryGetDataSpecRequest) (*QueryGetDataSpecResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetDataSpec not implemented")
}</span>
func (*UnimplementedQueryServer) DecodeQuerydata(ctx context.Context, req *QueryDecodeQuerydataRequest) (*QueryDecodeQuerydataResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DecodeQuerydata not implemented")
}</span>
func (*UnimplementedQueryServer) GenerateQuerydata(ctx context.Context, req *QueryGenerateQuerydataRequest) (*QueryGenerateQuerydataResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GenerateQuerydata not implemented")
}</span>
func (*UnimplementedQueryServer) DecodeValue(ctx context.Context, req *QueryDecodeValueRequest) (*QueryDecodeValueResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DecodeValue not implemented")
}</span>

func RegisterQueryServer(s grpc1.Server, srv QueryServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;_Query_serviceDesc, srv)
}</span>

func _Query_Params_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryParamsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).Params(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.registry.Query/Params",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).Params(ctx, req.(*QueryParamsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_GetDataSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryGetDataSpecRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetDataSpec(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.registry.Query/GetDataSpec",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).GetDataSpec(ctx, req.(*QueryGetDataSpecRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_DecodeQuerydata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryDecodeQuerydataRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).DecodeQuerydata(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.registry.Query/DecodeQuerydata",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).DecodeQuerydata(ctx, req.(*QueryDecodeQuerydataRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_GenerateQuerydata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryGenerateQuerydataRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).GenerateQuerydata(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.registry.Query/GenerateQuerydata",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).GenerateQuerydata(ctx, req.(*QueryGenerateQuerydataRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_DecodeValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryDecodeValueRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).DecodeValue(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.registry.Query/DecodeValue",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).DecodeValue(ctx, req.(*QueryDecodeValueRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _Query_serviceDesc = grpc.ServiceDesc{
        ServiceName: "layer.registry.Query",
        HandlerType: (*QueryServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Params",
                        Handler:    _Query_Params_Handler,
                },
                {
                        MethodName: "GetDataSpec",
                        Handler:    _Query_GetDataSpec_Handler,
                },
                {
                        MethodName: "DecodeQuerydata",
                        Handler:    _Query_DecodeQuerydata_Handler,
                },
                {
                        MethodName: "GenerateQuerydata",
                        Handler:    _Query_GenerateQuerydata_Handler,
                },
                {
                        MethodName: "DecodeValue",
                        Handler:    _Query_DecodeValue_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "layer/registry/query.proto",
}

func (m *QueryParamsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryParamsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryParamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *QueryParamsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryParamsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func (m *QueryGetDataSpecRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetDataSpecRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetDataSpecRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.QueryType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryType)
                copy(dAtA[i:], m.QueryType)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.QueryType)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGetDataSpecResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGetDataSpecResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGetDataSpecResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Spec != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryDecodeQuerydataRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryDecodeQuerydataRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryDecodeQuerydataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.QueryData) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryData)
                copy(dAtA[i:], m.QueryData)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.QueryData)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryDecodeQuerydataResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryDecodeQuerydataResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryDecodeQuerydataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Spec) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Spec)
                copy(dAtA[i:], m.Spec)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.Spec)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGenerateQuerydataRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGenerateQuerydataRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGenerateQuerydataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Parameters) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Parameters)
                copy(dAtA[i:], m.Parameters)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.Parameters)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Querytype) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Querytype)
                copy(dAtA[i:], m.Querytype)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.Querytype)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryGenerateQuerydataResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryGenerateQuerydataResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryGenerateQuerydataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.QueryData) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryData)
                copy(dAtA[i:], m.QueryData)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.QueryData)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryDecodeValueRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryDecodeValueRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryDecodeValueRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Value) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Value)
                copy(dAtA[i:], m.Value)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.Value)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.QueryType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryType)
                copy(dAtA[i:], m.QueryType)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.QueryType)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryDecodeValueResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryDecodeValueResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryDecodeValueResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.DecodedValue) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.DecodedValue)
                copy(dAtA[i:], m.DecodedValue)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.DecodedValue)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovQuery(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *QueryParamsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *QueryParamsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Params.Size()
        n += 1 + l + sovQuery(uint64(l))
        return n</span>
}

func (m *QueryGetDataSpecRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.QueryType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGetDataSpecResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Spec != nil </span><span class="cov0" title="0">{
                l = m.Spec.Size()
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryDecodeQuerydataRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.QueryData)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryDecodeQuerydataResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Spec)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGenerateQuerydataRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Querytype)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Parameters)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryGenerateQuerydataResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.QueryData)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryDecodeValueRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.QueryType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Value)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryDecodeValueResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.DecodedValue)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovQuery(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozQuery(x uint64) (n int) <span class="cov0" title="0">{
        return sovQuery(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *QueryParamsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryParamsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetDataSpecRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetDataSpecRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetDataSpecRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGetDataSpecResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetDataSpecResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGetDataSpecResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Spec == nil </span><span class="cov0" title="0">{
                                m.Spec = &amp;DataSpec{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryDecodeQuerydataRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryDecodeQuerydataRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryDecodeQuerydataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryData", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryData = append(m.QueryData[:0], dAtA[iNdEx:postIndex]...)
                        if m.QueryData == nil </span><span class="cov0" title="0">{
                                m.QueryData = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryDecodeQuerydataResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryDecodeQuerydataResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryDecodeQuerydataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Spec = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGenerateQuerydataRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGenerateQuerydataRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGenerateQuerydataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Querytype", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Querytype = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Parameters = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryGenerateQuerydataResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGenerateQuerydataResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryGenerateQuerydataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryData", wireType)
                        }</span>
                        <span class="cov0" title="0">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if byteLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + byteLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryData = append(m.QueryData[:0], dAtA[iNdEx:postIndex]...)
                        if m.QueryData == nil </span><span class="cov0" title="0">{
                                m.QueryData = []byte{}
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryDecodeValueRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryDecodeValueRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryDecodeValueRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Value = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryDecodeValueResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryDecodeValueResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryDecodeValueResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DecodedValue", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.DecodedValue = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipQuery(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupQuery
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthQuery
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file159" style="display: none">// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: layer/registry/query.proto

/*
Package types is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package types

import (
        "context"
        "io"
        "net/http"

        "github.com/golang/protobuf/descriptor"
        "github.com/golang/protobuf/proto"
        "github.com/grpc-ecosystem/grpc-gateway/runtime"
        "github.com/grpc-ecosystem/grpc-gateway/utilities"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/grpclog"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// Suppress "imported and not used" errors
var _ codes.Code
var _ io.Reader
var _ status.Status
var _ = runtime.String
var _ = utilities.NewDoubleArray
var _ = descriptor.ForMessage
var _ = metadata.Join

func request_Query_Params_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryParamsRequest
        var metadata runtime.ServerMetadata

        msg, err := client.Params(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err

}</span>

func local_request_Query_Params_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryParamsRequest
        var metadata runtime.ServerMetadata

        msg, err := server.Params(ctx, &amp;protoReq)
        return msg, metadata, err

}</span>

func request_Query_GetDataSpec_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetDataSpecRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["query_type"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "query_type")
        }</span>

        <span class="cov0" title="0">protoReq.QueryType, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "query_type", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.GetDataSpec(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_GetDataSpec_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGetDataSpecRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["query_type"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "query_type")
        }</span>

        <span class="cov0" title="0">protoReq.QueryType, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "query_type", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.GetDataSpec(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_DecodeQuerydata_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryDecodeQuerydataRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["query_data"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "query_data")
        }</span>

        <span class="cov0" title="0">protoReq.QueryData, err = runtime.Bytes(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "query_data", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.DecodeQuerydata(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_DecodeQuerydata_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryDecodeQuerydataRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["query_data"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "query_data")
        }</span>

        <span class="cov0" title="0">protoReq.QueryData, err = runtime.Bytes(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "query_data", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.DecodeQuerydata(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_GenerateQuerydata_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGenerateQuerydataRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["querytype"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "querytype")
        }</span>

        <span class="cov0" title="0">protoReq.Querytype, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "querytype", err)
        }</span>

        <span class="cov0" title="0">val, ok = pathParams["parameters"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parameters")
        }</span>

        <span class="cov0" title="0">protoReq.Parameters, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parameters", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.GenerateQuerydata(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_GenerateQuerydata_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryGenerateQuerydataRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["querytype"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "querytype")
        }</span>

        <span class="cov0" title="0">protoReq.Querytype, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "querytype", err)
        }</span>

        <span class="cov0" title="0">val, ok = pathParams["parameters"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parameters")
        }</span>

        <span class="cov0" title="0">protoReq.Parameters, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parameters", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.GenerateQuerydata(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_DecodeValue_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryDecodeValueRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["queryType"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "queryType")
        }</span>

        <span class="cov0" title="0">protoReq.QueryType, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "queryType", err)
        }</span>

        <span class="cov0" title="0">val, ok = pathParams["value"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "value")
        }</span>

        <span class="cov0" title="0">protoReq.Value, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "value", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.DecodeValue(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_DecodeValue_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryDecodeValueRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["queryType"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "queryType")
        }</span>

        <span class="cov0" title="0">protoReq.QueryType, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "queryType", err)
        }</span>

        <span class="cov0" title="0">val, ok = pathParams["value"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "value")
        }</span>

        <span class="cov0" title="0">protoReq.Value, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "value", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.DecodeValue(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

// RegisterQueryHandlerServer registers the http handlers for service Query to "mux".
// UnaryRPC     :call QueryServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterQueryHandlerFromEndpoint instead.
func RegisterQueryHandlerServer(ctx context.Context, mux *runtime.ServeMux, server QueryServer) error <span class="cov0" title="0">{

        mux.Handle("GET", pattern_Query_Params_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_Params_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_Params_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetDataSpec_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_GetDataSpec_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetDataSpec_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_DecodeQuerydata_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_DecodeQuerydata_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_DecodeQuerydata_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GenerateQuerydata_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_GenerateQuerydata_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GenerateQuerydata_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_DecodeValue_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_DecodeValue_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_DecodeValue_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

// RegisterQueryHandlerFromEndpoint is same as RegisterQueryHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterQueryHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) <span class="cov0" title="0">{
        conn, err := grpc.Dial(endpoint, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                }()
        }()

        <span class="cov0" title="0">return RegisterQueryHandler(ctx, mux, conn)</span>
}

// RegisterQueryHandler registers the http handlers for service Query to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterQueryHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error <span class="cov0" title="0">{
        return RegisterQueryHandlerClient(ctx, mux, NewQueryClient(conn))
}</span>

// RegisterQueryHandlerClient registers the http handlers for service Query
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "QueryClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "QueryClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "QueryClient" to call the correct interceptors.
func RegisterQueryHandlerClient(ctx context.Context, mux *runtime.ServeMux, client QueryClient) error <span class="cov0" title="0">{

        mux.Handle("GET", pattern_Query_Params_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_Params_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_Params_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GetDataSpec_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_GetDataSpec_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GetDataSpec_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_DecodeQuerydata_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_DecodeQuerydata_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_DecodeQuerydata_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_GenerateQuerydata_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_GenerateQuerydata_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_GenerateQuerydata_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_DecodeValue_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_DecodeValue_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_DecodeValue_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

var (
        pattern_Query_Params_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"layer", "registry", "params"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_GetDataSpec_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"layer", "registry", "get_data_spec", "query_type"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_DecodeQuerydata_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"layer", "registry", "decode_querydata", "query_data"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_GenerateQuerydata_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 1, 0, 4, 1, 5, 4}, []string{"layer", "registry", "generate_querydata", "querytype", "parameters"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_DecodeValue_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 1, 0, 4, 1, 5, 4}, []string{"layer", "registry", "decode_value", "queryType", "value"}, "", runtime.AssumeColonVerbOpt(false)))
)

var (
        forward_Query_Params_0 = runtime.ForwardResponseMessage

        forward_Query_GetDataSpec_0 = runtime.ForwardResponseMessage

        forward_Query_DecodeQuerydata_0 = runtime.ForwardResponseMessage

        forward_Query_GenerateQuerydata_0 = runtime.ForwardResponseMessage

        forward_Query_DecodeValue_0 = runtime.ForwardResponseMessage
)
</pre>
		
		<pre class="file" id="file160" style="display: none">package types

var SupportedValueTypes = map[string]bool{
        "int8":      true,
        "int16":     true,
        "int32":     true,
        "int64":     true,
        "int128":    true,
        "int256":    true,
        "int[]":     true,
        "int8[]":    true,
        "int16[]":   true,
        "int32[]":   true,
        "int64[]":   true,
        "int128[]":  true,
        "int256[]":  true,
        "uint8":     true,
        "uint16":    true,
        "uint32":    true,
        "uint64":    true,
        "uint128":   true,
        "uint256":   true,
        "uint[]":    true,
        "uint8[]":   true,
        "uint16[]":  true,
        "uint32[]":  true,
        "uint64[]":  true,
        "uint128[]": true,
        "uint256[]": true,
        "bytes":     true,
        "string":    true,
        "bool":      true,
        "address":   true,
        "bytes[]":   true,
        "string[]":  true,
        "bool[]":    true,
        "address[]": true,
}

func SupportedType(dataType string) bool <span class="cov0" title="0">{
        _, exists := SupportedValueTypes[dataType]
        return exists
}</span>
</pre>
		
		<pre class="file" id="file161" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/registry/tx.proto

package types

import (
        context "context"
        fmt "fmt"
        _ "github.com/cosmos/cosmos-proto"
        _ "github.com/cosmos/cosmos-sdk/types/msgservice"
        _ "github.com/cosmos/cosmos-sdk/types/tx/amino"
        _ "github.com/cosmos/gogoproto/gogoproto"
        grpc1 "github.com/cosmos/gogoproto/grpc"
        proto "github.com/cosmos/gogoproto/proto"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgRegisterSpec defines the Msg/RegisterSpec request type.
type MsgRegisterSpec struct {
        // address that registers the data spec
        Registrar string `protobuf:"bytes,1,opt,name=registrar,proto3" json:"registrar,omitempty"`
        // name of the query type (ie. "SpotPrice")
        QueryType string `protobuf:"bytes,2,opt,name=query_type,json=queryType,proto3" json:"query_type,omitempty"`
        // data spec
        Spec DataSpec `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec"`
}

func (m *MsgRegisterSpec) Reset()         <span class="cov0" title="0">{ *m = MsgRegisterSpec{} }</span>
func (m *MsgRegisterSpec) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgRegisterSpec) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgRegisterSpec) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6dfd681be11a64dd, []int{0}
}</span>
func (m *MsgRegisterSpec) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgRegisterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgRegisterSpec.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgRegisterSpec) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgRegisterSpec.Merge(m, src)
}</span>
func (m *MsgRegisterSpec) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgRegisterSpec) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgRegisterSpec.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgRegisterSpec proto.InternalMessageInfo

func (m *MsgRegisterSpec) GetRegistrar() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Registrar
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgRegisterSpec) GetQueryType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgRegisterSpec) GetSpec() DataSpec <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Spec
        }</span>
        <span class="cov0" title="0">return DataSpec{}</span>
}

// MsgRegisterSpecResponse defines the Msg/RegisterSpec response type.
type MsgRegisterSpecResponse struct {
}

func (m *MsgRegisterSpecResponse) Reset()         <span class="cov0" title="0">{ *m = MsgRegisterSpecResponse{} }</span>
func (m *MsgRegisterSpecResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgRegisterSpecResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgRegisterSpecResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6dfd681be11a64dd, []int{1}
}</span>
func (m *MsgRegisterSpecResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgRegisterSpecResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgRegisterSpecResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgRegisterSpecResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgRegisterSpecResponse.Merge(m, src)
}</span>
func (m *MsgRegisterSpecResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgRegisterSpecResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgRegisterSpecResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgRegisterSpecResponse proto.InternalMessageInfo

// MsgUpdateDataSpec is the Msg/UpdateDataSpec request type.
type MsgUpdateDataSpec struct {
        // authority is the address that is allowed calling this msg.
        Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
        // query type to update
        QueryType string `protobuf:"bytes,2,opt,name=query_type,json=queryType,proto3" json:"query_type,omitempty"`
        // data spec update
        Spec DataSpec `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec"`
}

func (m *MsgUpdateDataSpec) Reset()         <span class="cov0" title="0">{ *m = MsgUpdateDataSpec{} }</span>
func (m *MsgUpdateDataSpec) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgUpdateDataSpec) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgUpdateDataSpec) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6dfd681be11a64dd, []int{2}
}</span>
func (m *MsgUpdateDataSpec) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdateDataSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdateDataSpec.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdateDataSpec) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateDataSpec.Merge(m, src)
}</span>
func (m *MsgUpdateDataSpec) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdateDataSpec) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateDataSpec.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdateDataSpec proto.InternalMessageInfo

func (m *MsgUpdateDataSpec) GetAuthority() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Authority
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgUpdateDataSpec) GetQueryType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QueryType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgUpdateDataSpec) GetSpec() DataSpec <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Spec
        }</span>
        <span class="cov0" title="0">return DataSpec{}</span>
}

type MsgUpdateDataSpecResponse struct {
}

func (m *MsgUpdateDataSpecResponse) Reset()         <span class="cov0" title="0">{ *m = MsgUpdateDataSpecResponse{} }</span>
func (m *MsgUpdateDataSpecResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgUpdateDataSpecResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgUpdateDataSpecResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6dfd681be11a64dd, []int{3}
}</span>
func (m *MsgUpdateDataSpecResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdateDataSpecResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdateDataSpecResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdateDataSpecResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateDataSpecResponse.Merge(m, src)
}</span>
func (m *MsgUpdateDataSpecResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdateDataSpecResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateDataSpecResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdateDataSpecResponse proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*MsgRegisterSpec)(nil), "layer.registry.MsgRegisterSpec")
        proto.RegisterType((*MsgRegisterSpecResponse)(nil), "layer.registry.MsgRegisterSpecResponse")
        proto.RegisterType((*MsgUpdateDataSpec)(nil), "layer.registry.MsgUpdateDataSpec")
        proto.RegisterType((*MsgUpdateDataSpecResponse)(nil), "layer.registry.MsgUpdateDataSpecResponse")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/registry/tx.proto", fileDescriptor_6dfd681be11a64dd) }</span>

var fileDescriptor_6dfd681be11a64dd = []byte{
        // 433 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x52, 0xb1, 0xef, 0xd2, 0x40,
        0x18, 0xed, 0x09, 0x9a, 0x70, 0x1a, 0x0c, 0x0d, 0x09, 0xa5, 0xc6, 0x82, 0x5d, 0x44, 0x0c, 0xbd,
        0x88, 0xd1, 0xc1, 0x4d, 0xa2, 0x23, 0x4b, 0xd1, 0xc4, 0x38, 0x48, 0x8e, 0xf6, 0x72, 0x34, 0xa1,
        0x5c, 0xbd, 0x3b, 0x0c, 0xdd, 0x8c, 0xa3, 0x93, 0x7f, 0x88, 0x03, 0x83, 0x7f, 0x83, 0x61, 0x24,
        0x26, 0x26, 0x4e, 0xc6, 0xc0, 0xc0, 0xbf, 0x61, 0x7a, 0x6d, 0x21, 0x94, 0x5f, 0xc2, 0xf4, 0x5b,
        0xda, 0xde, 0xf7, 0xde, 0x7d, 0xef, 0x7b, 0xdf, 0x2b, 0x6c, 0xcc, 0x70, 0x4c, 0x38, 0xe2, 0x84,
        0x06, 0x42, 0xf2, 0x18, 0xc9, 0xa5, 0x13, 0x71, 0x26, 0x99, 0x5e, 0x55, 0x80, 0x93, 0x03, 0x66,
        0x0d, 0x87, 0xc1, 0x9c, 0x21, 0xf5, 0x4c, 0x29, 0x66, 0xc3, 0x63, 0x22, 0x64, 0x02, 0x85, 0x82,
        0xa2, 0x4f, 0x4f, 0x92, 0x57, 0x06, 0x34, 0x53, 0x60, 0xac, 0x4e, 0x28, 0x3d, 0x64, 0x50, 0x9d,
        0x32, 0xca, 0xd2, 0x7a, 0xf2, 0x95, 0x55, 0xad, 0xc2, 0x14, 0x3e, 0x96, 0x78, 0x2c, 0x22, 0xe2,
        0xa5, 0xb8, 0xfd, 0x1d, 0xc0, 0xbb, 0x43, 0x41, 0x5d, 0x85, 0x13, 0x3e, 0x8a, 0x88, 0xa7, 0x3f,
        0x87, 0x95, 0x8c, 0x8f, 0xb9, 0x01, 0xda, 0xa0, 0x53, 0x19, 0x18, 0xbf, 0x7e, 0xf4, 0xea, 0x99,
        0xdc, 0x4b, 0xdf, 0xe7, 0x44, 0x88, 0x91, 0xe4, 0xc1, 0x9c, 0xba, 0x47, 0xaa, 0x7e, 0x1f, 0xc2,
        0x8f, 0x0b, 0xc2, 0xe3, 0xb1, 0x8c, 0x23, 0x62, 0xdc, 0x48, 0x2e, 0xba, 0x15, 0x55, 0x79, 0x13,
        0x47, 0x44, 0xef, 0xc3, 0x72, 0x22, 0x6c, 0x94, 0xda, 0xa0, 0x73, 0xbb, 0x6f, 0x38, 0xa7, 0x6b,
        0x70, 0x5e, 0x61, 0x89, 0x13, 0xf9, 0x41, 0x79, 0xfd, 0xb7, 0xa5, 0xb9, 0x8a, 0xfb, 0xa2, 0xfa,
        0x65, 0xbf, 0xea, 0x1e, 0x25, 0xec, 0x26, 0x6c, 0x14, 0xa6, 0x75, 0x89, 0x88, 0xd8, 0x5c, 0x10,
        0xfb, 0x37, 0x80, 0xb5, 0xa1, 0xa0, 0x6f, 0x23, 0x1f, 0x4b, 0x92, 0x37, 0x4b, 0xbc, 0xe0, 0x85,
        0x9c, 0x32, 0x1e, 0xc8, 0xf8, 0xb2, 0x97, 0x03, 0xf5, 0x3a, 0xbc, 0x3c, 0x53, 0x5e, 0x0e, 0x12,
        0x5f, 0xf7, 0xab, 0xae, 0x9d, 0xa6, 0xb3, 0x3c, 0xe6, 0x73, 0xe6, 0xc0, 0xbe, 0x07, 0x9b, 0x67,
        0xc5, 0xdc, 0x74, 0xff, 0x27, 0x80, 0xa5, 0xa1, 0xa0, 0xfa, 0x3b, 0x78, 0xe7, 0x24, 0xc2, 0x56,
        0x71, 0xa2, 0xc2, 0xd6, 0xcc, 0x87, 0x17, 0x08, 0xb9, 0x82, 0xfe, 0x01, 0x56, 0x0b, 0x2b, 0x7d,
        0x70, 0xc5, 0xd5, 0x53, 0x8a, 0xf9, 0xe8, 0x22, 0x25, 0xef, 0x6f, 0xde, 0xfc, 0xbc, 0x5f, 0x75,
        0xc1, 0xe0, 0xf5, 0x7a, 0x6b, 0x81, 0xcd, 0xd6, 0x02, 0xff, 0xb6, 0x16, 0xf8, 0xb6, 0xb3, 0xb4,
        0xcd, 0xce, 0xd2, 0xfe, 0xec, 0x2c, 0xed, 0xfd, 0x63, 0x1a, 0xc8, 0xe9, 0x62, 0xe2, 0x78, 0x2c,
        0x44, 0x92, 0xcc, 0x66, 0x8c, 0xf7, 0x02, 0x86, 0xce, 0x16, 0x97, 0xe4, 0x24, 0x26, 0xb7, 0xd4,
        0x5f, 0xfd, 0xf4, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x41, 0x01, 0x74, 0x1c, 0x7d, 0x03, 0x00,
        0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
        // RegisterSpec defines a method for registering a new data specification.
        RegisterSpec(ctx context.Context, in *MsgRegisterSpec, opts ...grpc.CallOption) (*MsgRegisterSpecResponse, error)
        // UpdateDataSpec defines a method for updating an existing data specification.
        UpdateDataSpec(ctx context.Context, in *MsgUpdateDataSpec, opts ...grpc.CallOption) (*MsgUpdateDataSpecResponse, error)
}

type msgClient struct {
        cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient <span class="cov0" title="0">{
        return &amp;msgClient{cc}
}</span>

func (c *msgClient) RegisterSpec(ctx context.Context, in *MsgRegisterSpec, opts ...grpc.CallOption) (*MsgRegisterSpecResponse, error) <span class="cov0" title="0">{
        out := new(MsgRegisterSpecResponse)
        err := c.cc.Invoke(ctx, "/layer.registry.Msg/RegisterSpec", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgClient) UpdateDataSpec(ctx context.Context, in *MsgUpdateDataSpec, opts ...grpc.CallOption) (*MsgUpdateDataSpecResponse, error) <span class="cov0" title="0">{
        out := new(MsgUpdateDataSpecResponse)
        err := c.cc.Invoke(ctx, "/layer.registry.Msg/UpdateDataSpec", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
        // RegisterSpec defines a method for registering a new data specification.
        RegisterSpec(context.Context, *MsgRegisterSpec) (*MsgRegisterSpecResponse, error)
        // UpdateDataSpec defines a method for updating an existing data specification.
        UpdateDataSpec(context.Context, *MsgUpdateDataSpec) (*MsgUpdateDataSpecResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) RegisterSpec(ctx context.Context, req *MsgRegisterSpec) (*MsgRegisterSpecResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RegisterSpec not implemented")
}</span>
func (*UnimplementedMsgServer) UpdateDataSpec(ctx context.Context, req *MsgUpdateDataSpec) (*MsgUpdateDataSpecResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateDataSpec not implemented")
}</span>

func RegisterMsgServer(s grpc1.Server, srv MsgServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;_Msg_serviceDesc, srv)
}</span>

func _Msg_RegisterSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgRegisterSpec)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).RegisterSpec(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.registry.Msg/RegisterSpec",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).RegisterSpec(ctx, req.(*MsgRegisterSpec))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Msg_UpdateDataSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgUpdateDataSpec)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).UpdateDataSpec(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.registry.Msg/UpdateDataSpec",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).UpdateDataSpec(ctx, req.(*MsgUpdateDataSpec))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _Msg_serviceDesc = grpc.ServiceDesc{
        ServiceName: "layer.registry.Msg",
        HandlerType: (*MsgServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "RegisterSpec",
                        Handler:    _Msg_RegisterSpec_Handler,
                },
                {
                        MethodName: "UpdateDataSpec",
                        Handler:    _Msg_UpdateDataSpec_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "layer/registry/tx.proto",
}

func (m *MsgRegisterSpec) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgRegisterSpec) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgRegisterSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintTx(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x1a
        if len(m.QueryType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryType)
                copy(dAtA[i:], m.QueryType)
                i = encodeVarintTx(dAtA, i, uint64(len(m.QueryType)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Registrar) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Registrar)
                copy(dAtA[i:], m.Registrar)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Registrar)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgRegisterSpecResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgRegisterSpecResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgRegisterSpecResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgUpdateDataSpec) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdateDataSpec) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdateDataSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintTx(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x1a
        if len(m.QueryType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.QueryType)
                copy(dAtA[i:], m.QueryType)
                i = encodeVarintTx(dAtA, i, uint64(len(m.QueryType)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Authority) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Authority)
                copy(dAtA[i:], m.Authority)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgUpdateDataSpecResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdateDataSpecResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdateDataSpecResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func encodeVarintTx(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovTx(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *MsgRegisterSpec) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Registrar)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.QueryType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Spec.Size()
        n += 1 + l + sovTx(uint64(l))
        return n</span>
}

func (m *MsgRegisterSpecResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgUpdateDataSpec) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Authority)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.QueryType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Spec.Size()
        n += 1 + l + sovTx(uint64(l))
        return n</span>
}

func (m *MsgUpdateDataSpecResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func sovTx(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozTx(x uint64) (n int) <span class="cov0" title="0">{
        return sovTx(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *MsgRegisterSpec) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRegisterSpec: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRegisterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Registrar", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Registrar = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgRegisterSpecResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRegisterSpecResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRegisterSpecResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUpdateDataSpec) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateDataSpec: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateDataSpec: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Authority = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field QueryType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.QueryType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUpdateDataSpecResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateDataSpecResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateDataSpecResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipTx(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupTx
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthTx
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file162" style="display: none">package keeper

import (
        "context"
        "errors"
        "fmt"
        gomath "math"

        "cosmossdk.io/collections"
        "cosmossdk.io/math"
        sdk "github.com/cosmos/cosmos-sdk/types"

        stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
        "github.com/tellor-io/layer/x/reporter/types"
)

// WithdrawReporterCommission withdraws the accumulated commission of a reporter.
// It fetches the reporter's accumulated commission from the storage and checks if it is zero.
// If the commission is zero, it returns an error.
// Otherwise, it truncates the commission and updates the remainder in the storage for later withdrawal.
// It then updates the outstanding rewards by subtracting the commission from the reporter's rewards.
// If the commission is not zero, it sends the commission coins from the module to the reporter's account.
// Finally, it emits an event to indicate the successful withdrawal of the commission.
// Returns the withdrawn commission coins and any error encountered.
func (k Keeper) WithdrawReporterCommission(ctx context.Context, reporterVal sdk.ValAddress) (sdk.Coins, error) <span class="cov8" title="1">{
        // fetch reporter accumulated commission
        accumCommission, err := k.ReportersAccumulatedCommission.Get(ctx, reporterVal)
        if err != nil &amp;&amp; !errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if accumCommission.Commission.IsZero() </span><span class="cov0" title="0">{
                return nil, types.ErrNoReporterCommission
        }</span>

        <span class="cov8" title="1">commission, remainder := accumCommission.Commission.TruncateDecimal()
        err = k.ReportersAccumulatedCommission.Set(ctx, reporterVal, types.ReporterAccumulatedCommission{Commission: remainder}) // leave remainder to withdraw later
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // update outstanding
        <span class="cov8" title="1">outstanding, err := k.ReporterOutstandingRewards.Get(ctx, reporterVal)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = k.ReporterOutstandingRewards.Set(ctx, reporterVal, types.ReporterOutstandingRewards{Rewards: outstanding.Rewards.Sub(sdk.NewDecCoinsFromCoins(commission...))})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !commission.IsZero() </span><span class="cov8" title="1">{

                err = k.bankKeeper.SendCoinsFromModuleToAccount(ctx, types.ModuleName, reporterVal.Bytes(), commission)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">sdkCtx := sdk.UnwrapSDKContext(ctx)
        sdkCtx.EventManager().EmitEvent(
                sdk.NewEvent(
                        types.EventTypeWithdrawCommission,
                        sdk.NewAttribute(sdk.AttributeKeyAmount, commission.String()),
                ),
        )

        return commission, nil</span>
}

// AllocateTokensToReporter allocate tokens to a particular reporter,
// splitting according to commission.
// AllocateTokensToReporter allocates tokens to a reporter and updates the commission, rewards, and outstanding rewards.
// It splits the tokens between the reporter and delegators according to the commission rate.
// Parameters:
// - ctx: The context of the current operation.
// - reporterAcc: The account address of the reporter as AccAddress type.
// - tokens: The tokens to be allocated.
// Returns:
// - error: An error if the operation fails, nil otherwise.
func (k Keeper) AllocateTokensToReporter(ctx context.Context, reporterVal sdk.ValAddress, tokens sdk.DecCoins) error <span class="cov8" title="1">{
        // split tokens between reporter and delegators according to commission
        rep, err := k.Reporters.Get(ctx, reporterVal.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">commission := tokens.MulDec(rep.Commission.Rate)
        shared := tokens.Sub(commission)

        // update current commission
        sdkCtx := sdk.UnwrapSDKContext(ctx)
        sdkCtx.EventManager().EmitEvent(
                sdk.NewEvent(
                        types.EventTypeCommission,
                        sdk.NewAttribute(sdk.AttributeKeyAmount, commission.String()),
                        sdk.NewAttribute(types.AttributeKeyReporter, sdk.AccAddress(reporterVal).String()),
                ),
        )
        currentCommission, err := k.ReportersAccumulatedCommission.Get(ctx, reporterVal)
        if err != nil &amp;&amp; !errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">currentCommission.Commission = currentCommission.Commission.Add(commission...)
        err = k.ReportersAccumulatedCommission.Set(ctx, reporterVal, currentCommission)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // update current rewards
        <span class="cov8" title="1">currentRewards, err := k.ReporterCurrentRewards.Get(ctx, reporterVal)
        // if the rewards do not exist it's fine, we will just add to zero.
        if err != nil &amp;&amp; !errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">currentRewards.Rewards = currentRewards.Rewards.Add(shared...)
        err = k.ReporterCurrentRewards.Set(ctx, reporterVal, currentRewards)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // update outstanding rewards
        <span class="cov8" title="1">sdkCtx.EventManager().EmitEvent(
                sdk.NewEvent(
                        types.EventTypeRewards,
                        sdk.NewAttribute(sdk.AttributeKeyAmount, tokens.String()),
                        sdk.NewAttribute(types.AttributeKeyReporter, sdk.AccAddress(reporterVal).String()),
                ),
        )

        outstanding, err := k.ReporterOutstandingRewards.Get(ctx, reporterVal)
        if err != nil &amp;&amp; !errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">outstanding.Rewards = outstanding.Rewards.Add(tokens...)
        return k.ReporterOutstandingRewards.Set(ctx, reporterVal, outstanding)</span>
}

// WithdrawDelegationRewards withdraws the delegation rewards for a given delegator and reporter.
// It retrieves the reporter and delegator from the keeper and asserts that the reporter matches the delegator's reporter.
// Then, it calls the withdrawDelegationRewards function to actually withdraw the rewards.
// After that, it reinitializes the delegation by calling the initializeDelegation function.
// Finally, it returns the withdrawn rewards.
func (k Keeper) WithdrawDelegationRewards(ctx context.Context, reporterVal sdk.ValAddress, delAddr sdk.AccAddress) (sdk.Coins, error) <span class="cov8" title="1">{
        reporter, err := k.Reporters.Get(ctx, reporterVal.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">del, err := k.Delegators.Get(ctx, delAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // assert the right reporter for sanity
        <span class="cov8" title="1">if del.GetReporter() != reporter.GetReporter() </span><span class="cov0" title="0">{
                return nil, types.ErrReporterMismatch
        }</span>

        // withdraw rewards
        <span class="cov8" title="1">rewards, err := k.withdrawDelegationRewards(ctx, reporter, delAddr, del)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // reinitialize the delegation
        <span class="cov8" title="1">err = k.initializeDelegation(ctx, reporterVal, delAddr, del.Amount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return rewards, nil</span>
}

// initialize starting info for a new delegation
// initializeDelegation initializes a delegation by storing the period ended by the delegation action and updating the reference count for the period.
// It also sets the DelegatorStartingInfo for the delegation.
func (k Keeper) initializeDelegation(ctx context.Context, reporterVal sdk.ValAddress, delAddr sdk.AccAddress, stake math.Int) error <span class="cov8" title="1">{
        // period has already been incremented - we want to store the period ended by this delegation action
        repCurrentRewards, err := k.ReporterCurrentRewards.Get(ctx, reporterVal)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">previousPeriod := repCurrentRewards.Period - 1

        // increment reference count for the period we're going to track
        err = k.incrementReferenceCount(ctx, reporterVal, previousPeriod)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">sdkCtx := sdk.UnwrapSDKContext(ctx)
        return k.DelegatorStartingInfo.Set(ctx, collections.Join(reporterVal, delAddr), types.NewDelegatorStartingInfo(previousPeriod, stake, uint64(sdkCtx.BlockHeight())))</span>
}

// increment the reference count for a historical rewards value
// incrementReferenceCount increments the reference count for a reporter's historical rewards for a specific period.
// It retrieves the historical rewards for the reporter and period from the store, increments the reference count,
// and updates the store with the modified historical rewards.
func (k Keeper) incrementReferenceCount(ctx context.Context, reporterVal sdk.ValAddress, period uint64) error <span class="cov8" title="1">{
        historical, err := k.ReporterHistoricalRewards.Get(ctx, collections.Join(reporterVal, period))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if historical.ReferenceCount &gt; 2 </span><span class="cov0" title="0">{
                panic("reference count should never exceed 2")</span>
        }
        <span class="cov8" title="1">historical.ReferenceCount++
        return k.ReporterHistoricalRewards.Set(ctx, collections.Join(reporterVal, period), historical)</span>
}

// withdrawDelegationRewards withdraws the delegation rewards for a specific delegator.
// It calculates the rewards, truncates the decimal portion, adds the rewards to the delegator's account,
// updates the outstanding rewards, burns the remainder, decrements the reference count of the starting period,
// and removes the delegator starting info. Finally, it emits an event for the withdrawal of rewards.
func (k Keeper) withdrawDelegationRewards(ctx context.Context, reporter types.OracleReporter, delAddr sdk.AccAddress, del types.Delegation) (sdk.Coins, error) <span class="cov8" title="1">{
        reporterVal := sdk.ValAddress(sdk.MustAccAddressFromBech32(reporter.Reporter))

        // check existence of delegator starting info
        hasInfo, err := k.DelegatorStartingInfo.Has(ctx, collections.Join(reporterVal, delAddr))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !hasInfo </span><span class="cov0" title="0">{
                return nil, types.ErrEmptyDelegationDistInfo
        }</span>
        // end current period and calculate rewards
        <span class="cov8" title="1">endingPeriod, err := k.IncrementReporterPeriod(ctx, reporter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rewardsRaw, err := k.CalculateDelegationRewards(ctx, reporterVal, delAddr, del, endingPeriod)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">outstanding, err := k.GetReporterOutstandingRewardsCoins(ctx, reporterVal)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // defensive edge case may happen on the very final digits
        // of the decCoins due to operation order of the distribution mechanism.
        <span class="cov8" title="1">rewards := rewardsRaw.Intersect(outstanding)
        if !rewards.Equal(rewardsRaw) </span><span class="cov0" title="0">{
                logger := k.Logger()
                logger.Info(
                        "rounding error withdrawing rewards from reporter",
                        "delegator", delAddr.String(),
                        "reporter", reporter.GetReporter(),
                        "got", rewards.String(),
                        "expected", rewardsRaw.String(),
                )
        }</span>

        // truncate reward dec coins, return remainder to decimal pool
        <span class="cov8" title="1">finalRewards, remainder := rewards.TruncateDecimal()

        // add coins to user account
        if !finalRewards.IsZero() </span><span class="cov8" title="1">{
                err = k.bankKeeper.SendCoinsFromModuleToAccount(ctx, types.ModuleName, delAddr, finalRewards)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // update the outstanding rewards and the decimal pool only if the transaction was successful
        <span class="cov8" title="1">if err := k.ReporterOutstandingRewards.Set(ctx, reporterVal, types.ReporterOutstandingRewards{Rewards: outstanding.Sub(rewards)}); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // TODO: burn remainder
        <span class="cov8" title="1">_ = remainder

        // decrement reference count of starting period
        startingInfo, err := k.DelegatorStartingInfo.Get(ctx, collections.Join(reporterVal, delAddr))
        if err != nil &amp;&amp; !errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">startingPeriod := startingInfo.PreviousPeriod
        err = k.decrementReferenceCount(ctx, reporterVal, startingPeriod)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // remove delegator starting info
        <span class="cov8" title="1">err = k.DelegatorStartingInfo.Remove(ctx, collections.Join(reporterVal, delAddr))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if finalRewards.IsZero() </span><span class="cov8" title="1">{
                // Note, we do not call the NewCoins constructor as we do not want the zero
                // coin removed.
                finalRewards = sdk.Coins{sdk.NewCoin(types.Denom, math.ZeroInt())}
        }</span>

        <span class="cov8" title="1">sdkCtx := sdk.UnwrapSDKContext(ctx)
        sdkCtx.EventManager().EmitEvent(
                sdk.NewEvent(
                        types.EventTypeWithdrawRewards,
                        sdk.NewAttribute(sdk.AttributeKeyAmount, finalRewards.String()),
                        sdk.NewAttribute(types.AttributeKeyReporter, reporter.GetReporter()),
                        sdk.NewAttribute(types.AttributeKeyDelegator, delAddr.String()),
                ),
        )

        return finalRewards, nil</span>
}

// CalculateDelegationRewards calculates the rewards for a delegation based on the starting and ending period.
// It takes the context, reporter ValAddress, delegator AccAddress, delegation information, and the ending period as input.
// It returns the rewards as sdk.DecCoins and an error if any.
func (k Keeper) CalculateDelegationRewards(ctx context.Context, reporterVal sdk.ValAddress, delAddr sdk.AccAddress, del types.Delegation, endingPeriod uint64) (rewards sdk.DecCoins, err error) <span class="cov8" title="1">{
        // fetch starting info for delegation
        startingInfo, err := k.DelegatorStartingInfo.Get(ctx, collections.Join(reporterVal, delAddr))
        if err != nil &amp;&amp; !errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                return sdk.DecCoins{}, err
        }</span>

        <span class="cov8" title="1">sdkCtx := sdk.UnwrapSDKContext(ctx)
        if startingInfo.Height == uint64(sdkCtx.BlockHeight()) </span><span class="cov8" title="1">{
                // started this height, no rewards yet
                return sdk.DecCoins{}, nil
        }</span>

        <span class="cov8" title="1">startingPeriod := startingInfo.PreviousPeriod
        stake := math.LegacyNewDecFromInt(startingInfo.Stake)

        // Iterate through disputes and withdraw with calculated staking for
        // distribution periods. These period offsets are dependent on *when* disputes
        // happen
        startingHeight := startingInfo.Height
        // Disputes this block happened after reward allocation, but we have to account
        // for them for the stake sanity check below.
        endingHeight := uint64(sdkCtx.BlockHeight())
        var iterErr error
        if endingHeight &gt; startingHeight </span><span class="cov8" title="1">{
                err = k.IterateReporterDisputeEventsBetween(ctx, reporterVal, startingHeight, endingHeight,
                        func(height uint64, event types.ReporterDisputeEvent) (stop bool) </span><span class="cov8" title="1">{
                                endingPeriod := event.ReporterPeriod
                                if endingPeriod &gt; startingPeriod </span><span class="cov8" title="1">{
                                        delRewards, err := k.calculateDelegationRewardsBetween(ctx, reporterVal, startingPeriod, endingPeriod, stake.TruncateInt())
                                        if err != nil </span><span class="cov0" title="0">{
                                                iterErr = err
                                                return true
                                        }</span>
                                        <span class="cov8" title="1">rewards = rewards.Add(delRewards...)

                                        // Note: It is necessary to truncate so we don't allow withdrawing
                                        // more rewards than owed.
                                        stake = stake.MulTruncate(math.LegacyOneDec().Sub(event.Fraction))
                                        startingPeriod = endingPeriod</span>
                                }
                                <span class="cov8" title="1">return false</span>
                        },
                )
                <span class="cov8" title="1">if iterErr != nil </span><span class="cov0" title="0">{
                        return sdk.DecCoins{}, iterErr
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return sdk.DecCoins{}, err
                }</span>
        }

        // A total stake sanity check; Recalculated final stake should be less than or
        // equal to current stake here. We cannot use Equals because stake is truncated
        // when multiplied by slash fractions (see above). We could only use equals if
        // we had arbitrary-precision rationals.
        <span class="cov8" title="1">currentStake := math.LegacyNewDecFromInt(del.Amount)

        if stake.GT(currentStake) </span><span class="cov0" title="0">{
                // AccountI for rounding inconsistencies between:
                //
                //     currentStake: calculated as in staking with a single computation
                //     stake:        calculated as an accumulation of stake
                //                   calculations across reporter's distribution periods
                //
                // These inconsistencies are due to differing order of operations which
                // will inevitably have different accumulated rounding and may lead to
                // the smallest decimal place being one greater in stake than
                // currentStake. When we calculated slashing by period, even if we
                // round down for each slash fraction, it's possible due to how much is
                // being rounded that we slash less when slashing by period instead of
                // for when we slash without periods. In other words, the single slash,
                // and the slashing by period could both be rounding down but the
                // slashing by period is simply rounding down less, thus making stake &gt;
                // currentStake
                //
                // A small amount of this error is tolerated and corrected for,
                // however any greater amount should be considered a breach in expected
                // behavior.
                marginOfErr := math.LegacySmallestDec().MulInt64(3)
                if stake.LTE(currentStake.Add(marginOfErr)) </span><span class="cov0" title="0">{
                        stake = currentStake
                }</span> else<span class="cov0" title="0"> {
                        return sdk.DecCoins{}, fmt.Errorf("calculated final stake for delegator %s greater than current stake"+
                                "\n\tfinal stake:\t%s"+
                                "\n\tcurrent stake:\t%s",
                                del.GetReporter(), stake, currentStake)
                }</span>
        }

        // calculate rewards for final period
        <span class="cov8" title="1">delRewards, err := k.calculateDelegationRewardsBetween(ctx, reporterVal, startingPeriod, endingPeriod, stake.TruncateInt())
        if err != nil </span><span class="cov0" title="0">{
                return sdk.DecCoins{}, err
        }</span>

        <span class="cov8" title="1">rewards = rewards.Add(delRewards...)
        return rewards, nil</span>
}

// increment reporter period, returning the period just ended
func (k Keeper) IncrementReporterPeriod(ctx context.Context, reporter types.OracleReporter) (uint64, error) <span class="cov8" title="1">{
        // fetch current rewards
        reporterVal := sdk.ValAddress(sdk.MustAccAddressFromBech32(reporter.Reporter))
        rewards, err := k.ReporterCurrentRewards.Get(ctx, reporterVal)
        if err != nil &amp;&amp; !errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // calculate current ratio
        <span class="cov8" title="1">var current sdk.DecCoins
        if reporter.TotalTokens.IsZero() </span><span class="cov0" title="0">{

                // can't calculate ratio for zero-token reporters
                // ergo we instead add to ~~~the decimal pool~~ TODO: burn rewards.Rewards

                outstanding, err := k.ReporterOutstandingRewards.Get(ctx, reporterVal)
                if err != nil &amp;&amp; !errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">outstanding.Rewards = outstanding.GetRewards().Sub(rewards.Rewards)

                err = k.ReporterOutstandingRewards.Set(ctx, reporterVal, outstanding)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">current = sdk.DecCoins{}</span>
        } else<span class="cov8" title="1"> {
                // note: necessary to truncate so we don't allow withdrawing more rewards than owed
                current = rewards.Rewards.QuoDecTruncate(math.LegacyNewDecFromInt(reporter.TotalTokens))
        }</span>

        // fetch historical rewards for last period
        <span class="cov8" title="1">historical, err := k.ReporterHistoricalRewards.Get(ctx, collections.Join(reporterVal, rewards.Period-1))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">cumRewardRatio := historical.CumulativeRewardRatio

        // decrement reference count
        err = k.decrementReferenceCount(ctx, reporterVal, rewards.Period-1)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // set new historical rewards with reference count of 1
        <span class="cov8" title="1">err = k.ReporterHistoricalRewards.Set(ctx, collections.Join(reporterVal, rewards.Period), types.NewReporterHistoricalRewards(cumRewardRatio.Add(current...), 1))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // set current rewards, incrementing period by 1
        <span class="cov8" title="1">err = k.ReporterCurrentRewards.Set(ctx, reporterVal, types.NewReporterCurrentRewards(sdk.DecCoins{}, rewards.Period+1))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return rewards.Period, nil</span>
}

// calculate the rewards accrued by a delegation between two periods
func (k Keeper) calculateDelegationRewardsBetween(ctx context.Context, reporterVal sdk.ValAddress,
        startingPeriod, endingPeriod uint64, stake math.Int,
) (sdk.DecCoins, error) <span class="cov8" title="1">{
        // sanity check
        if startingPeriod &gt; endingPeriod </span><span class="cov0" title="0">{
                return sdk.DecCoins{}, fmt.Errorf("startingPeriod cannot be greater than endingPeriod")
        }</span>

        // sanity check
        <span class="cov8" title="1">if stake.IsNegative() </span><span class="cov0" title="0">{
                return sdk.DecCoins{}, fmt.Errorf("stake should not be negative")
        }</span>

        // return staking * (ending - starting)
        <span class="cov8" title="1">starting, err := k.ReporterHistoricalRewards.Get(ctx, collections.Join(reporterVal, startingPeriod))
        if err != nil </span><span class="cov0" title="0">{
                return sdk.DecCoins{}, err
        }</span>

        <span class="cov8" title="1">ending, err := k.ReporterHistoricalRewards.Get(ctx, collections.Join(reporterVal, endingPeriod))
        if err != nil </span><span class="cov0" title="0">{
                return sdk.DecCoins{}, err
        }</span>

        <span class="cov8" title="1">difference := ending.CumulativeRewardRatio.Sub(starting.CumulativeRewardRatio)
        if difference.IsAnyNegative() </span><span class="cov0" title="0">{
                return sdk.DecCoins{}, fmt.Errorf("negative rewards should not be possible")
        }</span>
        // note: necessary to truncate so we don't allow withdrawing more rewards than owed
        <span class="cov8" title="1">rewards := difference.MulDecTruncate(math.LegacyNewDecFromInt(stake))
        return rewards, nil</span>
}

// decrement the reference count for a historical rewards value, and delete if zero references remain
func (k Keeper) decrementReferenceCount(ctx context.Context, reporterAddr sdk.ValAddress, period uint64) error <span class="cov8" title="1">{
        historical, err := k.ReporterHistoricalRewards.Get(ctx, collections.Join(reporterAddr, period))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if historical.ReferenceCount == 0 </span><span class="cov0" title="0">{
                panic("cannot set negative reference count")</span>
        }
        <span class="cov8" title="1">historical.ReferenceCount--
        if historical.ReferenceCount == 0 </span><span class="cov8" title="1">{
                return k.ReporterHistoricalRewards.Remove(ctx, collections.Join(reporterAddr, period))
        }</span>

        <span class="cov8" title="1">return k.ReporterHistoricalRewards.Set(ctx, collections.Join(reporterAddr, period), historical)</span>
}

// GetTotalRewards returns the total amount of fee distribution rewards held in the store
func (k Keeper) GetTotalRewards(ctx context.Context) (totalRewards sdk.DecCoins) <span class="cov0" title="0">{
        err := k.ReporterOutstandingRewards.Walk(ctx, nil, func(_ sdk.ValAddress, rewards types.ReporterOutstandingRewards) (stop bool, err error) </span><span class="cov0" title="0">{
                totalRewards = totalRewards.Add(rewards.Rewards...)
                return false, nil
        }</span>,
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return totalRewards</span>
}

// get outstanding rewards
func (k Keeper) GetReporterOutstandingRewardsCoins(ctx context.Context, reporterVal sdk.ValAddress) (sdk.DecCoins, error) <span class="cov8" title="1">{
        rewards, err := k.ReporterOutstandingRewards.Get(ctx, reporterVal)
        if err != nil &amp;&amp; !errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return rewards.Rewards, nil</span>
}

// iterate over slash events between heights, inclusive
func (k Keeper) IterateReporterDisputeEventsBetween(ctx context.Context, reporterVal sdk.ValAddress, startingHeight, endingHeight uint64,
        handler func(height uint64, event types.ReporterDisputeEvent) (stop bool),
) error <span class="cov8" title="1">{
        rng := new(collections.Range[collections.Triple[sdk.ValAddress, uint64, uint64]]).
                StartInclusive(collections.Join3(reporterVal, startingHeight, uint64(0))).
                EndExclusive(collections.Join3(reporterVal, endingHeight+1, uint64(gomath.MaxUint64)))

        err := k.ReporterDisputeEvents.Walk(ctx, rng, func(k collections.Triple[sdk.ValAddress, uint64, uint64], ev types.ReporterDisputeEvent) (stop bool, err error) </span><span class="cov8" title="1">{
                height := k.K2()
                if handler(height, ev) </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
                <span class="cov8" title="1">return false, nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (k Keeper) initializeReporter(ctx context.Context, reporter types.OracleReporter) error <span class="cov8" title="1">{
        valBz := sdk.ValAddress(sdk.MustAccAddressFromBech32(reporter.Reporter))
        // set initial historical rewards (period 0) with reference count of 1
        err := k.ReporterHistoricalRewards.Set(ctx, collections.Join(valBz, uint64(0)), types.NewReporterHistoricalRewards(sdk.DecCoins{}, 1))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // set current rewards (starting at period 1)
        <span class="cov8" title="1">err = k.ReporterCurrentRewards.Set(ctx, valBz, types.NewReporterCurrentRewards(sdk.DecCoins{}, 1))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // set accumulated commission
        <span class="cov8" title="1">err = k.ReportersAccumulatedCommission.Set(ctx, valBz, types.ReporterAccumulatedCommission{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // set outstanding rewards
        <span class="cov8" title="1">err = k.ReporterOutstandingRewards.Set(ctx, valBz, types.ReporterOutstandingRewards{Rewards: sdk.DecCoins{}})
        return err</span>
}

func (k Keeper) updateReporterDisputeFraction(ctx context.Context, reporterVal sdk.ValAddress, fraction math.LegacyDec) error <span class="cov8" title="1">{
        if fraction.GT(math.LegacyOneDec()) || fraction.IsNegative() </span><span class="cov0" title="0">{
                return fmt.Errorf("fraction must be &gt;=0 and &lt;=1, current fraction: %v", fraction)
        }</span>

        <span class="cov8" title="1">sdkCtx := sdk.UnwrapSDKContext(ctx)
        reporter, err := k.Reporters.Get(ctx, sdk.AccAddress(reporterVal))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // increment current period
        <span class="cov8" title="1">newPeriod, err := k.IncrementReporterPeriod(ctx, reporter)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // increment reference count on period we need to track
        <span class="cov8" title="1">err = k.incrementReferenceCount(ctx, reporterVal, newPeriod)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">slashEvent := types.NewReporterDisputeEvent(newPeriod, fraction)
        height := uint64(sdkCtx.BlockHeight())

        return k.ReporterDisputeEvents.Set(
                ctx,
                collections.Join3[sdk.ValAddress, uint64, uint64](
                        reporterVal,
                        height,
                        newPeriod,
                ),
                slashEvent,
        )</span>
}

// Hooks to implement part of reporter crud operations
func (k Keeper) AfterReporterRemoved(ctx context.Context, reporterVal sdk.ValAddress) error <span class="cov8" title="1">{
        // fetch outstanding
        outstanding, err := k.GetReporterOutstandingRewardsCoins(ctx, reporterVal)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // force-withdraw commission
        <span class="cov8" title="1">reporterCommission, err := k.ReportersAccumulatedCommission.Get(ctx, reporterVal)
        if err != nil &amp;&amp; !errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">commission := reporterCommission.Commission

        if !commission.IsZero() </span><span class="cov0" title="0">{
                // subtract from outstanding
                outstanding = outstanding.Sub(commission)

                // split into integral &amp; remainder
                coins, remainder := commission.TruncateDecimal()
                // TODO: burn remainder (inflationary?)
                _ = remainder

                // add to reporter account
                if !coins.IsZero() </span><span class="cov0" title="0">{
                        if err := k.bankKeeper.SendCoinsFromModuleToAccount(ctx, types.ModuleName, sdk.AccAddress(reporterVal), coins); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        // "TODO: burn outstanding dust"
        <span class="cov8" title="1">_ = outstanding

        // delete outstanding
        err = k.ReporterOutstandingRewards.Remove(ctx, reporterVal)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // remove commission record
        <span class="cov8" title="1">err = k.ReportersAccumulatedCommission.Remove(ctx, reporterVal)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // clear disputes
        <span class="cov8" title="1">err = k.ReporterDisputeEvents.Clear(ctx, collections.NewPrefixedTripleRange[sdk.ValAddress, uint64, uint64](reporterVal))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // clear historical rewards
        <span class="cov8" title="1">err = k.ReporterHistoricalRewards.Clear(ctx, collections.NewPrefixedPairRange[sdk.ValAddress, uint64](reporterVal))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // clear current rewards
        <span class="cov8" title="1">err = k.ReporterCurrentRewards.Remove(ctx, reporterVal)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// initialize reporter
func (k Keeper) AfterReporterCreated(ctx context.Context, reporter types.OracleReporter) error <span class="cov8" title="1">{
        return k.initializeReporter(ctx, reporter)
}</span>

// increment period
func (k Keeper) BeforeDelegationCreated(ctx context.Context, reporter types.OracleReporter) error <span class="cov8" title="1">{
        _, err := k.IncrementReporterPeriod(ctx, reporter)
        return err
}</span>

// withdraw delegation rewards (which also increments period)
func (k Keeper) BeforeDelegationModified(ctx context.Context, delAddr sdk.AccAddress, del types.Delegation, reporter types.OracleReporter) error <span class="cov8" title="1">{
        _, err := k.withdrawDelegationRewards(ctx, reporter, delAddr, del)
        return err
}</span>

// create new delegation period record
func (k Keeper) AfterDelegationModified(ctx context.Context, delAddr sdk.AccAddress, reporterVal sdk.ValAddress, stake math.Int) error <span class="cov8" title="1">{
        delegator, err := k.Delegators.Get(ctx, delAddr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">repAddr := sdk.MustAccAddressFromBech32(delegator.Reporter)

        sdkCtx := sdk.UnwrapSDKContext(ctx)
        snapshotKey := collections.Join(repAddr, sdkCtx.BlockHeight())
        // get all the token origins for the reporter
        tokenSources, err := k.GetTokenSourcesForReporter(ctx, repAddr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = k.TokenOriginSnapshot.Set(ctx, snapshotKey, tokenSources)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return k.initializeDelegation(ctx, reporterVal, delAddr, stake)</span>
}

// record the dispute event
func (k Keeper) BeforeReporterDisputed(ctx context.Context, valAddr sdk.ValAddress, fraction math.LegacyDec) error <span class="cov8" title="1">{
        return k.updateReporterDisputeFraction(ctx, valAddr, fraction)
}</span>

func (k Keeper) GetTokenOriginsAtHeight(ctx context.Context, repAddr sdk.AccAddress, height int64) (types.DelegationsPreUpdate, error) <span class="cov0" title="0">{
        return k.TokenOriginSnapshot.Get(ctx, collections.Join(repAddr, height))
}</span>

func (k Keeper) DivvyingTips(ctx context.Context, reporterAddr sdk.AccAddress, reward math.Int) error <span class="cov0" title="0">{
        reporter, err := k.Reporters.Get(ctx, reporterAddr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Calculate commission
        <span class="cov0" title="0">commission := math.LegacyNewDecFromInt(reward).Mul(reporter.Commission.Rate)

        // Calculate net reward
        netReward := math.LegacyNewDecFromInt(reward).Sub(commission)

        // Calculate each delegator's share (including the reporter as a self-delegator)
        repAddr, err := sdk.AccAddressFromBech32(reporter.Reporter)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">delAddrs, err := k.Delegators.Indexes.Reporter.MatchExact(ctx, repAddr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer delAddrs.Close()
        for ; delAddrs.Valid(); delAddrs.Next() </span><span class="cov0" title="0">{
                key, err := delAddrs.PrimaryKey()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">del, err := k.Delegators.Get(ctx, key)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">delegatorShare := netReward.Mul(math.LegacyNewDecFromInt(del.Amount)).Quo(math.LegacyNewDecFromInt(reporter.TotalTokens))
                if key.Equals(repAddr) </span><span class="cov0" title="0">{
                        delegatorShare = delegatorShare.Add(commission)
                }</span>
                <span class="cov0" title="0">err = k.DelegatorTips.Set(ctx, key, delegatorShare.TruncateInt())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (k Keeper) returnSlashedTokens(ctx context.Context, repAddr sdk.AccAddress, blockHeight int64, _ math.Int) error <span class="cov0" title="0">{

        snapshot, err := k.GetTokenOriginsAtHeight(ctx, repAddr, blockHeight)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // amt should be equal to sum of snapshot origins
        // var totalAmt = math.ZeroInt()
        <span class="cov0" title="0">for _, source := range snapshot.TokenOrigins </span><span class="cov0" title="0">{
                // totalAmt = totalAmt.Add(source.Amount)
                valAddr, err := sdk.ValAddressFromBech32(source.ValidatorAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">var val stakingtypes.Validator
                val, err = k.stakingKeeper.GetValidator(ctx, valAddr)
                if err != nil </span><span class="cov0" title="0">{
                        if !errors.Is(err, stakingtypes.ErrNoValidatorFound) </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">vals, err := k.GetBondedValidators(ctx, 1)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if len(vals) == 0 </span><span class="cov0" title="0">{
                                return errors.New("no validators found in staking module to return tokens to")
                        }</span>
                        <span class="cov0" title="0">val = vals[0]</span>
                }
                <span class="cov0" title="0">delAddr, err := sdk.AccAddressFromBech32(source.DelegatorAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">_, err = k.stakingKeeper.Delegate(ctx, delAddr, source.Amount, stakingtypes.Unbonded, val, false)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        }

        // assert totalAmt == amt
        <span class="cov0" title="0">return nil</span>
}

func (k Keeper) GetBondedValidators(ctx context.Context, max uint32) ([]stakingtypes.Validator, error) <span class="cov0" title="0">{
        validators := make([]stakingtypes.Validator, max)

        iterator, err := k.stakingKeeper.ValidatorsPowerStoreIterator(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer iterator.Close()

        i := 0
        for ; iterator.Valid() &amp;&amp; i &lt; int(max); iterator.Next() </span><span class="cov0" title="0">{
                address := iterator.Value()
                validator, err := k.stakingKeeper.GetValidator(ctx, address)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("validator record not found for address: %X", address)
                }</span>

                <span class="cov0" title="0">if validator.IsBonded() </span><span class="cov0" title="0">{
                        validators[i] = validator
                        i++
                }</span>
        }

        <span class="cov0" title="0">return validators[:i], nil</span> // trim
}

func (k Keeper) ReturnSlashedTokens(ctx context.Context, reporterAddr string, height int64, reward math.Int) error <span class="cov0" title="0">{
        repAcc, err := sdk.AccAddressFromBech32(reporterAddr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">reporter, err := k.Reporters.Get(ctx, repAcc)
        if err != nil </span><span class="cov0" title="0">{
                if !errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return k.returnSlashedTokens(ctx, repAcc, height, reward)</span>
        }

        <span class="cov0" title="0">snapshot, err := k.GetTokenOriginsAtHeight(ctx, repAcc, height)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, source := range snapshot.TokenOrigins </span><span class="cov0" title="0">{
                // attempt to get delegation in reporter module first
                valAddr, err := sdk.ValAddressFromBech32(source.ValidatorAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">delAddr, err := sdk.AccAddressFromBech32(source.DelegatorAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">del, err := k.Delegators.Get(ctx, delAddr)
                if err != nil </span><span class="cov0" title="0">{
                        if !errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // if delegator no longer exists, create a new one and
                        // delegate tokens to a randomly selected bonded validator
                        <span class="cov0" title="0">del.Amount = source.Amount
                        del.Reporter = repAcc.String()
                        // call hooks :todo
                        if err := k.BeforeDelegationCreated(ctx, reporter); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := k.Delegators.Set(ctx, delAddr, del); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := k.AfterDelegationModified(ctx, delAddr, repAcc.Bytes(), del.Amount); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">vals, err := k.GetBondedValidators(ctx, 1)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // this should never happen since chains need validators to run
                        <span class="cov0" title="0">if len(vals) == 0 </span><span class="cov0" title="0">{
                                return errors.New("no validators found in staking module to return tokens to")
                        }</span>
                        <span class="cov0" title="0">newVal, err := sdk.ValAddressFromBech32(vals[0].GetOperator())
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := k.TokenOrigin.Set(ctx, collections.Join(delAddr, newVal), source.Amount); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">_, err = k.stakingKeeper.Delegate(ctx, delAddr, source.Amount, stakingtypes.Bonded, vals[0], false)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                // if delegator exists, add tokens to it
                // call hooks :todo
                <span class="cov0" title="0">if err := k.BeforeDelegationModified(ctx, delAddr, del, reporter); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">del.Amount = del.Amount.Add(source.Amount)

                if err := k.Delegators.Set(ctx, delAddr, del); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := k.AfterDelegationModified(ctx, delAddr, repAcc.Bytes(), del.Amount); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // get token origin and see if it still exists
                <span class="cov0" title="0">prevAmt, err := k.TokenOrigin.Get(ctx, collections.Join(delAddr, valAddr))
                if err != nil </span><span class="cov0" title="0">{
                        if !errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        /*
                                // you can try the same previous validator even though it doesn't exist in tokenorigin store
                                // or just directly use go for a random bonded validator
                                // validator, err := k.stakingKeeper.GetValidator(ctx, valAddr)
                                // if err != nil {
                                //         if !errors.Is(err, stakingtypes.ErrNoValidatorFound) {
                                //                 return err
                                //         }
                                // }
                                // if err != nil || !validator.IsBonded() {
                                //         vals, err := k.GetBondedValidators(ctx, 1)
                                //         if err != nil {
                                //                 return err
                                //         }
                                //         validator = vals[0]
                                //         valAddr, err = sdk.ValAddressFromBech32(validator.GetOperator())
                                //         if err != nil {
                                //                 return err
                                //         }

                                // }
                        */
                        <span class="cov0" title="0">vals, err := k.GetBondedValidators(ctx, 1)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">randoValidator := vals[0]
                        randoValAddr, err := sdk.ValAddressFromBech32(randoValidator.GetOperator())
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // should probably make sure the random validator is not in tokenOrigin store first
                        // to avoid overwriting
                        <span class="cov0" title="0">randoAmt, err := k.TokenOrigin.Get(ctx, collections.Join(delAddr, randoValAddr))
                        if err != nil </span><span class="cov0" title="0">{
                                if !errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">if randoAmt.IsNil() </span><span class="cov0" title="0">{
                                randoAmt = math.ZeroInt()
                        }</span>
                        <span class="cov0" title="0">randoAmt = randoAmt.Add(source.Amount)
                        // if token origin no longer exists, set it
                        if err := k.TokenOrigin.Set(ctx, collections.Join(delAddr, valAddr), randoAmt); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">_, err = k.stakingKeeper.Delegate(ctx, delAddr, source.Amount, stakingtypes.Bonded, randoValidator, false)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">continue</span>

                }
                // at this stage the validator exists in tokenorigin store meaning key(delagator, validator) exists
                // first we see if stored validator is bonded
                <span class="cov0" title="0">validator, err := k.stakingKeeper.GetValidator(ctx, valAddr)
                if err != nil </span><span class="cov0" title="0">{
                        if !errors.Is(err, stakingtypes.ErrNoValidatorFound) </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">if err != nil || !validator.IsBonded() </span><span class="cov0" title="0">{
                        vals, err := k.GetBondedValidators(ctx, 1)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">validator = vals[0]
                        valAddr, err = sdk.ValAddressFromBech32(validator.GetOperator())
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // double check to make sure the random validator is not in tokenOrigin store first
                        <span class="cov0" title="0">prevAmt, err = k.TokenOrigin.Get(ctx, collections.Join(delAddr, valAddr))
                        if err != nil </span><span class="cov0" title="0">{
                                if !errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
                <span class="cov0" title="0">if prevAmt.IsNil() </span><span class="cov0" title="0">{
                        prevAmt = math.ZeroInt()
                }</span>
                <span class="cov0" title="0">prevAmt = prevAmt.Add(source.Amount)
                if err := k.TokenOrigin.Set(ctx, collections.Join(delAddr, valAddr), prevAmt); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">_, err = k.stakingKeeper.Delegate(ctx, delAddr, source.Amount, stakingtypes.Bonded, validator, false)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">continue</span>

        }
        <span class="cov0" title="0">reporter.TotalTokens = reporter.TotalTokens.Add(reward)
        return k.Reporters.Set(ctx, repAcc, reporter)</span>
}

func (k Keeper) AddAmountToStake(ctx context.Context, addr string, amt math.Int) error <span class="cov0" title="0">{
        acc, err := sdk.AccAddressFromBech32(addr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">vals, err := k.GetBondedValidators(ctx, 1)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">validator := vals[0]

        _, err = k.stakingKeeper.Delegate(ctx, acc, amt, stakingtypes.Bonded, validator, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file163" style="display: none">package keeper

import (
        "context"

        "cosmossdk.io/collections"
        sdkmath "cosmossdk.io/math"
        "github.com/tellor-io/layer/x/reporter/types"

        cryptotypes "github.com/cosmos/cosmos-sdk/crypto/types"
        sdk "github.com/cosmos/cosmos-sdk/types"
)

var _ types.StakingHooks = Hooks{}

// Hooks wrapper struct for reporter keeper
type Hooks struct {
        k Keeper
}

// Return the reporter hooks
func (k Keeper) Hooks() Hooks <span class="cov0" title="0">{
        return Hooks{k}
}</span>

// AfterValidatorBonded updates the signing info start height or create a new signing info
func (h Hooks) AfterValidatorBonded(_ context.Context, _ sdk.ConsAddress, _ sdk.ValAddress) error <span class="cov0" title="0">{
        return nil
}</span>

// AfterValidatorRemoved deletes the address-pubkey relation when a validator is removed,
func (h Hooks) AfterValidatorRemoved(_ context.Context, _ sdk.ConsAddress, _ sdk.ValAddress) error <span class="cov0" title="0">{
        return nil
}</span>

// AfterValidatorCreated adds the address-pubkey relation when a validator is created.
func (h Hooks) AfterValidatorCreated(_ context.Context, _ sdk.ValAddress) error <span class="cov0" title="0">{
        return nil
}</span>

func (h Hooks) AfterValidatorBeginUnbonding(_ context.Context, _ sdk.ConsAddress, _ sdk.ValAddress) error <span class="cov0" title="0">{
        return nil
}</span>

func (h Hooks) BeforeValidatorModified(_ context.Context, _ sdk.ValAddress) error <span class="cov0" title="0">{
        return nil
}</span>

func (h Hooks) BeforeDelegationCreated(_ context.Context, _ sdk.AccAddress, _ sdk.ValAddress) error <span class="cov0" title="0">{
        return nil
}</span>

func (h Hooks) BeforeDelegationSharesModified(_ context.Context, _ sdk.AccAddress, _ sdk.ValAddress) error <span class="cov0" title="0">{
        return nil
}</span>

func (h Hooks) BeforeDelegationRemoved(_ context.Context, _ sdk.AccAddress, _ sdk.ValAddress) error <span class="cov0" title="0">{
        return nil
}</span>

func (h Hooks) AfterDelegationModified(ctx context.Context, delAddr sdk.AccAddress, valAddr sdk.ValAddress) error <span class="cov0" title="0">{
        // reflect changes only when token/power decreases
        // update the reporter tokens and the delegator's tokens to reflect the new power numbers
        // also need to update the token origins to reflect the new changes when the delegator's tokens are updated
        exists, err := h.k.TokenOrigin.Has(ctx, collections.Join(delAddr, valAddr))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                // get delegation
                delegation, err := h.k.stakingKeeper.Delegation(ctx, delAddr, valAddr)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // get validator to calculate token amount from shares
                <span class="cov0" title="0">validator, err := h.k.stakingKeeper.GetValidator(ctx, valAddr)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">tokenAmount := validator.TokensFromSharesTruncated(delegation.GetShares()).TruncateInt()
                // get token origin
                sourced, err := h.k.TokenOrigin.Get(ctx, collections.Join(delAddr, valAddr))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // update token origin if the staked amount becomes less than what is written in the token origin struct
                <span class="cov0" title="0">if tokenAmount.LT(sourced) </span><span class="cov0" title="0">{
                        delegator, err := h.k.Delegators.Get(ctx, delAddr)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">repAddr := sdk.MustAccAddressFromBech32(delegator.Reporter)

                        // get the difference in the token change to reduce delegation and reporter tokens by.
                        diff := sourced.Sub(tokenAmount)
                        if err := h.k.UpdateOrRemoveSource(ctx, collections.Join(delAddr, valAddr), sourced, tokenAmount); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // update reporter
                        <span class="cov0" title="0">reporter, err := h.k.Reporters.Get(ctx, repAddr)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := h.k.UpdateOrRemoveDelegator(ctx, delAddr, delegator, reporter, diff); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := h.k.UpdateOrRemoveReporter(ctx, repAddr, reporter, diff); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

        }
        <span class="cov0" title="0">return nil</span>
}

func (h Hooks) BeforeValidatorSlashed(_ context.Context, _ sdk.ValAddress, _ sdkmath.LegacyDec) error <span class="cov0" title="0">{
        return nil
}</span>

func (h Hooks) AfterUnbondingInitiated(_ context.Context, _ uint64) error <span class="cov0" title="0">{
        return nil
}</span>

// AfterConsensusPubKeyUpdate triggers the functions to rotate the signing-infos also sets address pubkey relation.
func (h Hooks) AfterConsensusPubKeyUpdate(_ context.Context, _, _ cryptotypes.PubKey, _ sdk.Coin) error <span class="cov0" title="0">{
        return nil
}</span>

func (k Keeper) GetTokenSourcesForReporter(ctx context.Context, repAddr sdk.AccAddress) (types.DelegationsPreUpdate, error) <span class="cov8" title="1">{
        delegators, err := k.Delegators.Indexes.Reporter.MatchExact(ctx, repAddr)
        if err != nil </span><span class="cov0" title="0">{
                return types.DelegationsPreUpdate{}, err
        }</span>

        <span class="cov8" title="1">var tokenSources []*types.TokenOriginInfo
        for ; delegators.Valid(); delegators.Next() </span><span class="cov8" title="1">{
                key, err := delegators.PrimaryKey()
                if err != nil </span><span class="cov0" title="0">{
                        return types.DelegationsPreUpdate{}, err
                }</span>
                <span class="cov8" title="1">rng := collections.NewPrefixedPairRange[sdk.AccAddress, sdk.ValAddress](key)
                err = k.TokenOrigin.Walk(ctx, rng, func(key collections.Pair[sdk.AccAddress, sdk.ValAddress], value sdkmath.Int) (bool, error) </span><span class="cov8" title="1">{
                        tokenSources = append(tokenSources, &amp;types.TokenOriginInfo{
                                DelegatorAddress: key.K1().String(),
                                ValidatorAddress: key.K2().String(),
                                Amount:           value,
                        })
                        return false, nil
                }</span>)
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return types.DelegationsPreUpdate{}, err
                }</span>
        }
        <span class="cov8" title="1">return types.DelegationsPreUpdate{
                TokenOrigins: tokenSources,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file164" style="display: none">package keeper

import (
        "cosmossdk.io/collections"
        "cosmossdk.io/collections/indexes"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/reporter/types"
)

type ReporterDelegatorsIndex struct {
        Reporter *indexes.Multi[sdk.AccAddress, sdk.AccAddress, types.Delegation]
}

func (a ReporterDelegatorsIndex) IndexesList() []collections.Index[sdk.AccAddress, types.Delegation] <span class="cov8" title="1">{
        return []collections.Index[sdk.AccAddress, types.Delegation]{a.Reporter}
}</span>

func NewDelegatorsIndex(sb *collections.SchemaBuilder) ReporterDelegatorsIndex <span class="cov8" title="1">{
        return ReporterDelegatorsIndex{
                Reporter: indexes.NewMulti(
                        sb, types.ReporterDelegatorsIndexPrefix, "reporter_delegators_index",
                        sdk.AccAddressKey, sdk.AccAddressKey,
                        func(k sdk.AccAddress, del types.Delegation) (sdk.AccAddress, error) </span><span class="cov8" title="1">{
                                return sdk.AccAddressFromBech32(del.Reporter)
                        }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file165" style="display: none">package keeper

import (
        "context"
        "strconv"
        "time"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/reporter/types"
)

// send a reporter to jail
func (k Keeper) JailReporter(ctx context.Context, reporterAddr sdk.AccAddress, jailDuration int64) error <span class="cov0" title="0">{
        reporter, err := k.Reporters.Get(ctx, reporterAddr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if reporter.Jailed </span><span class="cov0" title="0">{
                return types.ErrReporterJailed.Wrapf("cannot jail already jailed reporter, %v", reporter)
        }</span>
        <span class="cov0" title="0">sdkctx := sdk.UnwrapSDKContext(ctx)
        reporter.JailedUntil = sdkctx.BlockTime().Add(time.Second * time.Duration(jailDuration))
        reporter.Jailed = true
        err = k.Reporters.Set(ctx, reporterAddr, reporter)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">sdkctx.EventManager().EmitEvents(sdk.Events{
                sdk.NewEvent(
                        "jailed_reporter",
                        sdk.NewAttribute("reporter", reporterAddr.String()),
                        sdk.NewAttribute("duration", strconv.FormatInt(jailDuration, 10)),
                ),
        })
        return nil</span>
}

// remove a reporter from jail
func (k Keeper) unjailReporter(ctx context.Context, reporterAddr sdk.AccAddress, reporter types.OracleReporter) error <span class="cov0" title="0">{
        if !reporter.Jailed </span><span class="cov0" title="0">{
                return types.ErrReporterNotJailed.Wrapf("cannot unjail already unjailed reporter, %v", reporter)
        }</span>

        <span class="cov0" title="0">sdkctx := sdk.UnwrapSDKContext(ctx)
        if sdkctx.BlockTime().Before(reporter.JailedUntil) </span><span class="cov0" title="0">{
                return types.ErrReporterJailed.Wrapf("cannot unjail reporter before jail time is up, %v", reporter)
        }</span>

        <span class="cov0" title="0">reporter.Jailed = false

        return k.Reporters.Set(ctx, reporterAddr, reporter)</span>
}
</pre>
		
		<pre class="file" id="file166" style="display: none">package keeper

import (
        "fmt"

        "cosmossdk.io/collections"
        "cosmossdk.io/core/store"
        "cosmossdk.io/log"
        "cosmossdk.io/math"
        "github.com/cosmos/cosmos-sdk/codec"
        sdk "github.com/cosmos/cosmos-sdk/types"

        "github.com/tellor-io/layer/x/reporter/types"
)

type (
        Keeper struct {
                cdc                            codec.BinaryCodec
                storeService                   store.KVStoreService
                Params                         collections.Item[types.Params]
                Reporters                      collections.Map[sdk.AccAddress, types.OracleReporter]
                DelegatorTips                  collections.Map[sdk.AccAddress, math.Int]
                Delegators                     *collections.IndexedMap[sdk.AccAddress, types.Delegation, ReporterDelegatorsIndex]
                TokenOrigin                    collections.Map[collections.Pair[sdk.AccAddress, sdk.ValAddress], math.Int]
                ReportersAccumulatedCommission collections.Map[sdk.ValAddress, types.ReporterAccumulatedCommission]
                ReporterOutstandingRewards     collections.Map[sdk.ValAddress, types.ReporterOutstandingRewards]
                ReporterCurrentRewards         collections.Map[sdk.ValAddress, types.ReporterCurrentRewards]
                DelegatorStartingInfo          collections.Map[collections.Pair[sdk.ValAddress, sdk.AccAddress], types.DelegatorStartingInfo]
                ReporterHistoricalRewards      collections.Map[collections.Pair[sdk.ValAddress, uint64], types.ReporterHistoricalRewards]
                ReporterDisputeEvents          collections.Map[collections.Triple[sdk.ValAddress, uint64, uint64], types.ReporterDisputeEvent]
                TokenOriginSnapshot            collections.Map[collections.Pair[sdk.AccAddress, int64], types.DelegationsPreUpdate]

                Schema collections.Schema
                logger log.Logger

                // the address capable of executing a MsgUpdateParams message. Typically, this
                // should be the x/gov module account.
                authority string

                stakingKeeper types.StakingKeeper
                bankKeeper    types.BankKeeper
        }
)

func NewKeeper(
        cdc codec.BinaryCodec,
        storeService store.KVStoreService,
        logger log.Logger,
        authority string,

        stakingKeeper types.StakingKeeper,
        bankKeeper types.BankKeeper,
) Keeper <span class="cov8" title="1">{
        if _, err := sdk.AccAddressFromBech32(authority); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("invalid authority address: %s", authority))</span>
        }
        <span class="cov8" title="1">sb := collections.NewSchemaBuilder(storeService)
        k := Keeper{
                cdc:          cdc,
                storeService: storeService,

                Params:                         collections.NewItem(sb, types.ParamsKey, "params", codec.CollValue[types.Params](cdc)),
                Reporters:                      collections.NewMap(sb, types.ReportersKey, "reporters_by_reporter", sdk.AccAddressKey, codec.CollValue[types.OracleReporter](cdc)),
                Delegators:                     collections.NewIndexedMap(sb, types.DelegatorsKey, "delegations_by_delegator", sdk.AccAddressKey, codec.CollValue[types.Delegation](cdc), NewDelegatorsIndex(sb)),
                TokenOrigin:                    collections.NewMap(sb, types.TokenOriginsKey, "token_origins_by_delegator_validator", collections.PairKeyCodec(sdk.AccAddressKey, sdk.ValAddressKey), sdk.IntValue),
                ReportersAccumulatedCommission: collections.NewMap(sb, types.ReporterAccumulatedCommissionPrefix, "reporters_accumulated_commission", sdk.ValAddressKey, codec.CollValue[types.ReporterAccumulatedCommission](cdc)),
                ReporterOutstandingRewards:     collections.NewMap(sb, types.ReporterOutstandingRewardsPrefix, "reporter_outstanding_rewards", sdk.ValAddressKey, codec.CollValue[types.ReporterOutstandingRewards](cdc)),
                ReporterCurrentRewards:         collections.NewMap(sb, types.ReporterCurrentRewardsPrefix, "reporters_current_rewards", sdk.ValAddressKey, codec.CollValue[types.ReporterCurrentRewards](cdc)),
                DelegatorStartingInfo:          collections.NewMap(sb, types.DelegatorStartingInfoPrefix, "delegators_starting_info", collections.PairKeyCodec(sdk.ValAddressKey, sdk.AccAddressKey), codec.CollValue[types.DelegatorStartingInfo](cdc)),
                ReporterHistoricalRewards:      collections.NewMap(sb, types.ReporterHistoricalRewardsPrefix, "reporter_historical_rewards", collections.PairKeyCodec(sdk.ValAddressKey, collections.Uint64Key), codec.CollValue[types.ReporterHistoricalRewards](cdc)),
                ReporterDisputeEvents:          collections.NewMap(sb, types.ReporterDisputeEventPrefix, "reporter_dispute_events", collections.TripleKeyCodec(sdk.ValAddressKey, collections.Uint64Key, collections.Uint64Key), codec.CollValue[types.ReporterDisputeEvent](cdc)),
                TokenOriginSnapshot:            collections.NewMap(sb, types.TokenOriginSnapshotPrefix, "token_origin_snapshot", collections.PairKeyCodec(sdk.AccAddressKey, collections.Int64Key), codec.CollValue[types.DelegationsPreUpdate](cdc)),
                authority:                      authority,
                logger:                         logger,
                stakingKeeper:                  stakingKeeper,
                bankKeeper:                     bankKeeper,
                DelegatorTips:                  collections.NewMap(sb, types.DelegatorTipsPrefix, "delegator_tips", sdk.AccAddressKey, sdk.IntValue),
        }
        schema, err := sb.Build()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">k.Schema = schema
        return k</span>
}

// GetAuthority returns the module's authority.
func (k Keeper) GetAuthority() string <span class="cov8" title="1">{
        return k.authority
}</span>

// Logger returns a module-specific logger.
func (k Keeper) Logger() log.Logger <span class="cov0" title="0">{
        return k.logger.With("module", fmt.Sprintf("x/%s", types.ModuleName))
}</span>
</pre>
		
		<pre class="file" id="file167" style="display: none">package keeper

import (
        "context"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/reporter/types"
)

type msgServer struct {
        Keeper
}

// NewMsgServerImpl returns an implementation of the MsgServer interface
// for the provided Keeper.
func NewMsgServerImpl(keeper Keeper) types.MsgServer <span class="cov8" title="1">{
        return &amp;msgServer{Keeper: keeper}
}</span>

var _ types.MsgServer = msgServer{}

func (k msgServer) WithdrawDelegatorReward(ctx context.Context, msg *types.MsgWithdrawDelegatorReward) (*types.MsgWithdrawDelegatorRewardResponse, error) <span class="cov0" title="0">{
        reporterVal := sdk.MustAccAddressFromBech32(msg.ReporterAddress)
        delAddr := sdk.MustAccAddressFromBech32(msg.DelegatorAddress)

        amount, err := k.WithdrawDelegationRewards(ctx, reporterVal.Bytes(), delAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;types.MsgWithdrawDelegatorRewardResponse{Amount: amount}, nil</span>
}

func (k msgServer) WithdrawReporterCommission(ctx context.Context, msg *types.MsgWithdrawReporterCommission) (*types.MsgWithdrawReporterCommissionResponse, error) <span class="cov0" title="0">{
        reporterVal := sdk.MustAccAddressFromBech32(msg.ReporterAddress)

        amount, err := k.Keeper.WithdrawReporterCommission(ctx, reporterVal.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;types.MsgWithdrawReporterCommissionResponse{Amount: amount}, nil</span>
}

func (k msgServer) UnjailReporter(goCtx context.Context, msg *types.MsgUnjailReporter) (*types.MsgUnjailReporterResponse, error) <span class="cov0" title="0">{
        ctx := sdk.UnwrapSDKContext(goCtx)

        reporterAddr := sdk.MustAccAddressFromBech32(msg.ReporterAddress)

        reporter, err := k.Reporters.Get(ctx, reporterAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := k.Keeper.unjailReporter(ctx, reporterAddr, reporter); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;types.MsgUnjailReporterResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file168" style="display: none">package keeper

import (
        "context"

        "cosmossdk.io/errors"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/reporter/types"
)

func (k msgServer) CreateReporter(goCtx context.Context, msg *types.MsgCreateReporter) (*types.MsgCreateReporterResponse, error) <span class="cov8" title="1">{
        ctx := sdk.UnwrapSDKContext(goCtx)
        reporter := sdk.MustAccAddressFromBech32(msg.Reporter)
        reporterExists, err := k.Reporters.Has(ctx, reporter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if reporterExists </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(types.ErrReporterExists, "cannot create reporter with address %s, it already exists", msg.Reporter)
        }</span>
        // check if reporter is delegated somewhere
        <span class="cov8" title="1">delegatorExists, err := k.Delegators.Has(ctx, reporter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if delegatorExists </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(types.ErrAddressDelegated, "cannot use address %s as reporter as it is already delegated", msg.Reporter)
        }</span>
        <span class="cov8" title="1">if err := k.Keeper.ValidateAndSetAmount(ctx, reporter, msg.TokenOrigins, msg.Amount); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">minCommRate, err := k.MinCommissionRate(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if msg.Commission.Rate.LT(minCommRate) </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(types.ErrCommissionLTMinRate, "cannot set validator commission to less than minimum rate of %s", minCommRate)
        }</span>

        <span class="cov8" title="1">commission := types.NewCommissionWithTime(msg.Commission.Rate, msg.Commission.MaxRate,
                msg.Commission.MaxChangeRate, ctx.HeaderInfo().Time)

        if err := commission.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // create a new reporter
        <span class="cov8" title="1">newOracleReporter := types.NewOracleReporter(msg.Reporter, msg.Amount, &amp;commission)
        if err := k.Reporters.Set(ctx, reporter, newOracleReporter); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // **********************  AfterReporterCreated  hook **************************************
        <span class="cov8" title="1">if err := k.Keeper.AfterReporterCreated(ctx, newOracleReporter); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // ************************************************************************************************
        // create a new delegation
        // **********************  BeforeDelegationCreated  hook **************************************
        <span class="cov8" title="1">if err := k.Keeper.BeforeDelegationCreated(ctx, newOracleReporter); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // ************************************************************************************************
        <span class="cov8" title="1">newDelegation := types.NewDelegation(msg.Reporter, msg.Amount)
        if err := k.Delegators.Set(ctx, reporter, newDelegation); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // **********************  AfterDelegationModified  hook **************************************
        <span class="cov8" title="1">if err := k.Keeper.AfterDelegationModified(ctx, reporter, sdk.ValAddress(reporter), newDelegation.Amount); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // ************************************************************************************************
        <span class="cov8" title="1">return &amp;types.MsgCreateReporterResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file169" style="display: none">package keeper

import (
        "context"
        "errors"

        errorsmod "cosmossdk.io/errors"

        "cosmossdk.io/collections"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/reporter/types"
)

func (k msgServer) DelegateReporter(goCtx context.Context, msg *types.MsgDelegateReporter) (*types.MsgDelegateReporterResponse, error) <span class="cov8" title="1">{
        ctx := sdk.UnwrapSDKContext(goCtx)

        delAddr := sdk.MustAccAddressFromBech32(msg.Delegator)
        repAddr := sdk.MustAccAddressFromBech32(msg.Reporter)

        // fetch reporter
        reporter, err := k.Reporters.Get(ctx, repAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">delegation, err := k.Delegators.Get(ctx, delAddr)
        if err != nil </span><span class="cov8" title="1">{
                if !errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                        return nil, err
                }</span> else<span class="cov8" title="1"> {
                        // create a new delegation
                        // **********************  BeforeDelegationCreated  hook **************************************
                        if err := k.BeforeDelegationCreated(ctx, reporter); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">delegation.Reporter = msg.Reporter
                        delegation.Amount = msg.Amount</span>
                }
        }
        <span class="cov8" title="1">if err == nil </span><span class="cov0" title="0">{
                // found delegation, update the amount
                // validate right reporter selected
                if delegation.Reporter != msg.Reporter </span><span class="cov0" title="0">{
                        return nil, errorsmod.Wrapf(types.ErrInvalidReporter, "Reporter mismatch for delegated address %s, expected %s, got %s", msg.Delegator, delegation.Reporter, msg.Reporter)
                }</span>
                // **********************  BeforeDelegationModified  hook **************************************
                <span class="cov0" title="0">if err := k.BeforeDelegationModified(ctx, delAddr, delegation, reporter); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">delegation.Amount = delegation.Amount.Add(msg.Amount)</span>
        }
        <span class="cov8" title="1">if err := k.Keeper.ValidateAndSetAmount(ctx, delAddr, msg.TokenOrigins, msg.Amount); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := k.Delegators.Set(ctx, delAddr, delegation); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // **********************  AfterDelegationModified  hook **************************************
        <span class="cov8" title="1">if err := k.AfterDelegationModified(ctx, delAddr, sdk.ValAddress(repAddr), delegation.Amount); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // update reporter total tokens
        <span class="cov8" title="1">reporter.TotalTokens = reporter.TotalTokens.Add(msg.Amount)
        if err := k.Reporters.Set(ctx, repAddr, reporter); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;types.MsgDelegateReporterResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file170" style="display: none">package keeper

import (
        "context"

        "cosmossdk.io/collections"
        "cosmossdk.io/math"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/tellor-io/layer/x/reporter/types"
)

func (k msgServer) UndelegateReporter(goCtx context.Context, msg *types.MsgUndelegateReporter) (*types.MsgUndelegateReporterResponse, error) <span class="cov8" title="1">{
        ctx := sdk.UnwrapSDKContext(goCtx)

        // fetch delegation
        delAddr := sdk.MustAccAddressFromBech32(msg.DelegatorAddress)
        delegation, err := k.Delegators.Get(ctx, delAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // fetch reporter
        <span class="cov8" title="1">repAddr := sdk.MustAccAddressFromBech32(delegation.Reporter)
        reporter, err := k.Reporters.Get(ctx, repAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var reducedbyAmount = math.ZeroInt()
        for _, source := range msg.TokenOrigins </span><span class="cov8" title="1">{
                valAddr, err := sdk.ValAddressFromBech32(source.ValidatorAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">currentSourceAmt, err := k.TokenOrigin.Get(ctx, collections.Join(delAddr, valAddr))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">err = k.UndelegateSource(ctx, collections.Join(delAddr, valAddr), currentSourceAmt, source.Amount)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">reducedbyAmount = reducedbyAmount.Add(source.Amount)</span>
        }

        <span class="cov8" title="1">if err := k.UpdateOrRemoveDelegator(ctx, delAddr, delegation, reporter, reducedbyAmount); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := k.UpdateOrRemoveReporter(ctx, repAddr, reporter, reducedbyAmount); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;types.MsgUndelegateReporterResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file171" style="display: none">package keeper

import (
        "context"
        "errors"

        sdk "github.com/cosmos/cosmos-sdk/types"
        stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
        "github.com/tellor-io/layer/x/reporter/types"

        layertypes "github.com/tellor-io/layer/types"
)

func (k msgServer) WithdrawTip(goCtx context.Context, msg *types.MsgWithdrawTip) (*types.MsgWithdrawTipResponse, error) <span class="cov0" title="0">{
        ctx := sdk.UnwrapSDKContext(goCtx)
        delAddr := sdk.MustAccAddressFromBech32(msg.DelegatorAddress)
        shares, err := k.Keeper.DelegatorTips.Get(ctx, delAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">valAddr, err := sdk.ValAddressFromBech32(msg.ValidatorAddress)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">val, err := k.stakingKeeper.GetValidator(ctx, valAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !val.IsBonded() </span><span class="cov0" title="0">{
                return nil, errors.New("chosen validator must be bonded")
        }</span>
        <span class="cov0" title="0">_, err = k.Keeper.stakingKeeper.Delegate(ctx, delAddr, shares, val.Status, val, false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = k.Keeper.DelegatorTips.Remove(ctx, delAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // send coins
        <span class="cov0" title="0">err = k.Keeper.bankKeeper.SendCoinsFromModuleToModule(ctx, types.TipsEscrowPool, stakingtypes.BondedPoolName, sdk.NewCoins(sdk.NewCoin(layertypes.BondDenom, shares)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;types.MsgWithdrawTipResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file172" style="display: none">package keeper

import (
        "context"

        errorsmod "cosmossdk.io/errors"
        sdk "github.com/cosmos/cosmos-sdk/types"

        "github.com/tellor-io/layer/x/reporter/types"
)

func (k msgServer) UpdateParams(goCtx context.Context, req *types.MsgUpdateParams) (*types.MsgUpdateParamsResponse, error) <span class="cov8" title="1">{
        if k.GetAuthority() != req.Authority </span><span class="cov8" title="1">{
                return nil, errorsmod.Wrapf(types.ErrInvalidSigner, "invalid authority; expected %s, got %s", k.GetAuthority(), req.Authority)
        }</span>

        <span class="cov8" title="1">ctx := sdk.UnwrapSDKContext(goCtx)
        if err := k.Params.Set(ctx, req.Params); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;types.MsgUpdateParamsResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file173" style="display: none">package keeper

import (
        "context"

        "cosmossdk.io/math"
)

func (k Keeper) MinCommissionRate(ctx context.Context) (math.LegacyDec, error) <span class="cov8" title="1">{
        params, err := k.Params.Get(ctx)
        return params.MinCommissionRate, err
}</span>
</pre>
		
		<pre class="file" id="file174" style="display: none">package keeper

import (
        "context"
        "errors"

        "cosmossdk.io/collections"
        errorsmod "cosmossdk.io/errors"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        sdk "github.com/cosmos/cosmos-sdk/types"

        "github.com/tellor-io/layer/x/reporter/types"
)

type Querier struct {
        Keeper
}

var _ types.QueryServer = Querier{}

func NewQuerier(keeper Keeper) Querier <span class="cov8" title="1">{
        return Querier{Keeper: keeper}
}</span>

// Reporter queries a reporter by address
func (k Querier) Reporter(ctx context.Context, req *types.QueryReporterRequest) (*types.QueryReporterResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov0" title="0">reporterAddr := sdk.MustAccAddressFromBech32(req.ReporterAddress)

        reporter, err := k.Keeper.Reporter(ctx, reporterAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;types.QueryReporterResponse{Reporter: reporter}, nil</span>
}

// Reporters queries all the reporters
func (k Querier) Reporters(ctx context.Context, req *types.QueryReportersRequest) (*types.QueryReportersResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov0" title="0">iter, err := k.Keeper.Reporters.Iterate(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">reporters, err := iter.Values()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">reportersPtrs := make([]*types.OracleReporter, len(reporters))
        for i, reporter := range reporters </span><span class="cov0" title="0">{
                reportersPtrs[i] = &amp;reporter
        }</span>
        <span class="cov0" title="0">return &amp;types.QueryReportersResponse{Reporters: reportersPtrs}, nil</span>

}

// DelegatorReporter queries the reporter of a delegator
func (k Querier) DelegatorReporter(ctx context.Context, req *types.QueryDelegatorReporterRequest) (*types.QueryDelegatorReporterResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov0" title="0">delAddr := sdk.MustAccAddressFromBech32(req.DelegatorAddress)

        delegator, err := k.Keeper.Delegators.Get(ctx, delAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;types.QueryDelegatorReporterResponse{Reporter: delegator.GetReporter()}, nil</span>
}

// ReporterStake queries the total tokens of a reporter
func (k Querier) ReporterStake(ctx context.Context, req *types.QueryReporterStakeRequest) (*types.QueryReporterStakeResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov0" title="0">reporterAddr := sdk.MustAccAddressFromBech32(req.ReporterAddress)

        reporter, err := k.Keeper.Reporters.Get(ctx, reporterAddr)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                        return nil, types.ErrReporterDoesNotExist
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;types.QueryReporterStakeResponse{Stake: reporter.TotalTokens}, nil</span>
}

// DelegationRewards the total rewards accrued by a delegation
func (k Querier) DelegationRewards(ctx context.Context, req *types.QueryDelegationRewardsRequest) (*types.QueryDelegationRewardsResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov0" title="0">reporterAddr := sdk.MustAccAddressFromBech32(req.ReporterAddress)
        delAddr := sdk.MustAccAddressFromBech32(req.DelegatorAddress)

        reporter, err := k.Keeper.Reporters.Get(ctx, reporterAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">delegation, err := k.Keeper.Delegators.Get(ctx, delAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if reporter.GetReporter() != delegation.GetReporter() </span><span class="cov0" title="0">{
                return nil, types.ErrReporterMismatch
        }</span>

        <span class="cov0" title="0">endingPeriod, err := k.Keeper.IncrementReporterPeriod(ctx, reporter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">rewards, err := k.Keeper.CalculateDelegationRewards(ctx, reporterAddr.Bytes(), delAddr, delegation, endingPeriod)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;types.QueryDelegationRewardsResponse{Rewards: rewards}, nil</span>
}

// ReporterOutstandingRewards queries rewards of a reporter address
func (k Querier) ReporterOutstandingRewards(ctx context.Context, req *types.QueryReporterOutstandingRewardsRequest) (*types.QueryReporterOutstandingRewardsResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov0" title="0">reporterAddr := sdk.MustAccAddressFromBech32(req.ReporterAddress)

        exists, err := k.Keeper.Reporters.Has(ctx, reporterAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return nil, errorsmod.Wrapf(types.ErrReporterDoesNotExist, req.ReporterAddress)
        }</span>

        <span class="cov0" title="0">rewards, err := k.Keeper.ReporterOutstandingRewards.Get(ctx, reporterAddr.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;types.QueryReporterOutstandingRewardsResponse{Rewards: rewards}, nil</span>
}

// RporterCommission queries accumulated commission for a reporter
func (k Querier) ReporterCommission(ctx context.Context, req *types.QueryReporterCommissionRequest) (*types.QueryReporterCommissionResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>

        <span class="cov0" title="0">reporterAddr := sdk.MustAccAddressFromBech32(req.ReporterAddress)

        exists, err := k.Keeper.Reporters.Has(ctx, reporterAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return nil, errorsmod.Wrapf(types.ErrReporterDoesNotExist, req.ReporterAddress)
        }</span>
        <span class="cov0" title="0">commission, err := k.Keeper.ReportersAccumulatedCommission.Get(ctx, reporterAddr.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;types.QueryReporterCommissionResponse{Commission: commission}, nil</span>
}
</pre>
		
		<pre class="file" id="file175" style="display: none">package keeper

import (
        "context"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/tellor-io/layer/x/reporter/types"
)

func (k Querier) Params(goCtx context.Context, req *types.QueryParamsRequest) (*types.QueryParamsResponse, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid request")
        }</span>
        <span class="cov8" title="1">ctx := sdk.UnwrapSDKContext(goCtx)
        params, err := k.Keeper.Params.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;types.QueryParamsResponse{Params: params}, nil</span>
}
</pre>
		
		<pre class="file" id="file176" style="display: none">package keeper

import (
        "context"
        "errors"

        "cosmossdk.io/collections"
        errorsmod "cosmossdk.io/errors"
        "cosmossdk.io/math"
        sdk "github.com/cosmos/cosmos-sdk/types"

        "github.com/tellor-io/layer/x/reporter/types"
)

func (k Keeper) ValidateAndSetAmount(ctx context.Context, delegator sdk.AccAddress, originAmounts []*types.TokenOrigin, amount math.Int) error <span class="cov8" title="1">{
        _amt := math.ZeroInt()
        for _, origin := range originAmounts </span><span class="cov8" title="1">{
                _amt = _amt.Add(origin.Amount)
        }</span>

        <span class="cov8" title="1">if !amount.Equal(_amt) </span><span class="cov8" title="1">{
                return errorsmod.Wrapf(types.ErrTokenAmountMismatch, "got %v as amount, but sum of token origins is %v", amount, _amt)
        }</span>
        <span class="cov8" title="1">for _, origin := range originAmounts </span><span class="cov8" title="1">{
                valAddr, err := sdk.ValAddressFromBech32(origin.ValidatorAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">tokenSource, err := k.TokenOrigin.Get(ctx, collections.Join(delegator, valAddr))
                if err != nil </span><span class="cov8" title="1">{
                        if !errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                                return errorsmod.Wrapf(err, "unable to fetch token origin")
                        }</span> else<span class="cov8" title="1"> {
                                // not found so initialize
                                tokenSource = math.ZeroInt()
                        }</span>
                }
                <span class="cov8" title="1">validator, err := k.stakingKeeper.GetValidator(ctx, valAddr)
                if err != nil </span><span class="cov0" title="0">{
                        return errorsmod.Wrapf(err, "failed to fetch validator for source tokens %v", origin)
                }</span>
                <span class="cov8" title="1">delegation, err := k.stakingKeeper.Delegation(ctx, delegator, valAddr)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // check if the delegator has enough tokens bonded with validator, this would be the sum
                // of what is currently delegated to reporter plus the amount being added in this transaction
                // todo: further documentation
                // LTE doesnt work ? 
                <span class="cov8" title="1">sum := tokenSource.Add(origin.Amount)
                tokensFromShares := validator.TokensFromShares(delegation.GetShares()).TruncateInt()
                if tokensFromShares.LT(sum) </span><span class="cov8" title="1">{
                        return errorsmod.Wrapf(types.ErrInsufficientTokens, "insufficient tokens bonded with validator %v", valAddr)
                }</span>
                <span class="cov8" title="1">tokenSource = sum
                if err := k.TokenOrigin.Set(ctx, collections.Join(delegator, valAddr), tokenSource); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (k Keeper) UpdateOrRemoveDelegator(ctx context.Context, delAddr sdk.AccAddress, del types.Delegation, reporter types.OracleReporter, amt math.Int) error <span class="cov8" title="1">{
        if err := k.BeforeDelegationModified(ctx, delAddr, del, reporter); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if del.Amount.LTE(amt) </span><span class="cov8" title="1">{
                return k.Delegators.Remove(ctx, delAddr)
        }</span>
        <span class="cov8" title="1">del.Amount = del.Amount.Sub(amt)
        err := k.Delegators.Set(ctx, delAddr, del)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">reporterVal := sdk.ValAddress(sdk.MustAccAddressFromBech32(reporter.GetReporter()))
        return k.AfterDelegationModified(ctx, delAddr, reporterVal, del.Amount)</span>
}

func (k Keeper) UpdateOrRemoveReporter(ctx context.Context, key sdk.AccAddress, rep types.OracleReporter, amt math.Int) error <span class="cov8" title="1">{
        if rep.TotalTokens.LTE(amt) </span><span class="cov8" title="1">{
                if err := k.Reporters.Remove(ctx, key); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">reporterVal := sdk.ValAddress(key)
                return k.AfterReporterRemoved(ctx, reporterVal)</span>
        }
        <span class="cov8" title="1">rep.TotalTokens = rep.TotalTokens.Sub(amt)
        return k.Reporters.Set(ctx, key, rep)</span>

}

func (k Keeper) UpdateOrRemoveSource(ctx context.Context, key collections.Pair[sdk.AccAddress, sdk.ValAddress], srcAmount math.Int, amt math.Int) (err error) <span class="cov0" title="0">{
        // amount is the current staked amount in staking mod
        // so if current amount is zero remove the source
        if amt.IsZero() </span><span class="cov0" title="0">{
                return k.TokenOrigin.Remove(ctx, key)
        }</span>
        <span class="cov0" title="0">return k.TokenOrigin.Set(ctx, key, amt)</span>
}

func (k Keeper) UndelegateSource(ctx context.Context, key collections.Pair[sdk.AccAddress, sdk.ValAddress], currentAmount math.Int, newAmount math.Int) error <span class="cov8" title="1">{
        if newAmount.GTE(currentAmount) </span><span class="cov8" title="1">{
                return k.TokenOrigin.Remove(ctx, key)
        }</span>
        <span class="cov8" title="1">return k.TokenOrigin.Set(ctx, key, currentAmount.Sub(newAmount))</span>
}

func (k Keeper) Reporter(ctx context.Context, repAddr sdk.AccAddress) (*types.OracleReporter, error) <span class="cov0" title="0">{
        reporter, err := k.Reporters.Get(ctx, repAddr)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, collections.ErrNotFound) </span><span class="cov0" title="0">{
                        return nil, types.ErrReporterDoesNotExist
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;reporter, nil</span>
}

func (k Keeper) TotalReporterPower(ctx context.Context) (math.Int, error) <span class="cov0" title="0">{
        totalPower := math.ZeroInt()
        iter, err := k.Reporters.Iterate(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return math.Int{}, err
        }</span>
        <span class="cov0" title="0">defer iter.Close()
        for ; iter.Valid(); iter.Next() </span><span class="cov0" title="0">{
                reporter, err := iter.Value()
                if err != nil </span><span class="cov0" title="0">{
                        return math.Int{}, err
                }</span>
                <span class="cov0" title="0">totalPower = totalPower.Add(reporter.TotalTokens)</span>
        }
        <span class="cov0" title="0">return totalPower, nil</span>
}
</pre>
		
		<pre class="file" id="file177" style="display: none">package keeper

import (
        "context"
        "errors"
        "fmt"

        "cosmossdk.io/collections"
        "cosmossdk.io/math"
        sdk "github.com/cosmos/cosmos-sdk/types"
        stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
        layertypes "github.com/tellor-io/layer/types"
        disputetypes "github.com/tellor-io/layer/x/dispute/types"
        "github.com/tellor-io/layer/x/reporter/types"
)

// FeefromReporterStake deducts the fee from the reporter's stake used mainly for paying dispute from bond
func (k Keeper) FeefromReporterStake(ctx context.Context, reporterAddr sdk.AccAddress, amt math.Int) error <span class="cov0" title="0">{
        reporter, err := k.Reporters.Get(ctx, reporterAddr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Calculate each delegator's share (including the reporter as a self-delegator)
        <span class="cov0" title="0">repAddr, err := sdk.AccAddressFromBech32(reporter.Reporter)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">delAddrs, err := k.Delegators.Indexes.Reporter.MatchExact(ctx, repAddr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">totaltokens := math.LegacyNewDecFromInt(reporter.TotalTokens)
        defer delAddrs.Close()
        for ; delAddrs.Valid(); delAddrs.Next() </span><span class="cov0" title="0">{
                key, err := delAddrs.PrimaryKey()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">rng := collections.NewPrefixedPairRange[sdk.AccAddress, sdk.ValAddress](key)
                iter, err := k.TokenOrigin.Iterate(ctx, rng)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">delegatorSources, err := iter.KeyValues()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for _, source := range delegatorSources </span><span class="cov0" title="0">{
                        srcAmt := math.LegacyNewDecFromInt(source.Value)
                        share := srcAmt.Quo(totaltokens).Mul(math.LegacyNewDecFromInt(amt))
                        _, err = k.feeFromStake(ctx, source.Key.K1(), source.Key.K2(), share)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (k Keeper) feeFromStake(
        ctx context.Context, delAddr sdk.AccAddress, valAddr sdk.ValAddress, sharesAmount math.LegacyDec,
) (math.Int, error) <span class="cov0" title="0">{

        returnAmount, err := k.stakingKeeper.Unbond(ctx, delAddr, valAddr, sharesAmount)
        if err != nil </span><span class="cov0" title="0">{
                return math.Int{}, err
        }</span>
        <span class="cov0" title="0">if err := k.moveTokensFromValidator(ctx, valAddr, returnAmount); err != nil </span><span class="cov0" title="0">{
                return math.Int{}, err
        }</span>

        <span class="cov0" title="0">return returnAmount, nil</span>
}

// get dst validator for a redelegated delegator
func (k Keeper) getDstValidator(ctx context.Context, delAddr sdk.AccAddress, valAddr sdk.ValAddress) (sdk.ValAddress, error) <span class="cov0" title="0">{
        reds, err := k.stakingKeeper.GetRedelegationsFromSrcValidator(ctx, valAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, red := range reds </span><span class="cov0" title="0">{
                if red.DelegatorAddress == delAddr.String() </span><span class="cov0" title="0">{
                        valAddr, err := sdk.ValAddressFromBech32(red.ValidatorDstAddress)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return valAddr, nil</span>
                }
        }
        <span class="cov0" title="0">return nil, errors.New("redelegation to destination validator not found")</span>
}

func (k Keeper) deductUnbondingDelegation(ctx context.Context, delAddr sdk.AccAddress, valAddr sdk.ValAddress, shares math.Int) (math.Int, error) <span class="cov0" title="0">{
        ubd, err := k.stakingKeeper.GetUnbondingDelegation(ctx, delAddr, valAddr)
        if err != nil </span><span class="cov0" title="0">{
                return math.Int{}, err
        }</span>
        <span class="cov0" title="0">if len(ubd.Entries) == 0 </span><span class="cov0" title="0">{
                return math.Int{}, types.ErrNoUnbondingDelegationEntries
        }</span>
        <span class="cov0" title="0">for i, u := range ubd.Entries </span><span class="cov0" title="0">{
                if u.Balance.LT(shares) </span><span class="cov0" title="0">{
                        shares = shares.Sub(u.Balance)
                        ubd.RemoveEntry(int64(i))
                }</span> else<span class="cov0" title="0"> {
                        u.Balance = u.Balance.Sub(shares)
                        u.InitialBalance = u.InitialBalance.Sub(shares)
                        ubd.Entries[i] = u
                        shares = math.ZeroInt()
                        break</span>
                }
        }

        <span class="cov0" title="0">if len(ubd.Entries) == 0 </span><span class="cov0" title="0">{
                err = k.stakingKeeper.RemoveUnbondingDelegation(ctx, ubd)
        }</span> else<span class="cov0" title="0"> {
                err = k.stakingKeeper.SetUnbondingDelegation(ctx, ubd)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return math.Int{}, err
        }</span>
        <span class="cov0" title="0">return shares, nil</span>

}

func (k Keeper) deductFromdelegation(ctx context.Context, delAddr sdk.AccAddress, valAddr sdk.ValAddress, shares math.LegacyDec) (math.LegacyDec, error) <span class="cov0" title="0">{
        // get delegation
        del, err := k.stakingKeeper.GetDelegation(ctx, delAddr, valAddr)
        if err != nil </span><span class="cov0" title="0">{
                return shares, err
        }</span>
        <span class="cov0" title="0">if del.Shares.GTE(shares) </span><span class="cov0" title="0">{
                _, err := k.stakingKeeper.Unbond(ctx, delAddr, valAddr, shares)
                if err != nil </span><span class="cov0" title="0">{
                        return shares, err
                }</span>
                <span class="cov0" title="0">return math.LegacyZeroDec(), nil</span>
        } else<span class="cov0" title="0"> {
                shares = shares.Sub(del.Shares)
                _, err := k.stakingKeeper.Unbond(ctx, delAddr, valAddr, del.Shares)
                if err != nil </span><span class="cov0" title="0">{
                        return shares, err
                }</span>
                <span class="cov0" title="0">return shares, nil</span>
        }

}

func (k Keeper) moveTokensFromValidator(ctx context.Context, valAddr sdk.ValAddress, amount math.Int) error <span class="cov0" title="0">{
        validator, err := k.stakingKeeper.GetValidator(ctx, valAddr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">var fromPool string
        switch </span>{
        case validator.IsBonded():<span class="cov0" title="0">
                fromPool = stakingtypes.BondedPoolName</span>
        case validator.IsUnbonding():<span class="cov0" title="0">
                fromPool = stakingtypes.NotBondedPoolName</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown validator status: %s", validator.GetStatus())</span>
        }
        <span class="cov0" title="0">return k.tokensToDispute(ctx, fromPool, amount)</span>
}
func (k Keeper) undelegate(ctx context.Context, delAddr sdk.AccAddress, valAddr sdk.ValAddress, shares math.LegacyDec) (math.Int, error) <span class="cov0" title="0">{
        remainingFromdel, err := k.deductFromdelegation(ctx, delAddr, valAddr, shares)
        if err != nil </span><span class="cov0" title="0">{
                if !errors.Is(err, stakingtypes.ErrNoDelegation) </span><span class="cov0" title="0">{
                        return math.Int{}, err
                }</span>
        }

        <span class="cov0" title="0">if remainingFromdel.IsZero() </span><span class="cov0" title="0">{
                if err := k.moveTokensFromValidator(ctx, valAddr, shares.TruncateInt()); err != nil </span><span class="cov0" title="0">{
                        return math.Int{}, err
                }</span>
                <span class="cov0" title="0">return remainingFromdel.TruncateInt(), nil</span>

        } else<span class="cov0" title="0"> {
                remainingUnbonding, err := k.deductUnbondingDelegation(ctx, delAddr, valAddr, remainingFromdel.TruncateInt())
                if err != nil </span><span class="cov0" title="0">{
                        return math.Int{}, err
                }</span>
                <span class="cov0" title="0">if remainingUnbonding.IsZero() </span><span class="cov0" title="0">{
                        if err := k.tokensToDispute(ctx, stakingtypes.NotBondedPoolName, remainingFromdel.TruncateInt()); err != nil </span><span class="cov0" title="0">{
                                return math.Int{}, err
                        }</span>
                }
                <span class="cov0" title="0">return remainingUnbonding, nil</span>
        }

}

func (k Keeper) EscrowReporterStake(ctx context.Context, reporterAddr sdk.AccAddress, power, height int64, amt math.Int) error <span class="cov0" title="0">{
        // get origins at height
        rng := collections.NewPrefixedPairRange[sdk.AccAddress, int64](reporterAddr).StartInclusive(height)
        var firstValue *types.DelegationsPreUpdate

        err := k.TokenOriginSnapshot.Walk(ctx, rng, func(key collections.Pair[sdk.AccAddress, int64], value types.DelegationsPreUpdate) (stop bool, err error) </span><span class="cov0" title="0">{
                firstValue = &amp;value
                return true, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">totalTokens := layertypes.PowerReduction.MulRaw(power)
        for _, del := range firstValue.TokenOrigins </span><span class="cov0" title="0">{
                delegatorShare := math.LegacyNewDecFromInt(del.Amount).Quo(math.LegacyNewDecFromInt(totalTokens)).Mul(math.LegacyNewDecFromInt(amt))
                delAddr, err := sdk.AccAddressFromBech32(del.DelegatorAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">valAddr, err := sdk.ValAddressFromBech32(del.ValidatorAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">remaining, err := k.undelegate(ctx, delAddr, valAddr, delegatorShare)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !remaining.IsZero() </span><span class="cov0" title="0">{
                        dstVAl, err := k.getDstValidator(ctx, delAddr, valAddr)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">_, err = k.undelegate(ctx, delAddr, dstVAl, math.LegacyNewDecFromInt(remaining))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (k Keeper) tokensToDispute(ctx context.Context, fromPool string, amount math.Int) error <span class="cov0" title="0">{
        return k.bankKeeper.SendCoinsFromModuleToModule(ctx, fromPool, disputetypes.ModuleName, sdk.NewCoins(sdk.NewCoin(layertypes.BondDenom, amount)))
}</span>
</pre>
		
		<pre class="file" id="file178" style="display: none">package reporter

import (
        autocliv1 "cosmossdk.io/api/cosmos/autocli/v1"

        modulev1 "github.com/tellor-io/layer/api/layer/reporter"
)

// AutoCLIOptions implements the autocli.HasAutoCLIConfig interface.
func (am AppModule) AutoCLIOptions() *autocliv1.ModuleOptions <span class="cov0" title="0">{
        return &amp;autocliv1.ModuleOptions{
                Query: &amp;autocliv1.ServiceCommandDescriptor{
                        Service: modulev1.Query_ServiceDesc.ServiceName,
                        RpcCommandOptions: []*autocliv1.RpcCommandOptions{
                                {
                                        RpcMethod: "Params",
                                        Use:       "params",
                                        Short:     "Shows the parameters of the module",
                                },
                                {
                                        RpcMethod:      "Reporter",
                                        Use:            "reporter [reporter-addr]",
                                        Short:          "Query staked reporter by address",
                                        PositionalArgs: []*autocliv1.PositionalArgDescriptor{{ProtoField: "reporter_address"}},
                                },
                                {
                                        RpcMethod:      "Reporters",
                                        Use:            "reporters",
                                        Short:          "Query staked reporters",
                                        PositionalArgs: []*autocliv1.PositionalArgDescriptor{},
                                },
                                {
                                        RpcMethod:      "DelegatorReporter",
                                        Use:            "delegator-reporter [delegator-addr]",
                                        Short:          "Query reporter of a delegator",
                                        PositionalArgs: []*autocliv1.PositionalArgDescriptor{{ProtoField: "delegator_address"}},
                                },
                                {
                                        RpcMethod:      "ReporterStake",
                                        Use:            "reporter-stake [reporter-addr]",
                                        Short:          "Query total tokens of a reporter",
                                        PositionalArgs: []*autocliv1.PositionalArgDescriptor{{ProtoField: "reporter_address"}},
                                },
                                {
                                        RpcMethod:      "DelegationRewards",
                                        Use:            "delegation-rewards [delegator-addr] [reporter-addr]",
                                        Short:          "Query delegator rewards from a particular reporter",
                                        PositionalArgs: []*autocliv1.PositionalArgDescriptor{{ProtoField: "delegator_address"}, {ProtoField: "reporter_address"}},
                                },
                                {
                                        RpcMethod:      "ReporterOutstandingRewards",
                                        Use:            "outstanding-rewards [reporter]",
                                        Short:          "Query outstanding rewards for a reporter and all their delegations",
                                        PositionalArgs: []*autocliv1.PositionalArgDescriptor{{ProtoField: "reporter_address"}},
                                },
                                {
                                        RpcMethod:      "ReporterCommission",
                                        Use:            "commission [reporter]",
                                        Short:          "Query distribution reporter commission",
                                        PositionalArgs: []*autocliv1.PositionalArgDescriptor{{ProtoField: "reporter_address"}},
                                },
                                // this line is used by ignite scaffolding # autocli/query
                        },
                },
                Tx: &amp;autocliv1.ServiceCommandDescriptor{
                        Service:              modulev1.Msg_ServiceDesc.ServiceName,
                        EnhanceCustomCommand: true, // only required if you want to use the custom command
                        RpcCommandOptions: []*autocliv1.RpcCommandOptions{
                                {
                                        RpcMethod: "UpdateParams",
                                        Skip:      true, // skipped because authority gated
                                },
                                {
                                        RpcMethod:      "CreateReporter",
                                        Use:            "create-reporter [amount] [token-origins]",
                                        Short:          "Execute the CreateReporter RPC method",
                                        PositionalArgs: []*autocliv1.PositionalArgDescriptor{{ProtoField: "amount"}, {ProtoField: "token_origins"}},
                                },
                                {
                                        RpcMethod:      "DelegateReporter",
                                        Use:            "delegate-reporter [reporter] [amount] [token-origin]",
                                        Short:          "Execute the DelegateReporter RPC method",
                                        PositionalArgs: []*autocliv1.PositionalArgDescriptor{{ProtoField: "reporter"}, {ProtoField: "amount"}, {ProtoField: "token_origins"}},
                                },
                                {
                                        RpcMethod:      "UndelegateReporter",
                                        Use:            "undelegate-reporter [amount]",
                                        Short:          "Execute the UndelegateReporter RPC method",
                                        PositionalArgs: []*autocliv1.PositionalArgDescriptor{{ProtoField: "token_origins"}},
                                },
                                {
                                        RpcMethod:      "UnjailReporter",
                                        Use:            "unjail-reporter [reporter-addr]",
                                        Short:          "Execute the UnjailReporter RPC method",
                                        PositionalArgs: []*autocliv1.PositionalArgDescriptor{{ProtoField: "reporter_address"}},
                                },
                                {
                                        RpcMethod:      "WithdrawTip",
                                        Use:            "withdraw-tip [delegator-address] [validator-address]",
                                        Short:          "Send a WithdrawTip tx",
                                        PositionalArgs: []*autocliv1.PositionalArgDescriptor{{ProtoField: "delegator_address"}, {ProtoField: "validator_address"}},
                                },
                                // this line is used by ignite scaffolding # autocli/tx
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file179" style="display: none">package reporter

import (
        sdk "github.com/cosmos/cosmos-sdk/types"

        "github.com/tellor-io/layer/x/reporter/keeper"
        "github.com/tellor-io/layer/x/reporter/types"
)

// InitGenesis initializes the module's state from a provided genesis state.
func InitGenesis(ctx sdk.Context, k keeper.Keeper, genState types.GenesisState) <span class="cov8" title="1">{
        // this line is used by starport scaffolding # genesis/module/init
        err := k.Params.Set(ctx, genState.Params)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// ExportGenesis returns the module's exported genesis.
func ExportGenesis(ctx sdk.Context, k keeper.Keeper) *types.GenesisState <span class="cov8" title="1">{
        genesis := types.DefaultGenesis()
        params, err := k.Params.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">genesis.Params = params

        // this line is used by starport scaffolding # genesis/module/export

        return genesis</span>
}
</pre>
		
		<pre class="file" id="file180" style="display: none">package reporter

import (
        "context"
        "encoding/json"
        "fmt"

        "cosmossdk.io/core/appmodule"
        "cosmossdk.io/core/store"
        "cosmossdk.io/depinject"
        "cosmossdk.io/log"
        "github.com/cosmos/cosmos-sdk/client"
        "github.com/cosmos/cosmos-sdk/codec"
        cdctypes "github.com/cosmos/cosmos-sdk/codec/types"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/module"
        authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
        govtypes "github.com/cosmos/cosmos-sdk/x/gov/types"
        "github.com/grpc-ecosystem/grpc-gateway/runtime"

        // this line is used by starport scaffolding # 1

        modulev1 "github.com/tellor-io/layer/api/layer/reporter/module"
        "github.com/tellor-io/layer/x/reporter/keeper"
        "github.com/tellor-io/layer/x/reporter/types"
)

var (
        _ module.AppModuleBasic      = (*AppModule)(nil)
        _ module.AppModuleSimulation = (*AppModule)(nil)
        _ module.HasGenesis          = (*AppModule)(nil)
        _ module.HasInvariants       = (*AppModule)(nil)
        _ module.HasConsensusVersion = (*AppModule)(nil)

        _ appmodule.AppModule       = (*AppModule)(nil)
        _ appmodule.HasBeginBlocker = (*AppModule)(nil)
        _ appmodule.HasEndBlocker   = (*AppModule)(nil)
)

// ----------------------------------------------------------------------------
// AppModuleBasic
// ----------------------------------------------------------------------------

// AppModuleBasic implements the AppModuleBasic interface that defines the
// independent methods a Cosmos SDK module needs to implement.
type AppModuleBasic struct {
        cdc codec.BinaryCodec
}

func NewAppModuleBasic(cdc codec.BinaryCodec) AppModuleBasic <span class="cov0" title="0">{
        return AppModuleBasic{cdc: cdc}
}</span>

// Name returns the name of the module as a string.
func (AppModuleBasic) Name() string <span class="cov0" title="0">{
        return types.ModuleName
}</span>

// RegisterLegacyAminoCodec registers the amino codec for the module, which is used
// to marshal and unmarshal structs to/from []byte in order to persist them in the module's KVStore.
func (AppModuleBasic) RegisterLegacyAminoCodec(cdc *codec.LegacyAmino) {<span class="cov0" title="0">}</span>

// RegisterInterfaces registers a module's interface types and their concrete implementations as proto.Message.
func (a AppModuleBasic) RegisterInterfaces(reg cdctypes.InterfaceRegistry) <span class="cov0" title="0">{
        types.RegisterInterfaces(reg)
}</span>

// DefaultGenesis returns a default GenesisState for the module, marshalled to json.RawMessage.
// The default GenesisState need to be defined by the module developer and is primarily used for testing.
func (AppModuleBasic) DefaultGenesis(cdc codec.JSONCodec) json.RawMessage <span class="cov0" title="0">{
        return cdc.MustMarshalJSON(types.DefaultGenesis())
}</span>

// ValidateGenesis used to validate the GenesisState, given in its json.RawMessage form.
func (AppModuleBasic) ValidateGenesis(cdc codec.JSONCodec, config client.TxEncodingConfig, bz json.RawMessage) error <span class="cov0" title="0">{
        var genState types.GenesisState
        if err := cdc.UnmarshalJSON(bz, &amp;genState); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal %s genesis state: %w", types.ModuleName, err)
        }</span>
        <span class="cov0" title="0">return genState.Validate()</span>
}

// RegisterGRPCGatewayRoutes registers the gRPC Gateway routes for the module.
func (AppModuleBasic) RegisterGRPCGatewayRoutes(clientCtx client.Context, mux *runtime.ServeMux) <span class="cov0" title="0">{
        if err := types.RegisterQueryHandlerClient(context.Background(), mux, types.NewQueryClient(clientCtx)); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// ----------------------------------------------------------------------------
// AppModule
// ----------------------------------------------------------------------------

// AppModule implements the AppModule interface that defines the inter-dependent methods that modules need to implement
type AppModule struct {
        AppModuleBasic

        keeper        keeper.Keeper
        accountKeeper types.AccountKeeper
        bankKeeper    types.BankKeeper
}

func NewAppModule(
        cdc codec.Codec,
        keeper keeper.Keeper,
        accountKeeper types.AccountKeeper,
        bankKeeper types.BankKeeper,
) AppModule <span class="cov0" title="0">{
        return AppModule{
                AppModuleBasic: NewAppModuleBasic(cdc),
                keeper:         keeper,
                accountKeeper:  accountKeeper,
                bankKeeper:     bankKeeper,
        }
}</span>

// RegisterServices registers a gRPC query service to respond to the module-specific gRPC queries
func (am AppModule) RegisterServices(cfg module.Configurator) <span class="cov0" title="0">{
        types.RegisterMsgServer(cfg.MsgServer(), keeper.NewMsgServerImpl(am.keeper))
        types.RegisterQueryServer(cfg.QueryServer(), keeper.NewQuerier(am.keeper))
}</span>

// RegisterInvariants registers the invariants of the module. If an invariant deviates from its predicted value, the InvariantRegistry triggers appropriate logic (most often the chain will be halted)
func (am AppModule) RegisterInvariants(_ sdk.InvariantRegistry) {<span class="cov0" title="0">}</span>

// InitGenesis performs the module's genesis initialization. It returns no validator updates.
func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, gs json.RawMessage) <span class="cov0" title="0">{
        var genState types.GenesisState
        // Initialize global index to index in genesis state
        cdc.MustUnmarshalJSON(gs, &amp;genState)

        InitGenesis(ctx, am.keeper, genState)
}</span>

// ExportGenesis returns the module's exported genesis state as raw JSON bytes.
func (am AppModule) ExportGenesis(ctx sdk.Context, cdc codec.JSONCodec) json.RawMessage <span class="cov0" title="0">{
        genState := ExportGenesis(ctx, am.keeper)
        return cdc.MustMarshalJSON(genState)
}</span>

// ConsensusVersion is a sequence number for state-breaking change of the module.
// It should be incremented on each consensus-breaking change introduced by the module.
// To avoid wrong/empty versions, the initial version should be set to 1.
func (AppModule) ConsensusVersion() uint64 <span class="cov0" title="0">{ return 1 }</span>

// BeginBlock contains the logic that is automatically triggered at the beginning of each block.
// The begin block implementation is optional.
func (am AppModule) BeginBlock(_ context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// EndBlock contains the logic that is automatically triggered at the end of each block.
// The end block implementation is optional.
func (am AppModule) EndBlock(_ context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// IsOnePerModuleType implements the depinject.OnePerModuleType interface.
func (am AppModule) IsOnePerModuleType() {<span class="cov0" title="0">}</span>

// IsAppModule implements the appmodule.AppModule interface.
func (am AppModule) IsAppModule() {<span class="cov0" title="0">}</span>

// ----------------------------------------------------------------------------
// App Wiring Setup
// ----------------------------------------------------------------------------

func init() <span class="cov8" title="1">{
        appmodule.Register(
                &amp;modulev1.Module{},
                appmodule.Provide(ProvideModule),
        )
}</span>

type ModuleInputs struct {
        depinject.In

        StoreService store.KVStoreService
        Cdc          codec.Codec
        Config       *modulev1.Module
        Logger       log.Logger

        AccountKeeper types.AccountKeeper
        BankKeeper    types.BankKeeper
        StakingKeeper types.StakingKeeper
}

type ModuleOutputs struct {
        depinject.Out

        ReporterKeeper keeper.Keeper
        Module         appmodule.AppModule
}

func ProvideModule(in ModuleInputs) ModuleOutputs <span class="cov0" title="0">{
        // default to governance authority if not provided
        authority := authtypes.NewModuleAddress(govtypes.ModuleName)
        if in.Config.Authority != "" </span><span class="cov0" title="0">{
                authority = authtypes.NewModuleAddressOrBech32Address(in.Config.Authority)
        }</span>
        <span class="cov0" title="0">k := keeper.NewKeeper(
                in.Cdc,
                in.StoreService,
                in.Logger,
                authority.String(),
                in.StakingKeeper,
                in.BankKeeper,
        )
        m := NewAppModule(
                in.Cdc,
                k,
                in.AccountKeeper,
                in.BankKeeper,
        )

        return ModuleOutputs{ReporterKeeper: k, Module: m}</span>
}
</pre>
		
		<pre class="file" id="file181" style="display: none">package reporter

import (
        "math/rand"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/module"
        simtypes "github.com/cosmos/cosmos-sdk/types/simulation"
        "github.com/cosmos/cosmos-sdk/x/simulation"

        "github.com/tellor-io/layer/testutil/sample"
        reportersimulation "github.com/tellor-io/layer/x/reporter/simulation"
        "github.com/tellor-io/layer/x/reporter/types"
)

// avoid unused import issue
var (
        _ = reportersimulation.FindAccount
        _ = rand.Rand{}
        _ = sample.AccAddress
        _ = sdk.AccAddress{}
        _ = simulation.MsgEntryKind
)

const (
        opWeightMsgCreateReporter = "op_weight_msg_create_reporter"
        // TODO: Determine the simulation weight value
        defaultWeightMsgCreateReporter int = 100

        opWeightMsgDelegateReporter = "op_weight_msg_delegate_reporter"
        // TODO: Determine the simulation weight value
        defaultWeightMsgDelegateReporter int = 100

        opWeightMsgUndelegateReporter = "op_weight_msg_undelegate_reporter"
        // TODO: Determine the simulation weight value
        defaultWeightMsgUndelegateReporter int = 100

        opWeightMsgWithdrawTip = "op_weight_msg_withdraw_tip"
        // TODO: Determine the simulation weight value
        defaultWeightMsgWithdrawTip int = 100

        // this line is used by starport scaffolding # simapp/module/const
)

// GenerateGenesisState creates a randomized GenState of the module.
func (AppModule) GenerateGenesisState(simState *module.SimulationState) <span class="cov0" title="0">{
        accs := make([]string, len(simState.Accounts))
        for i, acc := range simState.Accounts </span><span class="cov0" title="0">{
                accs[i] = acc.Address.String()
        }</span>
        <span class="cov0" title="0">reporterGenesis := types.GenesisState{
                Params: types.DefaultParams(),
                // this line is used by starport scaffolding # simapp/module/genesisState
        }
        simState.GenState[types.ModuleName] = simState.Cdc.MustMarshalJSON(&amp;reporterGenesis)</span>
}

// RegisterStoreDecoder registers a decoder.
func (am AppModule) RegisterStoreDecoder(_ simtypes.StoreDecoderRegistry) {<span class="cov0" title="0">}</span>

// ProposalContents doesn't return any content functions for governance proposals.
func (AppModule) ProposalContents(_ module.SimulationState) []simtypes.WeightedProposalContent <span class="cov0" title="0">{
        return nil
}</span>

// WeightedOperations returns the all the gov module operations with their respective weights.
func (am AppModule) WeightedOperations(simState module.SimulationState) []simtypes.WeightedOperation <span class="cov0" title="0">{
        operations := make([]simtypes.WeightedOperation, 0)

        var weightMsgCreateReporter int
        simState.AppParams.GetOrGenerate(opWeightMsgCreateReporter, &amp;weightMsgCreateReporter, nil,
                func(_ *rand.Rand) </span><span class="cov0" title="0">{
                        weightMsgCreateReporter = defaultWeightMsgCreateReporter
                }</span>,
        )
        <span class="cov0" title="0">operations = append(operations, simulation.NewWeightedOperation(
                weightMsgCreateReporter,
                reportersimulation.SimulateMsgCreateReporter(am.accountKeeper, am.bankKeeper, am.keeper),
        ))

        var weightMsgDelegateReporter int
        simState.AppParams.GetOrGenerate(opWeightMsgDelegateReporter, &amp;weightMsgDelegateReporter, nil,
                func(_ *rand.Rand) </span><span class="cov0" title="0">{
                        weightMsgDelegateReporter = defaultWeightMsgDelegateReporter
                }</span>,
        )
        <span class="cov0" title="0">operations = append(operations, simulation.NewWeightedOperation(
                weightMsgDelegateReporter,
                reportersimulation.SimulateMsgDelegateReporter(am.accountKeeper, am.bankKeeper, am.keeper),
        ))

        var weightMsgUndelegateReporter int
        simState.AppParams.GetOrGenerate(opWeightMsgUndelegateReporter, &amp;weightMsgUndelegateReporter, nil,
                func(_ *rand.Rand) </span><span class="cov0" title="0">{
                        weightMsgUndelegateReporter = defaultWeightMsgUndelegateReporter
                }</span>,
        )
        <span class="cov0" title="0">operations = append(operations, simulation.NewWeightedOperation(
                weightMsgUndelegateReporter,
                reportersimulation.SimulateMsgUndelegateReporter(am.accountKeeper, am.bankKeeper, am.keeper),
        ))

        var weightMsgWithdrawTip int
        simState.AppParams.GetOrGenerate(opWeightMsgWithdrawTip, &amp;weightMsgWithdrawTip, nil,
                func(_ *rand.Rand) </span><span class="cov0" title="0">{
                        weightMsgWithdrawTip = defaultWeightMsgWithdrawTip
                }</span>,
        )
        <span class="cov0" title="0">operations = append(operations, simulation.NewWeightedOperation(
                weightMsgWithdrawTip,
                reportersimulation.SimulateMsgWithdrawTip(am.accountKeeper, am.bankKeeper, am.keeper),
        ))

        // this line is used by starport scaffolding # simapp/module/operation

        return operations</span>
}

// ProposalMsgs returns msgs used for governance proposals for simulations.
func (am AppModule) ProposalMsgs(simState module.SimulationState) []simtypes.WeightedProposalMsg <span class="cov0" title="0">{
        return []simtypes.WeightedProposalMsg{
                simulation.NewWeightedProposalMsg(
                        opWeightMsgCreateReporter,
                        defaultWeightMsgCreateReporter,
                        func(r *rand.Rand, ctx sdk.Context, accs []simtypes.Account) sdk.Msg </span><span class="cov0" title="0">{
                                reportersimulation.SimulateMsgCreateReporter(am.accountKeeper, am.bankKeeper, am.keeper)
                                return nil
                        }</span>,
                ),
                simulation.NewWeightedProposalMsg(
                        opWeightMsgDelegateReporter,
                        defaultWeightMsgDelegateReporter,
                        func(r *rand.Rand, ctx sdk.Context, accs []simtypes.Account) sdk.Msg <span class="cov0" title="0">{
                                reportersimulation.SimulateMsgDelegateReporter(am.accountKeeper, am.bankKeeper, am.keeper)
                                return nil
                        }</span>,
                ),
                simulation.NewWeightedProposalMsg(
                        opWeightMsgUndelegateReporter,
                        defaultWeightMsgUndelegateReporter,
                        func(r *rand.Rand, ctx sdk.Context, accs []simtypes.Account) sdk.Msg <span class="cov0" title="0">{
                                reportersimulation.SimulateMsgUndelegateReporter(am.accountKeeper, am.bankKeeper, am.keeper)
                                return nil
                        }</span>,
                ),
                simulation.NewWeightedProposalMsg(
                        opWeightMsgWithdrawTip,
                        defaultWeightMsgWithdrawTip,
                        func(r *rand.Rand, ctx sdk.Context, accs []simtypes.Account) sdk.Msg <span class="cov0" title="0">{
                                reportersimulation.SimulateMsgWithdrawTip(am.accountKeeper, am.bankKeeper, am.keeper)
                                return nil
                        }</span>,
                ),
                // this line is used by starport scaffolding # simapp/module/OpMsg
        }
}
</pre>
		
		<pre class="file" id="file182" style="display: none">package types

import (
        cdctypes "github.com/cosmos/cosmos-sdk/codec/types"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/msgservice"
        // this line is used by starport scaffolding # 1
)

func RegisterInterfaces(registry cdctypes.InterfaceRegistry) <span class="cov0" title="0">{
        registry.RegisterImplementations((*sdk.Msg)(nil),
                &amp;MsgCreateReporter{},
                &amp;MsgDelegateReporter{},
                &amp;MsgUndelegateReporter{},
                &amp;MsgUpdateParams{},
                &amp;MsgWithdrawDelegatorReward{},
                &amp;MsgWithdrawReporterCommission{},
                &amp;MsgWithdrawTip{},
        )
        // this line is used by starport scaffolding # 3
        msgservice.RegisterMsgServiceDesc(registry, &amp;_Msg_serviceDesc)
}</span>
</pre>
		
		<pre class="file" id="file183" style="display: none">package types

import (
        "cosmossdk.io/math"
)

func NewDelegation(reporter string, amount math.Int) Delegation <span class="cov0" title="0">{
        return Delegation{
                Reporter: reporter,
                Amount:   amount,
        }
}</span>

// create a new DelegatorStartingInfo
func NewDelegatorStartingInfo(previousPeriod uint64, stake math.Int, height uint64) DelegatorStartingInfo <span class="cov0" title="0">{
        return DelegatorStartingInfo{
                PreviousPeriod: previousPeriod,
                Stake:          stake,
                Height:         height,
        }
}</span>
</pre>
		
		<pre class="file" id="file184" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/reporter/delegation.proto

package types

import (
        cosmossdk_io_math "cosmossdk.io/math"
        fmt "fmt"
        _ "github.com/cosmos/cosmos-proto"
        _ "github.com/cosmos/cosmos-sdk/types/tx/amino"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Delegation is a type that represents a delegator's delegation to a reporter
type Delegation struct {
        // reporter is the address of the reporter being delegated to
        Reporter string `protobuf:"bytes,1,opt,name=reporter,proto3" json:"reporter,omitempty"`
        // amount is the amount of tokens delegated
        Amount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
}

func (m *Delegation) Reset()         <span class="cov0" title="0">{ *m = Delegation{} }</span>
func (m *Delegation) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Delegation) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Delegation) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_66d928de90a17af7, []int{0}
}</span>
func (m *Delegation) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Delegation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Delegation.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Delegation) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Delegation.Merge(m, src)
}</span>
func (m *Delegation) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Delegation) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Delegation.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Delegation proto.InternalMessageInfo

func (m *Delegation) GetReporter() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Reporter
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Delegation)(nil), "layer.reporter.Delegation")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/reporter/delegation.proto", fileDescriptor_66d928de90a17af7) }</span>

var fileDescriptor_66d928de90a17af7 = []byte{
        // 244 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0xcf, 0x49, 0xac, 0x4c,
        0x2d, 0xd2, 0x2f, 0x4a, 0x2d, 0xc8, 0x2f, 0x2a, 0x49, 0x2d, 0xd2, 0x4f, 0x49, 0xcd, 0x49, 0x4d,
        0x4f, 0x2c, 0xc9, 0xcc, 0xcf, 0xd3, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x03, 0x2b, 0xd0,
        0x83, 0x29, 0x90, 0x12, 0x4c, 0xcc, 0xcd, 0xcc, 0xcb, 0xd7, 0x07, 0x93, 0x10, 0x25, 0x52, 0x92,
        0xc9, 0xf9, 0xc5, 0xb9, 0xf9, 0xc5, 0xf1, 0x60, 0x9e, 0x3e, 0x84, 0x03, 0x95, 0x12, 0x49, 0xcf,
        0x4f, 0xcf, 0x87, 0x88, 0x83, 0x58, 0x10, 0x51, 0xa5, 0x5c, 0x2e, 0x2e, 0x17, 0xb8, 0x3d, 0x42,
        0x52, 0x5c, 0x1c, 0x30, 0xd3, 0x25, 0x18, 0x15, 0x18, 0x35, 0x38, 0x83, 0xe0, 0x7c, 0x21, 0x67,
        0x2e, 0xb6, 0xc4, 0xdc, 0xfc, 0xd2, 0xbc, 0x12, 0x09, 0x26, 0x90, 0x8c, 0x93, 0xf6, 0x89, 0x7b,
        0xf2, 0x0c, 0xb7, 0xee, 0xc9, 0x8b, 0x42, 0x6c, 0x29, 0x4e, 0xc9, 0xd6, 0xcb, 0xcc, 0xd7, 0xcf,
        0x4d, 0x2c, 0xc9, 0xd0, 0xf3, 0xcc, 0x2b, 0xb9, 0xb4, 0x45, 0x97, 0x0b, 0x6a, 0xbd, 0x67, 0x5e,
        0x49, 0x10, 0x54, 0xab, 0x93, 0xeb, 0x89, 0x47, 0x72, 0x8c, 0x17, 0x1e, 0xc9, 0x31, 0x3e, 0x78,
        0x24, 0xc7, 0x38, 0xe1, 0xb1, 0x1c, 0xc3, 0x85, 0xc7, 0x72, 0x0c, 0x37, 0x1e, 0xcb, 0x31, 0x44,
        0x69, 0xa7, 0x67, 0x96, 0x64, 0x94, 0x26, 0xe9, 0x25, 0xe7, 0xe7, 0xea, 0x97, 0xa4, 0xe6, 0xe4,
        0xe4, 0x17, 0xe9, 0x66, 0xe6, 0xeb, 0x43, 0x82, 0xa4, 0x02, 0x11, 0x28, 0x25, 0x95, 0x05, 0xa9,
        0xc5, 0x49, 0x6c, 0x60, 0xc7, 0x1b, 0x03, 0x02, 0x00, 0x00, 0xff, 0xff, 0xcf, 0x00, 0xfb, 0xcc,
        0x33, 0x01, 0x00, 0x00,
}

func (m *Delegation) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Delegation) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Delegation) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size := m.Amount.Size()
                i -= size
                if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintDelegation(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x12
        if len(m.Reporter) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Reporter)
                copy(dAtA[i:], m.Reporter)
                i = encodeVarintDelegation(dAtA, i, uint64(len(m.Reporter)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintDelegation(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovDelegation(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Delegation) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Reporter)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovDelegation(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Amount.Size()
        n += 1 + l + sovDelegation(uint64(l))
        return n</span>
}

func sovDelegation(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozDelegation(x uint64) (n int) <span class="cov0" title="0">{
        return sovDelegation(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Delegation) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowDelegation
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Delegation: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Delegation: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDelegation
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDelegation
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDelegation
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Reporter = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDelegation
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDelegation
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDelegation
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipDelegation(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDelegation
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipDelegation(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowDelegation
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowDelegation
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowDelegation
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthDelegation
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupDelegation
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthDelegation
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthDelegation        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowDelegation          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupDelegation = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file185" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/reporter/distribution.proto

package types

import (
        cosmossdk_io_math "cosmossdk.io/math"
        fmt "fmt"
        _ "github.com/cosmos/cosmos-proto"
        github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
        types "github.com/cosmos/cosmos-sdk/types"
        _ "github.com/cosmos/cosmos-sdk/types/tx/amino"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ReporterAccumulatedCommission represents accumulated commission for a reporter
type ReporterAccumulatedCommission struct {
        // commission is the accumulated commission for the reporter
        Commission github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,1,rep,name=commission,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"commission"`
}

func (m *ReporterAccumulatedCommission) Reset()         <span class="cov0" title="0">{ *m = ReporterAccumulatedCommission{} }</span>
func (m *ReporterAccumulatedCommission) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ReporterAccumulatedCommission) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ReporterAccumulatedCommission) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_7aca8e2611e4a9eb, []int{0}
}</span>
func (m *ReporterAccumulatedCommission) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ReporterAccumulatedCommission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ReporterAccumulatedCommission.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ReporterAccumulatedCommission) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ReporterAccumulatedCommission.Merge(m, src)
}</span>
func (m *ReporterAccumulatedCommission) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ReporterAccumulatedCommission) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ReporterAccumulatedCommission.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ReporterAccumulatedCommission proto.InternalMessageInfo

func (m *ReporterAccumulatedCommission) GetCommission() github_com_cosmos_cosmos_sdk_types.DecCoins <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Commission
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ReporterOutstandingRewards represents outstanding (un-withdrawn) rewards
// for a reporter inexpensive to track, allows simple sanity checks.
type ReporterOutstandingRewards struct {
        // rewards is the outstanding rewards for the reporter
        Rewards github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,1,rep,name=rewards,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"rewards"`
}

func (m *ReporterOutstandingRewards) Reset()         <span class="cov0" title="0">{ *m = ReporterOutstandingRewards{} }</span>
func (m *ReporterOutstandingRewards) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ReporterOutstandingRewards) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ReporterOutstandingRewards) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_7aca8e2611e4a9eb, []int{1}
}</span>
func (m *ReporterOutstandingRewards) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ReporterOutstandingRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ReporterOutstandingRewards.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ReporterOutstandingRewards) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ReporterOutstandingRewards.Merge(m, src)
}</span>
func (m *ReporterOutstandingRewards) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ReporterOutstandingRewards) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ReporterOutstandingRewards.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ReporterOutstandingRewards proto.InternalMessageInfo

func (m *ReporterOutstandingRewards) GetRewards() github_com_cosmos_cosmos_sdk_types.DecCoins <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Rewards
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DelegatorStartingInfo represents the starting info for a delegator reward
// period. It tracks the previous reporter period, the delegation's amount of
// staking token, and the creation height (to check later on if any disputes have
// occurred).
type DelegatorStartingInfo struct {
        // previous_period is the period last tracked for the delegator
        PreviousPeriod uint64 `protobuf:"varint,1,opt,name=previous_period,json=previousPeriod,proto3" json:"previous_period,omitempty"`
        // stake is the amount of staking token delegated.
        Stake cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=stake,proto3,customtype=cosmossdk.io/math.Int" json:"stake"`
        // creation_height is the height at which the starting was created/last updated.
        Height uint64 `protobuf:"varint,3,opt,name=height,proto3" json:"creation_height"`
}

func (m *DelegatorStartingInfo) Reset()         <span class="cov0" title="0">{ *m = DelegatorStartingInfo{} }</span>
func (m *DelegatorStartingInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DelegatorStartingInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*DelegatorStartingInfo) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_7aca8e2611e4a9eb, []int{2}
}</span>
func (m *DelegatorStartingInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *DelegatorStartingInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_DelegatorStartingInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *DelegatorStartingInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_DelegatorStartingInfo.Merge(m, src)
}</span>
func (m *DelegatorStartingInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *DelegatorStartingInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_DelegatorStartingInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_DelegatorStartingInfo proto.InternalMessageInfo

func (m *DelegatorStartingInfo) GetPreviousPeriod() uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PreviousPeriod
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *DelegatorStartingInfo) GetHeight() uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Height
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// ReporterHistoricalRewards represents historical rewards for a reporter.
// Height is implicit within the store key.
// Cumulative reward ratio is the sum from the zeroeth period
// until this period of rewards / tokens, per the spec.
// The reference count indicates the number of objects
// which might need to reference this historical entry at any point.
// ReferenceCount =
//
//          number of outstanding delegations which ended the associated period (and
//          might need to read that record)
//        + number of slashes which ended the associated period (and might need to
//        read that record)
//        + one per reporter for the zeroeth period, set on initialization
type ReporterHistoricalRewards struct {
        CumulativeRewardRatio github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,1,rep,name=cumulative_reward_ratio,json=cumulativeRewardRatio,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"cumulative_reward_ratio"`
        ReferenceCount        uint32                                      `protobuf:"varint,2,opt,name=reference_count,json=referenceCount,proto3" json:"reference_count,omitempty"`
}

func (m *ReporterHistoricalRewards) Reset()         <span class="cov0" title="0">{ *m = ReporterHistoricalRewards{} }</span>
func (m *ReporterHistoricalRewards) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ReporterHistoricalRewards) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ReporterHistoricalRewards) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_7aca8e2611e4a9eb, []int{3}
}</span>
func (m *ReporterHistoricalRewards) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ReporterHistoricalRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ReporterHistoricalRewards.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ReporterHistoricalRewards) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ReporterHistoricalRewards.Merge(m, src)
}</span>
func (m *ReporterHistoricalRewards) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ReporterHistoricalRewards) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ReporterHistoricalRewards.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ReporterHistoricalRewards proto.InternalMessageInfo

func (m *ReporterHistoricalRewards) GetCumulativeRewardRatio() github_com_cosmos_cosmos_sdk_types.DecCoins <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CumulativeRewardRatio
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ReporterHistoricalRewards) GetReferenceCount() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ReferenceCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// ReporterCurrentRewards represents current rewards and current
// period for a reporter kept as a running counter and incremented
// each block as long as the reporter's tokens remain constant.
type ReporterCurrentRewards struct {
        Rewards github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,1,rep,name=rewards,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"rewards"`
        Period  uint64                                      `protobuf:"varint,2,opt,name=period,proto3" json:"period,omitempty"`
}

func (m *ReporterCurrentRewards) Reset()         <span class="cov0" title="0">{ *m = ReporterCurrentRewards{} }</span>
func (m *ReporterCurrentRewards) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ReporterCurrentRewards) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ReporterCurrentRewards) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_7aca8e2611e4a9eb, []int{4}
}</span>
func (m *ReporterCurrentRewards) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ReporterCurrentRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ReporterCurrentRewards.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ReporterCurrentRewards) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ReporterCurrentRewards.Merge(m, src)
}</span>
func (m *ReporterCurrentRewards) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ReporterCurrentRewards) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ReporterCurrentRewards.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ReporterCurrentRewards proto.InternalMessageInfo

func (m *ReporterCurrentRewards) GetRewards() github_com_cosmos_cosmos_sdk_types.DecCoins <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Rewards
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ReporterCurrentRewards) GetPeriod() uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Period
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// ReporterDisputeEvent tracks disputes and the fraction of the
// reporter's stake that is slashed.
type ReporterDisputeEvent struct {
        ReporterPeriod uint64                      `protobuf:"varint,1,opt,name=reporter_period,json=reporterPeriod,proto3" json:"reporter_period,omitempty"`
        Fraction       cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=fraction,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"fraction"`
}

func (m *ReporterDisputeEvent) Reset()         <span class="cov0" title="0">{ *m = ReporterDisputeEvent{} }</span>
func (m *ReporterDisputeEvent) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ReporterDisputeEvent) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ReporterDisputeEvent) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_7aca8e2611e4a9eb, []int{5}
}</span>
func (m *ReporterDisputeEvent) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ReporterDisputeEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ReporterDisputeEvent.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ReporterDisputeEvent) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ReporterDisputeEvent.Merge(m, src)
}</span>
func (m *ReporterDisputeEvent) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ReporterDisputeEvent) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ReporterDisputeEvent.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ReporterDisputeEvent proto.InternalMessageInfo

func (m *ReporterDisputeEvent) GetReporterPeriod() uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ReporterPeriod
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*ReporterAccumulatedCommission)(nil), "layer.reporter.ReporterAccumulatedCommission")
        proto.RegisterType((*ReporterOutstandingRewards)(nil), "layer.reporter.ReporterOutstandingRewards")
        proto.RegisterType((*DelegatorStartingInfo)(nil), "layer.reporter.DelegatorStartingInfo")
        proto.RegisterType((*ReporterHistoricalRewards)(nil), "layer.reporter.ReporterHistoricalRewards")
        proto.RegisterType((*ReporterCurrentRewards)(nil), "layer.reporter.ReporterCurrentRewards")
        proto.RegisterType((*ReporterDisputeEvent)(nil), "layer.reporter.ReporterDisputeEvent")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/reporter/distribution.proto", fileDescriptor_7aca8e2611e4a9eb) }</span>

var fileDescriptor_7aca8e2611e4a9eb = []byte{
        // 601 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x54, 0xc1, 0x4f, 0x14, 0x3f,
        0x14, 0xde, 0xc2, 0xef, 0x87, 0x5a, 0x23, 0xc4, 0x09, 0xe0, 0xb2, 0xea, 0x2c, 0xee, 0x45, 0x02,
        0x32, 0x13, 0xf4, 0xe2, 0x95, 0xdd, 0x25, 0x91, 0x44, 0xa3, 0x19, 0x6f, 0x5e, 0x36, 0xdd, 0xce,
        0x63, 0xb6, 0x61, 0xa6, 0x9d, 0xb4, 0x6f, 0x56, 0xf9, 0x27, 0x88, 0x37, 0xef, 0x9c, 0x8c, 0x27,
        0x0e, 0xfe, 0x11, 0x78, 0x23, 0x26, 0x26, 0xc6, 0x03, 0x1a, 0x38, 0x90, 0xf8, 0x57, 0x98, 0x99,
        0x76, 0x80, 0xe0, 0x99, 0x78, 0xd9, 0xed, 0xfb, 0xda, 0xbe, 0xef, 0x7b, 0xdf, 0x7c, 0x29, 0x7d,
        0x90, 0xb2, 0x1d, 0xd0, 0xa1, 0x86, 0x5c, 0x69, 0x04, 0x1d, 0xc6, 0xc2, 0xa0, 0x16, 0xc3, 0x02,
        0x85, 0x92, 0x41, 0xae, 0x15, 0x2a, 0x6f, 0xba, 0x3a, 0x12, 0xd4, 0x47, 0x5a, 0xb7, 0x59, 0x26,
        0xa4, 0x0a, 0xab, 0x5f, 0x7b, 0xa4, 0xe5, 0x73, 0x65, 0x32, 0x65, 0xc2, 0x21, 0x33, 0x10, 0x8e,
        0xd7, 0x86, 0x80, 0x6c, 0x2d, 0xe4, 0x4a, 0xb8, 0x16, 0xad, 0x05, 0xbb, 0x3f, 0xa8, 0xaa, 0xd0,
        0x16, 0x6e, 0x6b, 0x36, 0x51, 0x89, 0xb2, 0x78, 0xb9, 0xb2, 0x68, 0xe7, 0x03, 0xa1, 0xf7, 0x23,
        0x47, 0xb8, 0xce, 0x79, 0x91, 0x15, 0x29, 0x43, 0x88, 0x7b, 0x2a, 0xcb, 0x84, 0x31, 0x42, 0x49,
        0x6f, 0x4c, 0x29, 0x3f, 0xab, 0x9a, 0x64, 0x71, 0x72, 0xe9, 0xe6, 0xe3, 0x7b, 0x81, 0x6b, 0x5d,
        0xea, 0x08, 0x9c, 0x8e, 0xa0, 0x0f, 0xbc, 0xa7, 0x84, 0xec, 0x3e, 0x3d, 0x38, 0x6a, 0x37, 0x3e,
        0xfd, 0x6c, 0xaf, 0x24, 0x02, 0x47, 0xc5, 0x30, 0xe0, 0x2a, 0x73, 0x52, 0xdc, 0xdf, 0xaa, 0x89,
        0xb7, 0x43, 0xdc, 0xc9, 0xc1, 0xd4, 0x77, 0xcc, 0xc7, 0xd3, 0xfd, 0x65, 0x12, 0x5d, 0x60, 0xea,
        0xec, 0x12, 0xda, 0xaa, 0x95, 0xbd, 0x2c, 0xd0, 0x20, 0x93, 0xb1, 0x90, 0x49, 0x04, 0x6f, 0x99,
        0x8e, 0x8d, 0x97, 0xd3, 0x6b, 0xda, 0x2e, 0xaf, 0x58, 0x53, 0x4d, 0xd3, 0xf9, 0x42, 0xe8, 0x5c,
        0x1f, 0x52, 0x48, 0x18, 0x2a, 0xfd, 0x1a, 0x99, 0x46, 0x21, 0x93, 0x4d, 0xb9, 0xa5, 0xbc, 0x87,
        0x74, 0x26, 0xd7, 0x30, 0x16, 0xaa, 0x30, 0x83, 0x1c, 0xb4, 0x50, 0x71, 0x93, 0x2c, 0x92, 0xa5,
        0xff, 0xa2, 0xe9, 0x1a, 0x7e, 0x55, 0xa1, 0xde, 0x3a, 0xfd, 0xdf, 0x20, 0xdb, 0x86, 0xe6, 0xc4,
        0x22, 0x59, 0xba, 0xd1, 0x5d, 0x29, 0x45, 0xfd, 0x38, 0x6a, 0xcf, 0x59, 0x09, 0x26, 0xde, 0x0e,
        0x84, 0x0a, 0x33, 0x86, 0xa3, 0x60, 0x53, 0xe2, 0xd7, 0xcf, 0xab, 0xd4, 0x8d, 0xb4, 0x29, 0x31,
        0xb2, 0x37, 0xbd, 0x3e, 0x9d, 0x1a, 0x81, 0x48, 0x46, 0xd8, 0x9c, 0x2c, 0x29, 0xba, 0x8f, 0x7e,
        0x1f, 0xb5, 0x67, 0xb8, 0x06, 0x56, 0x06, 0x69, 0x60, 0xb7, 0xf6, 0x4e, 0xf7, 0x97, 0x2f, 0x63,
        0x76, 0x18, 0x77, 0xb7, 0xf3, 0x8d, 0xd0, 0x85, 0xda, 0xdc, 0x67, 0xc2, 0xa0, 0xd2, 0x82, 0xb3,
        0xb4, 0xf6, 0x76, 0x97, 0xd0, 0x3b, 0x2e, 0x0a, 0x62, 0x0c, 0x03, 0x6b, 0xc0, 0x40, 0x97, 0xed,
        0xae, 0xd8, 0xec, 0xb9, 0x73, 0x5a, 0x2b, 0x26, 0x2a, 0x49, 0x4b, 0x83, 0x35, 0x6c, 0x81, 0x06,
        0xc9, 0x61, 0xc0, 0x55, 0x21, 0xb1, 0x72, 0xf0, 0x56, 0x34, 0x7d, 0x06, 0xf7, 0x4a, 0xb4, 0xb3,
        0x47, 0xe8, 0x7c, 0x3d, 0x57, 0xaf, 0xd0, 0x1a, 0x24, 0xfe, 0xb3, 0xc0, 0x78, 0xf3, 0x74, 0xca,
        0xa5, 0x61, 0xa2, 0x4a, 0x83, 0xab, 0xca, 0x64, 0xcf, 0xd6, 0x22, 0xfb, 0xc2, 0xe4, 0x05, 0xc2,
        0xc6, 0x18, 0x24, 0xda, 0x31, 0x2d, 0x7e, 0x29, 0x47, 0x35, 0xec, 0x72, 0xf4, 0x82, 0x5e, 0xdf,
        0xd2, 0x8c, 0x97, 0x9f, 0xd7, 0x45, 0x69, 0xcd, 0x45, 0xe9, 0xee, 0xdf, 0x51, 0x7a, 0x0e, 0x09,
        0xe3, 0x3b, 0x7d, 0xe0, 0x17, 0x02, 0xd5, 0x07, 0x1e, 0x9d, 0xb5, 0xe8, 0x6e, 0x1c, 0x1c, 0xfb,
        0xe4, 0xf0, 0xd8, 0x27, 0xbf, 0x8e, 0x7d, 0xf2, 0xfe, 0xc4, 0x6f, 0x1c, 0x9e, 0xf8, 0x8d, 0xef,
        0x27, 0x7e, 0xe3, 0xcd, 0xc5, 0xe9, 0x11, 0xd2, 0x54, 0xe9, 0x55, 0xa1, 0x42, 0xfb, 0x94, 0xbd,
        0x3b, 0x7f, 0xcc, 0x2a, 0x1b, 0x86, 0x53, 0xd5, 0x93, 0xf2, 0xe4, 0x4f, 0x00, 0x00, 0x00, 0xff,
        0xff, 0x1b, 0x43, 0xb9, 0x42, 0xeb, 0x04, 0x00, 0x00,
}

func (m *ReporterAccumulatedCommission) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *ReporterAccumulatedCommission) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ReporterAccumulatedCommission) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Commission) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Commission) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Commission[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintDistribution(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *ReporterOutstandingRewards) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *ReporterOutstandingRewards) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ReporterOutstandingRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Rewards) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Rewards) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Rewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintDistribution(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *DelegatorStartingInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *DelegatorStartingInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *DelegatorStartingInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Height != 0 </span><span class="cov0" title="0">{
                i = encodeVarintDistribution(dAtA, i, uint64(m.Height))
                i--
                dAtA[i] = 0x18
        }</span>
        <span class="cov0" title="0">{
                size := m.Stake.Size()
                i -= size
                if _, err := m.Stake.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintDistribution(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x12
        if m.PreviousPeriod != 0 </span><span class="cov0" title="0">{
                i = encodeVarintDistribution(dAtA, i, uint64(m.PreviousPeriod))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *ReporterHistoricalRewards) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *ReporterHistoricalRewards) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ReporterHistoricalRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.ReferenceCount != 0 </span><span class="cov0" title="0">{
                i = encodeVarintDistribution(dAtA, i, uint64(m.ReferenceCount))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.CumulativeRewardRatio) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.CumulativeRewardRatio) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.CumulativeRewardRatio[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintDistribution(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *ReporterCurrentRewards) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *ReporterCurrentRewards) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ReporterCurrentRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Period != 0 </span><span class="cov0" title="0">{
                i = encodeVarintDistribution(dAtA, i, uint64(m.Period))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.Rewards) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Rewards) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Rewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintDistribution(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *ReporterDisputeEvent) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *ReporterDisputeEvent) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ReporterDisputeEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size := m.Fraction.Size()
                i -= size
                if _, err := m.Fraction.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintDistribution(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x12
        if m.ReporterPeriod != 0 </span><span class="cov0" title="0">{
                i = encodeVarintDistribution(dAtA, i, uint64(m.ReporterPeriod))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintDistribution(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovDistribution(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *ReporterAccumulatedCommission) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Commission) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Commission </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovDistribution(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *ReporterOutstandingRewards) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Rewards) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Rewards </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovDistribution(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *DelegatorStartingInfo) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.PreviousPeriod != 0 </span><span class="cov0" title="0">{
                n += 1 + sovDistribution(uint64(m.PreviousPeriod))
        }</span>
        <span class="cov0" title="0">l = m.Stake.Size()
        n += 1 + l + sovDistribution(uint64(l))
        if m.Height != 0 </span><span class="cov0" title="0">{
                n += 1 + sovDistribution(uint64(m.Height))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *ReporterHistoricalRewards) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.CumulativeRewardRatio) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.CumulativeRewardRatio </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovDistribution(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">if m.ReferenceCount != 0 </span><span class="cov0" title="0">{
                n += 1 + sovDistribution(uint64(m.ReferenceCount))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *ReporterCurrentRewards) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Rewards) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Rewards </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovDistribution(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">if m.Period != 0 </span><span class="cov0" title="0">{
                n += 1 + sovDistribution(uint64(m.Period))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *ReporterDisputeEvent) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.ReporterPeriod != 0 </span><span class="cov0" title="0">{
                n += 1 + sovDistribution(uint64(m.ReporterPeriod))
        }</span>
        <span class="cov0" title="0">l = m.Fraction.Size()
        n += 1 + l + sovDistribution(uint64(l))
        return n</span>
}

func sovDistribution(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozDistribution(x uint64) (n int) <span class="cov0" title="0">{
        return sovDistribution(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *ReporterAccumulatedCommission) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowDistribution
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ReporterAccumulatedCommission: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ReporterAccumulatedCommission: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDistribution
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDistribution
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDistribution
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Commission = append(m.Commission, types.DecCoin{})
                        if err := m.Commission[len(m.Commission)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipDistribution(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDistribution
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *ReporterOutstandingRewards) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowDistribution
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ReporterOutstandingRewards: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ReporterOutstandingRewards: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDistribution
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDistribution
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDistribution
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Rewards = append(m.Rewards, types.DecCoin{})
                        if err := m.Rewards[len(m.Rewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipDistribution(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDistribution
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *DelegatorStartingInfo) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowDistribution
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: DelegatorStartingInfo: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: DelegatorStartingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PreviousPeriod", wireType)
                        }</span>
                        <span class="cov0" title="0">m.PreviousPeriod = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDistribution
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.PreviousPeriod |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Stake", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDistribution
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDistribution
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDistribution
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Stake.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Height = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDistribution
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Height |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipDistribution(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDistribution
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *ReporterHistoricalRewards) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowDistribution
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ReporterHistoricalRewards: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ReporterHistoricalRewards: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CumulativeRewardRatio", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDistribution
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDistribution
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDistribution
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.CumulativeRewardRatio = append(m.CumulativeRewardRatio, types.DecCoin{})
                        if err := m.CumulativeRewardRatio[len(m.CumulativeRewardRatio)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ReferenceCount", wireType)
                        }</span>
                        <span class="cov0" title="0">m.ReferenceCount = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDistribution
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.ReferenceCount |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipDistribution(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDistribution
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *ReporterCurrentRewards) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowDistribution
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ReporterCurrentRewards: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ReporterCurrentRewards: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDistribution
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDistribution
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDistribution
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Rewards = append(m.Rewards, types.DecCoin{})
                        if err := m.Rewards[len(m.Rewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Period", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Period = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDistribution
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Period |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipDistribution(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDistribution
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *ReporterDisputeEvent) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowDistribution
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ReporterDisputeEvent: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ReporterDisputeEvent: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ReporterPeriod", wireType)
                        }</span>
                        <span class="cov0" title="0">m.ReporterPeriod = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDistribution
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.ReporterPeriod |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Fraction", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowDistribution
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDistribution
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDistribution
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Fraction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipDistribution(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthDistribution
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipDistribution(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowDistribution
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowDistribution
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowDistribution
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthDistribution
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupDistribution
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthDistribution
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthDistribution        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowDistribution          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupDistribution = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file186" style="display: none">package types

// this line is used by starport scaffolding # genesis/types/import

// DefaultIndex is the default global index
const DefaultIndex uint64 = 1

// DefaultGenesis returns the default genesis state
func DefaultGenesis() *GenesisState <span class="cov8" title="1">{
        return &amp;GenesisState{
                // this line is used by starport scaffolding # genesis/types/default
                Params: DefaultParams(),
        }
}</span>

// Validate performs basic genesis state validation returning an error upon any
// failure.
func (gs GenesisState) Validate() error <span class="cov8" title="1">{
        // this line is used by starport scaffolding # genesis/types/validate

        return gs.Params.Validate()
}</span>
</pre>
		
		<pre class="file" id="file187" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/reporter/genesis.proto

package types

import (
        fmt "fmt"
        _ "github.com/cosmos/cosmos-sdk/types/tx/amino"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GenesisState defines the reporter module's genesis state.
type GenesisState struct {
        // params defines all the parameters of the module.
        Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
}

func (m *GenesisState) Reset()         <span class="cov0" title="0">{ *m = GenesisState{} }</span>
func (m *GenesisState) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GenesisState) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GenesisState) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_1affa61e846a6c93, []int{0}
}</span>
func (m *GenesisState) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *GenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_GenesisState.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *GenesisState) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GenesisState.Merge(m, src)
}</span>
func (m *GenesisState) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *GenesisState) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GenesisState.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GenesisState proto.InternalMessageInfo

func (m *GenesisState) GetParams() Params <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Params
        }</span>
        <span class="cov0" title="0">return Params{}</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*GenesisState)(nil), "layer.reporter.GenesisState")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/reporter/genesis.proto", fileDescriptor_1affa61e846a6c93) }</span>

var fileDescriptor_1affa61e846a6c93 = []byte{
        // 209 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0xc9, 0x49, 0xac, 0x4c,
        0x2d, 0xd2, 0x2f, 0x4a, 0x2d, 0xc8, 0x2f, 0x2a, 0x49, 0x2d, 0xd2, 0x4f, 0x4f, 0xcd, 0x4b, 0x2d,
        0xce, 0x2c, 0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x03, 0xcb, 0xea, 0xc1, 0x64, 0xa5,
        0x04, 0x13, 0x73, 0x33, 0xf3, 0xf2, 0xf5, 0xc1, 0x24, 0x44, 0x89, 0x94, 0x48, 0x7a, 0x7e, 0x7a,
        0x3e, 0x98, 0xa9, 0x0f, 0x62, 0x41, 0x45, 0xa5, 0xd1, 0x8c, 0x2d, 0x48, 0x2c, 0x4a, 0xcc, 0x85,
        0x9a, 0xaa, 0xe4, 0xc9, 0xc5, 0xe3, 0x0e, 0xb1, 0x26, 0xb8, 0x24, 0xb1, 0x24, 0x55, 0xc8, 0x92,
        0x8b, 0x0d, 0x22, 0x2f, 0xc1, 0xa8, 0xc0, 0xa8, 0xc1, 0x6d, 0x24, 0xa6, 0x87, 0x6a, 0xad, 0x5e,
        0x00, 0x58, 0xd6, 0x89, 0xf3, 0xc4, 0x3d, 0x79, 0x86, 0x15, 0xcf, 0x37, 0x68, 0x31, 0x06, 0x41,
        0x35, 0x38, 0xb9, 0x9e, 0x78, 0x24, 0xc7, 0x78, 0xe1, 0x91, 0x1c, 0xe3, 0x83, 0x47, 0x72, 0x8c,
        0x13, 0x1e, 0xcb, 0x31, 0x5c, 0x78, 0x2c, 0xc7, 0x70, 0xe3, 0xb1, 0x1c, 0x43, 0x94, 0x76, 0x7a,
        0x66, 0x49, 0x46, 0x69, 0x92, 0x5e, 0x72, 0x7e, 0xae, 0x7e, 0x49, 0x6a, 0x4e, 0x4e, 0x7e, 0x91,
        0x6e, 0x66, 0xbe, 0x3e, 0xc4, 0x59, 0x15, 0x08, 0x87, 0x95, 0x54, 0x16, 0xa4, 0x16, 0x27, 0xb1,
        0x81, 0x1d, 0x66, 0x0c, 0x08, 0x00, 0x00, 0xff, 0xff, 0x4d, 0x1b, 0xa6, 0xa6, 0x0e, 0x01, 0x00,
        0x00,
}

func (m *GenesisState) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *GenesisState) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *GenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintGenesis(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func encodeVarintGenesis(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovGenesis(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *GenesisState) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Params.Size()
        n += 1 + l + sovGenesis(uint64(l))
        return n</span>
}

func sovGenesis(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozGenesis(x uint64) (n int) <span class="cov0" title="0">{
        return sovGenesis(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *GenesisState) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowGenesis
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipGenesis(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipGenesis(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowGenesis
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupGenesis
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthGenesis
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthGenesis        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowGenesis          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupGenesis = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file188" style="display: none">package types

import "cosmossdk.io/collections"

const (
        // ModuleName defines the module name
        ModuleName = "reporter"

        // StoreKey defines the primary module store key
        StoreKey = ModuleName

        // MemStoreKey defines the in-memory store key
        MemStoreKey = "mem_reporter"

        Denom = "loya"

        TipsEscrowPool = "tips_escrow_pool"
)

var (
        ParamsKey                           = []byte("p_reporter")
        ReportersKey                        = collections.NewPrefix(11)
        DelegatorsKey                       = collections.NewPrefix(12)
        TokenOriginsKey                     = collections.NewPrefix(13)
        ReporterAccumulatedCommissionPrefix = collections.NewPrefix(14)
        ReporterOutstandingRewardsPrefix    = collections.NewPrefix(15)
        ReporterCurrentRewardsPrefix        = collections.NewPrefix(16)
        DelegatorStartingInfoPrefix         = collections.NewPrefix(17)
        ReporterHistoricalRewardsPrefix     = collections.NewPrefix(18)
        ReporterDisputeEventPrefix          = collections.NewPrefix(19)
        ReporterDelegatorsIndexPrefix       = collections.NewPrefix(20)
        TokenOriginSnapshotPrefix           = collections.NewPrefix(21)
        DelegatorTipsPrefix                 = collections.NewPrefix(22)
)

func KeyPrefix(p string) []byte <span class="cov0" title="0">{
        return []byte(p)
}</span>
</pre>
		
		<pre class="file" id="file189" style="display: none">package types

import (
        errorsmod "cosmossdk.io/errors"
        "cosmossdk.io/math"
        sdk "github.com/cosmos/cosmos-sdk/types"
        sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
        stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
)

var _ sdk.Msg = &amp;MsgCreateReporter{}

func NewMsgCreateReporter(reporter string, amount math.Int, tokenOrigins []*TokenOrigin, commission *stakingtypes.Commission) *MsgCreateReporter <span class="cov0" title="0">{
        return &amp;MsgCreateReporter{
                Reporter:     reporter,
                Amount:       amount,
                TokenOrigins: tokenOrigins,
                Commission:   commission,
        }
}</span>

func (msg *MsgCreateReporter) ValidateBasic() error <span class="cov8" title="1">{
        _, err := sdk.AccAddressFromBech32(msg.Reporter)
        if err != nil </span><span class="cov8" title="1">{
                return errorsmod.Wrapf(sdkerrors.ErrInvalidAddress, "invalid creator address (%s)", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file190" style="display: none">package types

import (
        errorsmod "cosmossdk.io/errors"
        "cosmossdk.io/math"
        sdk "github.com/cosmos/cosmos-sdk/types"
        sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
)

var _ sdk.Msg = &amp;MsgDelegateReporter{}

func NewMsgDelegateReporter(delegator string, reporter string, amount math.Int, tokenOrigin []*TokenOrigin) *MsgDelegateReporter <span class="cov0" title="0">{
        return &amp;MsgDelegateReporter{
                Delegator:    delegator,
                Reporter:     reporter,
                Amount:       amount,
                TokenOrigins: tokenOrigin,
        }
}</span>

func (msg *MsgDelegateReporter) ValidateBasic() error <span class="cov8" title="1">{
        _, err := sdk.AccAddressFromBech32(msg.Delegator)
        if err != nil </span><span class="cov8" title="1">{
                return errorsmod.Wrapf(sdkerrors.ErrInvalidAddress, "invalid delegator address (%s)", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file191" style="display: none">package types

import (
        errorsmod "cosmossdk.io/errors"
        sdk "github.com/cosmos/cosmos-sdk/types"
        sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
)

var _ sdk.Msg = &amp;MsgUndelegateReporter{}

func NewMsgUndelegateReporter(delegator string, tokenOrigin []*TokenOrigin) *MsgUndelegateReporter <span class="cov0" title="0">{
        return &amp;MsgUndelegateReporter{
                DelegatorAddress: delegator,
                TokenOrigins:     tokenOrigin,
        }
}</span>

func (msg *MsgUndelegateReporter) ValidateBasic() error <span class="cov8" title="1">{
        _, err := sdk.AccAddressFromBech32(msg.DelegatorAddress)
        if err != nil </span><span class="cov8" title="1">{
                return errorsmod.Wrapf(sdkerrors.ErrInvalidAddress, "invalid delegator address (%s)", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file192" style="display: none">package types

import (
        errorsmod "cosmossdk.io/errors"
        sdk "github.com/cosmos/cosmos-sdk/types"
        sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
)

var _ sdk.Msg = &amp;MsgWithdrawTip{}

func NewMsgWithdrawTip(validatorAddress string, delegatorAddress string) *MsgWithdrawTip <span class="cov0" title="0">{
        return &amp;MsgWithdrawTip{
                ValidatorAddress: validatorAddress,
                DelegatorAddress: delegatorAddress,
        }
}</span>

func (msg *MsgWithdrawTip) ValidateBasic() error <span class="cov8" title="1">{
        _, err := sdk.AccAddressFromBech32(msg.DelegatorAddress)
        if err != nil </span><span class="cov8" title="1">{
                return errorsmod.Wrapf(sdkerrors.ErrInvalidAddress, "invalid creator address (%s)", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file193" style="display: none">package types

import (
        errorsmod "cosmossdk.io/errors"
        sdk "github.com/cosmos/cosmos-sdk/types"
)

var _ sdk.Msg = &amp;MsgUpdateParams{}

// ValidateBasic does a sanity check on the provided data.
func (m *MsgUpdateParams) ValidateBasic() error <span class="cov0" title="0">{
        if _, err := sdk.AccAddressFromBech32(m.Authority); err != nil </span><span class="cov0" title="0">{
                return errorsmod.Wrap(err, "invalid authority address")
        }</span>

        <span class="cov0" title="0">if err := m.Params.Validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file194" style="display: none">package types

import (
        "time"

        "cosmossdk.io/math"
        sdk "github.com/cosmos/cosmos-sdk/types"
        stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
)

func NewOracleReporter(reporter string, totalAmount math.Int, commission *stakingtypes.Commission) OracleReporter <span class="cov0" title="0">{
        return OracleReporter{
                Reporter:    reporter,
                TotalTokens: totalAmount,
                Commission:  commission,
        }
}</span>

// alias
func NewCommissionWithTime(rate, maxRate, maxChangeRate math.LegacyDec, updatedAt time.Time) stakingtypes.Commission <span class="cov0" title="0">{
        return stakingtypes.Commission{
                CommissionRates: stakingtypes.NewCommissionRates(rate, maxRate, maxChangeRate),
                UpdateTime:      updatedAt,
        }
}</span>

// create a new ReporterHistoricalRewards
func NewReporterHistoricalRewards(cumulativeRewardRatio sdk.DecCoins, referenceCount uint32) ReporterHistoricalRewards <span class="cov0" title="0">{
        return ReporterHistoricalRewards{
                CumulativeRewardRatio: cumulativeRewardRatio,
                ReferenceCount:        referenceCount,
        }
}</span>

// create a new ReporterCurrentRewards
func NewReporterCurrentRewards(rewards sdk.DecCoins, period uint64) ReporterCurrentRewards <span class="cov0" title="0">{
        return ReporterCurrentRewards{
                Rewards: rewards,
                Period:  period,
        }
}</span>

// create a new ReporterDisputeEvent
func NewReporterDisputeEvent(reporterPeriod uint64, fraction math.LegacyDec) ReporterDisputeEvent <span class="cov0" title="0">{
        return ReporterDisputeEvent{
                ReporterPeriod: reporterPeriod,
                Fraction:       fraction,
        }
}</span>
</pre>
		
		<pre class="file" id="file195" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/reporter/oracle_reporter.proto

package types

import (
        cosmossdk_io_math "cosmossdk.io/math"
        fmt "fmt"
        _ "github.com/cosmos/cosmos-proto"
        _ "github.com/cosmos/cosmos-sdk/types/tx/amino"
        types "github.com/cosmos/cosmos-sdk/x/staking/types"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
        _ "google.golang.org/protobuf/types/known/timestamppb"
        io "io"
        math "math"
        math_bits "math/bits"
        time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// OracleReporter is the struct that holds the data for a reporter
type OracleReporter struct {
        // reporter is the address of the reporter
        Reporter string `protobuf:"bytes,1,opt,name=reporter,proto3" json:"reporter,omitempty"`
        // tokens is the amount of tokens the reporter has
        TotalTokens cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_tokens,json=totalTokens,proto3,customtype=cosmossdk.io/math.Int" json:"total_tokens"`
        // commission for the reporter
        Commission *types.Commission `protobuf:"bytes,3,opt,name=commission,proto3" json:"commission,omitempty"`
        // jailed is a bool whether the reporter is jailed or not
        Jailed bool `protobuf:"varint,4,opt,name=jailed,proto3" json:"jailed,omitempty"`
        // jailed_until is the time the reporter is jailed until
        JailedUntil time.Time `protobuf:"bytes,5,opt,name=jailed_until,json=jailedUntil,proto3,stdtime" json:"jailed_until"`
}

func (m *OracleReporter) Reset()         <span class="cov0" title="0">{ *m = OracleReporter{} }</span>
func (m *OracleReporter) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*OracleReporter) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*OracleReporter) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_28310cb3dcf79802, []int{0}
}</span>
func (m *OracleReporter) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *OracleReporter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_OracleReporter.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *OracleReporter) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_OracleReporter.Merge(m, src)
}</span>
func (m *OracleReporter) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *OracleReporter) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_OracleReporter.DiscardUnknown(m)
}</span>

var xxx_messageInfo_OracleReporter proto.InternalMessageInfo

func (m *OracleReporter) GetReporter() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Reporter
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *OracleReporter) GetCommission() *types.Commission <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Commission
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *OracleReporter) GetJailed() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Jailed
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *OracleReporter) GetJailedUntil() time.Time <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.JailedUntil
        }</span>
        <span class="cov0" title="0">return time.Time{}</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*OracleReporter)(nil), "layer.reporter.OracleReporter")
}</span>

func init() <span class="cov8" title="1">{
        proto.RegisterFile("layer/reporter/oracle_reporter.proto", fileDescriptor_28310cb3dcf79802)
}</span>

var fileDescriptor_28310cb3dcf79802 = []byte{
        // 397 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x4c, 0x52, 0xc1, 0x6e, 0xd4, 0x30,
        0x10, 0x5d, 0x17, 0xa8, 0x8a, 0xb7, 0x54, 0x22, 0x02, 0x14, 0x72, 0x48, 0x56, 0x55, 0x0f, 0x2b,
        0xaa, 0xda, 0x2a, 0xfc, 0x41, 0x10, 0x87, 0x4a, 0x08, 0xa4, 0xa8, 0x5c, 0xb8, 0x44, 0x4e, 0x6a,
        0x52, 0xb3, 0x76, 0x26, 0x8a, 0x67, 0x11, 0xfd, 0x8b, 0x7e, 0x05, 0xe2, 0xc8, 0x81, 0x8f, 0xe8,
        0xb1, 0xe2, 0x84, 0x38, 0x14, 0xb4, 0x7b, 0xe0, 0x37, 0x50, 0x6c, 0x67, 0xe9, 0x25, 0xf2, 0x9b,
        0x79, 0x6f, 0xf2, 0xe6, 0x69, 0xe8, 0x81, 0x16, 0x17, 0xb2, 0xe7, 0xbd, 0xec, 0xa0, 0x47, 0xd9,
        0x73, 0xe8, 0x45, 0xad, 0x65, 0x39, 0x62, 0xd6, 0xf5, 0x80, 0x10, 0xed, 0x39, 0x16, 0x1b, 0xab,
        0xc9, 0x43, 0x61, 0x54, 0x0b, 0xdc, 0x7d, 0x3d, 0x25, 0x39, 0xa8, 0xc1, 0x1a, 0xb0, 0xdc, 0xa2,
        0x58, 0xa8, 0xb6, 0xe1, 0x9f, 0x8e, 0x2b, 0x89, 0xe2, 0x78, 0xc4, 0x81, 0xf5, 0xd4, 0xb3, 0x4a,
        0x87, 0xb8, 0x07, 0xa1, 0xf5, 0xa8, 0x81, 0x06, 0x7c, 0x7d, 0x78, 0x85, 0x6a, 0xd6, 0x00, 0x34,
        0x5a, 0x72, 0x87, 0xaa, 0xe5, 0x07, 0x8e, 0xca, 0x48, 0x8b, 0xc2, 0x74, 0x9e, 0xb0, 0xff, 0x65,
        0x8b, 0xee, 0xbd, 0x75, 0xa6, 0x8b, 0xe0, 0x2e, 0x4a, 0xe8, 0xce, 0xe8, 0x34, 0x26, 0x33, 0x32,
        0xbf, 0x5f, 0x6c, 0x70, 0xf4, 0x86, 0xee, 0x22, 0xa0, 0xd0, 0x25, 0xc2, 0x42, 0xb6, 0x36, 0xde,
        0x1a, 0xfa, 0xf9, 0xe1, 0xd5, 0x4d, 0x36, 0xf9, 0x75, 0x93, 0x3d, 0xf6, 0x8e, 0xec, 0xd9, 0x82,
        0x29, 0xe0, 0x46, 0xe0, 0x39, 0x3b, 0x69, 0xf1, 0xc7, 0xf7, 0x23, 0x1a, 0xac, 0x9e, 0xb4, 0x58,
        0x4c, 0xdd, 0x80, 0x53, 0xa7, 0x8f, 0x72, 0x4a, 0x6b, 0x30, 0x46, 0x59, 0xab, 0xa0, 0x8d, 0xef,
        0xcc, 0xc8, 0x7c, 0xfa, 0x7c, 0x9f, 0x05, 0xf6, 0xb8, 0x7b, 0xc8, 0x82, 0xbd, 0xdc, 0x30, 0x8b,
        0x5b, 0xaa, 0xe8, 0x09, 0xdd, 0xfe, 0x28, 0x94, 0x96, 0x67, 0xf1, 0xdd, 0x19, 0x99, 0xef, 0x14,
        0x01, 0x45, 0xaf, 0xe9, 0xae, 0x7f, 0x95, 0xcb, 0x16, 0x95, 0x8e, 0xef, 0xb9, 0xe9, 0x09, 0xf3,
        0x91, 0xb0, 0x31, 0x12, 0x76, 0x3a, 0x46, 0x92, 0x3f, 0x18, 0xf6, 0xb8, 0xfc, 0x9d, 0x91, 0xaf,
        0x7f, 0xbf, 0x3d, 0x23, 0xc5, 0xd4, 0xcb, 0xdf, 0x0d, 0xea, 0xfc, 0xd5, 0xd5, 0x2a, 0x25, 0xd7,
        0xab, 0x94, 0xfc, 0x59, 0xa5, 0xe4, 0x72, 0x9d, 0x4e, 0xae, 0xd7, 0xe9, 0xe4, 0xe7, 0x3a, 0x9d,
        0xbc, 0x3f, 0x6c, 0x14, 0x9e, 0x2f, 0x2b, 0x56, 0x83, 0xe1, 0x28, 0xb5, 0x86, 0xfe, 0x48, 0x01,
        0xf7, 0x87, 0xf1, 0xf9, 0xff, 0x69, 0xe0, 0x45, 0x27, 0x6d, 0xb5, 0xed, 0x7e, 0xfb, 0xe2, 0x5f,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x3e, 0x50, 0x72, 0x0b, 0x39, 0x02, 0x00, 0x00,
}

func (m *OracleReporter) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *OracleReporter) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *OracleReporter) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.JailedUntil, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.JailedUntil):])
        if err1 != nil </span><span class="cov0" title="0">{
                return 0, err1
        }</span>
        <span class="cov0" title="0">i -= n1
        i = encodeVarintOracleReporter(dAtA, i, uint64(n1))
        i--
        dAtA[i] = 0x2a
        if m.Jailed </span><span class="cov0" title="0">{
                i--
                if m.Jailed </span><span class="cov0" title="0">{
                        dAtA[i] = 1
                }</span> else<span class="cov0" title="0"> {
                        dAtA[i] = 0
                }</span>
                <span class="cov0" title="0">i--
                dAtA[i] = 0x20</span>
        }
        <span class="cov0" title="0">if m.Commission != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Commission.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintOracleReporter(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0x1a</span>
        }
        <span class="cov0" title="0">{
                size := m.TotalTokens.Size()
                i -= size
                if _, err := m.TotalTokens.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintOracleReporter(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x12
        if len(m.Reporter) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Reporter)
                copy(dAtA[i:], m.Reporter)
                i = encodeVarintOracleReporter(dAtA, i, uint64(len(m.Reporter)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintOracleReporter(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovOracleReporter(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *OracleReporter) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Reporter)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovOracleReporter(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.TotalTokens.Size()
        n += 1 + l + sovOracleReporter(uint64(l))
        if m.Commission != nil </span><span class="cov0" title="0">{
                l = m.Commission.Size()
                n += 1 + l + sovOracleReporter(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Jailed </span><span class="cov0" title="0">{
                n += 2
        }</span>
        <span class="cov0" title="0">l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.JailedUntil)
        n += 1 + l + sovOracleReporter(uint64(l))
        return n</span>
}

func sovOracleReporter(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozOracleReporter(x uint64) (n int) <span class="cov0" title="0">{
        return sovOracleReporter(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *OracleReporter) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowOracleReporter
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: OracleReporter: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: OracleReporter: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowOracleReporter
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthOracleReporter
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthOracleReporter
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Reporter = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field TotalTokens", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowOracleReporter
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthOracleReporter
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthOracleReporter
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.TotalTokens.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowOracleReporter
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthOracleReporter
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthOracleReporter
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Commission == nil </span><span class="cov0" title="0">{
                                m.Commission = &amp;types.Commission{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Commission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Jailed", wireType)
                        }</span>
                        <span class="cov0" title="0">var v int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowOracleReporter
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                v |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">m.Jailed = bool(v != 0)</span>
                case 5:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field JailedUntil", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowOracleReporter
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthOracleReporter
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthOracleReporter
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&amp;m.JailedUntil, dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipOracleReporter(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthOracleReporter
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipOracleReporter(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowOracleReporter
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowOracleReporter
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowOracleReporter
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthOracleReporter
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupOracleReporter
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthOracleReporter
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthOracleReporter        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowOracleReporter          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupOracleReporter = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file196" style="display: none">package types

import (
        "fmt"

        "cosmossdk.io/math"
        paramtypes "github.com/cosmos/cosmos-sdk/x/params/types"
)

var _ paramtypes.ParamSet = (*Params)(nil)

var (
        KeyMinCommissionRate = []byte("MinCommissionRate")
        // TODO: Determine the default value
        DefaultMinCommissionRate = math.LegacyZeroDec()
)

// ParamKeyTable the param key table for launch module
func ParamKeyTable() paramtypes.KeyTable <span class="cov0" title="0">{
        return paramtypes.NewKeyTable().RegisterParamSet(&amp;Params{})
}</span>

// NewParams creates a new Params instance
func NewParams(
        minCommissionRate math.LegacyDec,
) Params <span class="cov8" title="1">{
        return Params{
                MinCommissionRate: minCommissionRate,
        }
}</span>

// DefaultParams returns a default set of parameters
func DefaultParams() Params <span class="cov8" title="1">{
        return NewParams(
                DefaultMinCommissionRate,
        )
}</span>

// ParamSetPairs get the params.ParamSet
func (p *Params) ParamSetPairs() paramtypes.ParamSetPairs <span class="cov0" title="0">{
        return paramtypes.ParamSetPairs{
                paramtypes.NewParamSetPair(KeyMinCommissionRate, &amp;p.MinCommissionRate, validateMinCommissionRate),
        }
}</span>

// Validate validates the set of params
func (p Params) Validate() error <span class="cov8" title="1">{
        if err := validateMinCommissionRate(p.MinCommissionRate); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateMinStakeAmount validates the MinStakeAmount param
func validateMinCommissionRate(v interface{}) error <span class="cov8" title="1">{
        minCommissionRate, ok := v.(math.LegacyDec)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid parameter type: %T", v)
        }</span>

        // TODO implement validation
        <span class="cov8" title="1">_ = minCommissionRate

        return nil</span>
}
</pre>
		
		<pre class="file" id="file197" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/reporter/params.proto

package types

import (
        cosmossdk_io_math "cosmossdk.io/math"
        fmt "fmt"
        _ "github.com/cosmos/cosmos-proto"
        _ "github.com/cosmos/cosmos-sdk/types/tx/amino"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines the parameters for the module.
type Params struct {
        // min_commission_rate, adopted from staking module, is the minimum commission rate a reporter can their delegators
        MinCommissionRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,1,opt,name=min_commission_rate,json=minCommissionRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_commission_rate" yaml:"min_commission_rate"`
}

func (m *Params) Reset()         <span class="cov0" title="0">{ *m = Params{} }</span>
func (m *Params) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Params) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Params) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_2b46dabd827272cb, []int{0}
}</span>
func (m *Params) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Params.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Params) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Params.Merge(m, src)
}</span>
func (m *Params) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Params) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Params.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Params proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Params)(nil), "layer.reporter.Params")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/reporter/params.proto", fileDescriptor_2b46dabd827272cb) }</span>

var fileDescriptor_2b46dabd827272cb = []byte{
        // 292 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0xce, 0x49, 0xac, 0x4c,
        0x2d, 0xd2, 0x2f, 0x4a, 0x2d, 0xc8, 0x2f, 0x2a, 0x49, 0x2d, 0xd2, 0x2f, 0x48, 0x2c, 0x4a, 0xcc,
        0x2d, 0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x03, 0x4b, 0xea, 0xc1, 0x24, 0xa5, 0x04,
        0x13, 0x73, 0x33, 0xf3, 0xf2, 0xf5, 0xc1, 0x24, 0x44, 0x89, 0x94, 0x64, 0x72, 0x7e, 0x71, 0x6e,
        0x7e, 0x71, 0x3c, 0x98, 0xa7, 0x0f, 0xe1, 0x40, 0xa5, 0x44, 0xd2, 0xf3, 0xd3, 0xf3, 0x21, 0xe2,
        0x20, 0x16, 0x44, 0x54, 0x69, 0x23, 0x23, 0x17, 0x5b, 0x00, 0xd8, 0x12, 0xa1, 0x16, 0x46, 0x2e,
        0xe1, 0xdc, 0xcc, 0xbc, 0xf8, 0xe4, 0xfc, 0xdc, 0xdc, 0xcc, 0xe2, 0xe2, 0xcc, 0xfc, 0xbc, 0xf8,
        0xa2, 0xc4, 0x92, 0x54, 0x09, 0x46, 0x05, 0x46, 0x0d, 0x4e, 0xa7, 0x90, 0x13, 0xf7, 0xe4, 0x19,
        0x6e, 0xdd, 0x93, 0x97, 0x86, 0x18, 0x5a, 0x9c, 0x92, 0xad, 0x97, 0x99, 0xaf, 0x9f, 0x9b, 0x58,
        0x92, 0xa1, 0xe7, 0x93, 0x9a, 0x9e, 0x98, 0x5c, 0xe9, 0x92, 0x9a, 0xfc, 0xe9, 0x9e, 0xbc, 0x54,
        0x65, 0x62, 0x6e, 0x8e, 0x95, 0x12, 0x16, 0x73, 0x94, 0x2e, 0x6d, 0xd1, 0xe5, 0x82, 0xba, 0xc8,
        0x25, 0x35, 0x79, 0xc5, 0xf3, 0x0d, 0x5a, 0x8c, 0x41, 0x82, 0xb9, 0x99, 0x79, 0xce, 0x70, 0x75,
        0x41, 0x89, 0x25, 0xa9, 0x56, 0x0a, 0x2f, 0x16, 0xc8, 0x33, 0x76, 0x3d, 0xdf, 0xa0, 0x25, 0x0e,
        0x09, 0x8b, 0x0a, 0x44, 0x68, 0x40, 0x1c, 0xea, 0xe4, 0x7a, 0xe2, 0x91, 0x1c, 0xe3, 0x85, 0x47,
        0x72, 0x8c, 0x0f, 0x1e, 0xc9, 0x31, 0x4e, 0x78, 0x2c, 0xc7, 0x70, 0xe1, 0xb1, 0x1c, 0xc3, 0x8d,
        0xc7, 0x72, 0x0c, 0x51, 0xda, 0xe9, 0x99, 0x25, 0x19, 0xa5, 0x49, 0x7a, 0xc9, 0xf9, 0xb9, 0xfa,
        0x25, 0xa9, 0x39, 0x39, 0xf9, 0x45, 0xba, 0x99, 0xf9, 0xfa, 0x18, 0xe6, 0x94, 0x54, 0x16, 0xa4,
        0x16, 0x27, 0xb1, 0x81, 0x43, 0xc0, 0x18, 0x10, 0x00, 0x00, 0xff, 0xff, 0x7f, 0x99, 0x02, 0xe4,
        0x74, 0x01, 0x00, 0x00,
}

func (this *Params) Equal(that interface{}) bool <span class="cov0" title="0">{
        if that == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span>

        <span class="cov0" title="0">that1, ok := that.(*Params)
        if !ok </span><span class="cov0" title="0">{
                that2, ok := that.(Params)
                if ok </span><span class="cov0" title="0">{
                        that1 = &amp;that2
                }</span> else<span class="cov0" title="0"> {
                        return false
                }</span>
        }
        <span class="cov0" title="0">if that1 == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span> else<span class="cov0" title="0"> if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if !this.MinCommissionRate.Equal(that1.MinCommissionRate) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}
func (m *Params) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size := m.MinCommissionRate.Size()
                i -= size
                if _, err := m.MinCommissionRate.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintParams(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func encodeVarintParams(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovParams(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Params) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.MinCommissionRate.Size()
        n += 1 + l + sovParams(uint64(l))
        return n</span>
}

func sovParams(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozParams(x uint64) (n int) <span class="cov0" title="0">{
        return sovParams(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Params) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Params: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MinCommissionRate", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.MinCommissionRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipParams(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipParams(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupParams
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthParams
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthParams        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowParams          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupParams = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file198" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/reporter/query.proto

package types

import (
        context "context"
        cosmossdk_io_math "cosmossdk.io/math"
        fmt "fmt"
        _ "github.com/cosmos/cosmos-proto"
        github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
        types "github.com/cosmos/cosmos-sdk/types"
        _ "github.com/cosmos/cosmos-sdk/types/query"
        _ "github.com/cosmos/cosmos-sdk/types/tx/amino"
        _ "github.com/cosmos/gogoproto/gogoproto"
        grpc1 "github.com/cosmos/gogoproto/grpc"
        proto "github.com/cosmos/gogoproto/proto"
        _ "google.golang.org/genproto/googleapis/api/annotations"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QueryParamsRequest is request type for the Query/Params RPC method.
type QueryParamsRequest struct {
}

func (m *QueryParamsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryParamsRequest{} }</span>
func (m *QueryParamsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryParamsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryParamsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_a043abc58a7b99a9, []int{0}
}</span>
func (m *QueryParamsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryParamsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryParamsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsRequest.Merge(m, src)
}</span>
func (m *QueryParamsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryParamsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryParamsRequest proto.InternalMessageInfo

// QueryParamsResponse is response type for the Query/Params RPC method.
type QueryParamsResponse struct {
        // params holds all the parameters of this module.
        Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
}

func (m *QueryParamsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryParamsResponse{} }</span>
func (m *QueryParamsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryParamsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryParamsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_a043abc58a7b99a9, []int{1}
}</span>
func (m *QueryParamsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryParamsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryParamsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsResponse.Merge(m, src)
}</span>
func (m *QueryParamsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryParamsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryParamsResponse proto.InternalMessageInfo

func (m *QueryParamsResponse) GetParams() Params <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Params
        }</span>
        <span class="cov0" title="0">return Params{}</span>
}

// QueryReporterRequest is the request type for the Query/Reporter RPC method.
type QueryReporterRequest struct {
        // reporter_address defines the reporter address to query for.
        ReporterAddress string `protobuf:"bytes,1,opt,name=reporter_address,json=reporterAddress,proto3" json:"reporter_address,omitempty"`
}

func (m *QueryReporterRequest) Reset()         <span class="cov0" title="0">{ *m = QueryReporterRequest{} }</span>
func (m *QueryReporterRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryReporterRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryReporterRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_a043abc58a7b99a9, []int{2}
}</span>
func (m *QueryReporterRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryReporterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryReporterRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryReporterRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryReporterRequest.Merge(m, src)
}</span>
func (m *QueryReporterRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryReporterRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryReporterRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryReporterRequest proto.InternalMessageInfo

func (m *QueryReporterRequest) GetReporterAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ReporterAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// QueryReporterResponse is the response type for the Query/Reporter RPC method.
type QueryReporterResponse struct {
        Reporter *OracleReporter `protobuf:"bytes,1,opt,name=reporter,proto3" json:"reporter,omitempty"`
}

func (m *QueryReporterResponse) Reset()         <span class="cov0" title="0">{ *m = QueryReporterResponse{} }</span>
func (m *QueryReporterResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryReporterResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryReporterResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_a043abc58a7b99a9, []int{3}
}</span>
func (m *QueryReporterResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryReporterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryReporterResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryReporterResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryReporterResponse.Merge(m, src)
}</span>
func (m *QueryReporterResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryReporterResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryReporterResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryReporterResponse proto.InternalMessageInfo

func (m *QueryReporterResponse) GetReporter() *OracleReporter <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Reporter
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// QueryReportersRequest is the request type for the Query/Reporters RPC method.
type QueryReportersRequest struct {
}

func (m *QueryReportersRequest) Reset()         <span class="cov0" title="0">{ *m = QueryReportersRequest{} }</span>
func (m *QueryReportersRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryReportersRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryReportersRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_a043abc58a7b99a9, []int{4}
}</span>
func (m *QueryReportersRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryReportersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryReportersRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryReportersRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryReportersRequest.Merge(m, src)
}</span>
func (m *QueryReportersRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryReportersRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryReportersRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryReportersRequest proto.InternalMessageInfo

// QueryReportersResponse is the response type for the Query/Reporters RPC method.
type QueryReportersResponse struct {
        // all the reporters.
        Reporters []*OracleReporter `protobuf:"bytes,1,rep,name=reporters,proto3" json:"reporters,omitempty"`
}

func (m *QueryReportersResponse) Reset()         <span class="cov0" title="0">{ *m = QueryReportersResponse{} }</span>
func (m *QueryReportersResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryReportersResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryReportersResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_a043abc58a7b99a9, []int{5}
}</span>
func (m *QueryReportersResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryReportersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryReportersResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryReportersResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryReportersResponse.Merge(m, src)
}</span>
func (m *QueryReportersResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryReportersResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryReportersResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryReportersResponse proto.InternalMessageInfo

func (m *QueryReportersResponse) GetReporters() []*OracleReporter <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Reporters
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// QueryDelegatorReporterRequest is the request type for the
// Query/DelegatorReporter RPC method.
type QueryDelegatorReporterRequest struct {
        // delegator_address defines the delegator address to query for.
        DelegatorAddress string `protobuf:"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3" json:"delegator_address,omitempty"`
}

func (m *QueryDelegatorReporterRequest) Reset()         <span class="cov0" title="0">{ *m = QueryDelegatorReporterRequest{} }</span>
func (m *QueryDelegatorReporterRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryDelegatorReporterRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryDelegatorReporterRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_a043abc58a7b99a9, []int{6}
}</span>
func (m *QueryDelegatorReporterRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryDelegatorReporterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryDelegatorReporterRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryDelegatorReporterRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryDelegatorReporterRequest.Merge(m, src)
}</span>
func (m *QueryDelegatorReporterRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryDelegatorReporterRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryDelegatorReporterRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryDelegatorReporterRequest proto.InternalMessageInfo

// QueryDelegatorReporterResponse is the response type for the
// Query/DelegatorReporter RPC method.
type QueryDelegatorReporterResponse struct {
        // reporter defines the reporter of a delegator.
        Reporter string `protobuf:"bytes,1,opt,name=reporter,proto3" json:"reporter,omitempty"`
}

func (m *QueryDelegatorReporterResponse) Reset()         <span class="cov0" title="0">{ *m = QueryDelegatorReporterResponse{} }</span>
func (m *QueryDelegatorReporterResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryDelegatorReporterResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryDelegatorReporterResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_a043abc58a7b99a9, []int{7}
}</span>
func (m *QueryDelegatorReporterResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryDelegatorReporterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryDelegatorReporterResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryDelegatorReporterResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryDelegatorReporterResponse.Merge(m, src)
}</span>
func (m *QueryDelegatorReporterResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryDelegatorReporterResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryDelegatorReporterResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryDelegatorReporterResponse proto.InternalMessageInfo

func (m *QueryDelegatorReporterResponse) GetReporter() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Reporter
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// QueryReporterStakeRequest is the request type for the
// Query/ReporterStake RPC method.
type QueryReporterStakeRequest struct {
        // reporter_address defines the reporter address to query for.
        ReporterAddress string `protobuf:"bytes,1,opt,name=reporter_address,json=reporterAddress,proto3" json:"reporter_address,omitempty"`
}

func (m *QueryReporterStakeRequest) Reset()         <span class="cov0" title="0">{ *m = QueryReporterStakeRequest{} }</span>
func (m *QueryReporterStakeRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryReporterStakeRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryReporterStakeRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_a043abc58a7b99a9, []int{8}
}</span>
func (m *QueryReporterStakeRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryReporterStakeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryReporterStakeRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryReporterStakeRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryReporterStakeRequest.Merge(m, src)
}</span>
func (m *QueryReporterStakeRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryReporterStakeRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryReporterStakeRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryReporterStakeRequest proto.InternalMessageInfo

// QueryReporterStakeResponse is the response type for the
// Query/ReporterStake RPC method.
type QueryReporterStakeResponse struct {
        // stake defines the total tokens of a reporter.
        Stake cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=stake,proto3,customtype=cosmossdk.io/math.Int" json:"stake"`
}

func (m *QueryReporterStakeResponse) Reset()         <span class="cov0" title="0">{ *m = QueryReporterStakeResponse{} }</span>
func (m *QueryReporterStakeResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryReporterStakeResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryReporterStakeResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_a043abc58a7b99a9, []int{9}
}</span>
func (m *QueryReporterStakeResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryReporterStakeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryReporterStakeResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryReporterStakeResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryReporterStakeResponse.Merge(m, src)
}</span>
func (m *QueryReporterStakeResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryReporterStakeResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryReporterStakeResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryReporterStakeResponse proto.InternalMessageInfo

// QueryDelegationRewardsRequest is the request type for the
// Query/DelegationRewards RPC method.
type QueryDelegationRewardsRequest struct {
        // delegator_address defines the delegator address to query for.
        DelegatorAddress string `protobuf:"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3" json:"delegator_address,omitempty"`
        // reporter_address defines the reporter address to query for.
        ReporterAddress string `protobuf:"bytes,2,opt,name=reporter_address,json=reporterAddress,proto3" json:"reporter_address,omitempty"`
}

func (m *QueryDelegationRewardsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryDelegationRewardsRequest{} }</span>
func (m *QueryDelegationRewardsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryDelegationRewardsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryDelegationRewardsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_a043abc58a7b99a9, []int{10}
}</span>
func (m *QueryDelegationRewardsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryDelegationRewardsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryDelegationRewardsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryDelegationRewardsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryDelegationRewardsRequest.Merge(m, src)
}</span>
func (m *QueryDelegationRewardsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryDelegationRewardsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryDelegationRewardsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryDelegationRewardsRequest proto.InternalMessageInfo

// QueryDelegationRewardsResponse is the response type for the
// Query/DelegationRewards RPC method.
type QueryDelegationRewardsResponse struct {
        // rewards defines the rewards accrued by a delegation.
        Rewards github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,1,rep,name=rewards,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"rewards"`
}

func (m *QueryDelegationRewardsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryDelegationRewardsResponse{} }</span>
func (m *QueryDelegationRewardsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryDelegationRewardsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryDelegationRewardsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_a043abc58a7b99a9, []int{11}
}</span>
func (m *QueryDelegationRewardsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryDelegationRewardsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryDelegationRewardsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryDelegationRewardsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryDelegationRewardsResponse.Merge(m, src)
}</span>
func (m *QueryDelegationRewardsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryDelegationRewardsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryDelegationRewardsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryDelegationRewardsResponse proto.InternalMessageInfo

func (m *QueryDelegationRewardsResponse) GetRewards() github_com_cosmos_cosmos_sdk_types.DecCoins <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Rewards
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// QueryReporterOutstandingRewardsRequest is the request type for the
// Query/ReporterOutstandingRewards RPC method.
type QueryReporterOutstandingRewardsRequest struct {
        // reporter_address defines the reporter address to query for.
        ReporterAddress string `protobuf:"bytes,1,opt,name=reporter_address,json=reporterAddress,proto3" json:"reporter_address,omitempty"`
}

func (m *QueryReporterOutstandingRewardsRequest) Reset() <span class="cov0" title="0">{
        *m = QueryReporterOutstandingRewardsRequest{}
}</span>
func (m *QueryReporterOutstandingRewardsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryReporterOutstandingRewardsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryReporterOutstandingRewardsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_a043abc58a7b99a9, []int{12}
}</span>
func (m *QueryReporterOutstandingRewardsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryReporterOutstandingRewardsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryReporterOutstandingRewardsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryReporterOutstandingRewardsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryReporterOutstandingRewardsRequest.Merge(m, src)
}</span>
func (m *QueryReporterOutstandingRewardsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryReporterOutstandingRewardsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryReporterOutstandingRewardsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryReporterOutstandingRewardsRequest proto.InternalMessageInfo

func (m *QueryReporterOutstandingRewardsRequest) GetReporterAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ReporterAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// QueryReporterOutstandingRewardsResponse is the response type for the
// Query/ReporterOutstandingRewards RPC method.
type QueryReporterOutstandingRewardsResponse struct {
        Rewards ReporterOutstandingRewards `protobuf:"bytes,1,opt,name=rewards,proto3" json:"rewards"`
}

func (m *QueryReporterOutstandingRewardsResponse) Reset() <span class="cov0" title="0">{
        *m = QueryReporterOutstandingRewardsResponse{}
}</span>
func (m *QueryReporterOutstandingRewardsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryReporterOutstandingRewardsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryReporterOutstandingRewardsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_a043abc58a7b99a9, []int{13}
}</span>
func (m *QueryReporterOutstandingRewardsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryReporterOutstandingRewardsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryReporterOutstandingRewardsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryReporterOutstandingRewardsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryReporterOutstandingRewardsResponse.Merge(m, src)
}</span>
func (m *QueryReporterOutstandingRewardsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryReporterOutstandingRewardsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryReporterOutstandingRewardsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryReporterOutstandingRewardsResponse proto.InternalMessageInfo

func (m *QueryReporterOutstandingRewardsResponse) GetRewards() ReporterOutstandingRewards <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Rewards
        }</span>
        <span class="cov0" title="0">return ReporterOutstandingRewards{}</span>
}

// QueryReporterCommissionRequest is the request type for the
// Query/ReporterCommission RPC method
type QueryReporterCommissionRequest struct {
        // reporter_address defines the reporter address to query for.
        ReporterAddress string `protobuf:"bytes,1,opt,name=reporter_address,json=reporterAddress,proto3" json:"reporter_address,omitempty"`
}

func (m *QueryReporterCommissionRequest) Reset()         <span class="cov0" title="0">{ *m = QueryReporterCommissionRequest{} }</span>
func (m *QueryReporterCommissionRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryReporterCommissionRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryReporterCommissionRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_a043abc58a7b99a9, []int{14}
}</span>
func (m *QueryReporterCommissionRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryReporterCommissionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryReporterCommissionRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryReporterCommissionRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryReporterCommissionRequest.Merge(m, src)
}</span>
func (m *QueryReporterCommissionRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryReporterCommissionRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryReporterCommissionRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryReporterCommissionRequest proto.InternalMessageInfo

func (m *QueryReporterCommissionRequest) GetReporterAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ReporterAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// QueryReporterCommissionResponse is the response type for the
// Query/ReporterCommission RPC method
type QueryReporterCommissionResponse struct {
        // commission defines the commission the reporter received.
        Commission ReporterAccumulatedCommission `protobuf:"bytes,1,opt,name=commission,proto3" json:"commission"`
}

func (m *QueryReporterCommissionResponse) Reset()         <span class="cov0" title="0">{ *m = QueryReporterCommissionResponse{} }</span>
func (m *QueryReporterCommissionResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryReporterCommissionResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryReporterCommissionResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_a043abc58a7b99a9, []int{15}
}</span>
func (m *QueryReporterCommissionResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryReporterCommissionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryReporterCommissionResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryReporterCommissionResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryReporterCommissionResponse.Merge(m, src)
}</span>
func (m *QueryReporterCommissionResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryReporterCommissionResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryReporterCommissionResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryReporterCommissionResponse proto.InternalMessageInfo

func (m *QueryReporterCommissionResponse) GetCommission() ReporterAccumulatedCommission <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Commission
        }</span>
        <span class="cov0" title="0">return ReporterAccumulatedCommission{}</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*QueryParamsRequest)(nil), "layer.reporter.QueryParamsRequest")
        proto.RegisterType((*QueryParamsResponse)(nil), "layer.reporter.QueryParamsResponse")
        proto.RegisterType((*QueryReporterRequest)(nil), "layer.reporter.QueryReporterRequest")
        proto.RegisterType((*QueryReporterResponse)(nil), "layer.reporter.QueryReporterResponse")
        proto.RegisterType((*QueryReportersRequest)(nil), "layer.reporter.QueryReportersRequest")
        proto.RegisterType((*QueryReportersResponse)(nil), "layer.reporter.QueryReportersResponse")
        proto.RegisterType((*QueryDelegatorReporterRequest)(nil), "layer.reporter.QueryDelegatorReporterRequest")
        proto.RegisterType((*QueryDelegatorReporterResponse)(nil), "layer.reporter.QueryDelegatorReporterResponse")
        proto.RegisterType((*QueryReporterStakeRequest)(nil), "layer.reporter.QueryReporterStakeRequest")
        proto.RegisterType((*QueryReporterStakeResponse)(nil), "layer.reporter.QueryReporterStakeResponse")
        proto.RegisterType((*QueryDelegationRewardsRequest)(nil), "layer.reporter.QueryDelegationRewardsRequest")
        proto.RegisterType((*QueryDelegationRewardsResponse)(nil), "layer.reporter.QueryDelegationRewardsResponse")
        proto.RegisterType((*QueryReporterOutstandingRewardsRequest)(nil), "layer.reporter.QueryReporterOutstandingRewardsRequest")
        proto.RegisterType((*QueryReporterOutstandingRewardsResponse)(nil), "layer.reporter.QueryReporterOutstandingRewardsResponse")
        proto.RegisterType((*QueryReporterCommissionRequest)(nil), "layer.reporter.QueryReporterCommissionRequest")
        proto.RegisterType((*QueryReporterCommissionResponse)(nil), "layer.reporter.QueryReporterCommissionResponse")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/reporter/query.proto", fileDescriptor_a043abc58a7b99a9) }</span>

var fileDescriptor_a043abc58a7b99a9 = []byte{
        // 985 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x4d, 0x6f, 0xdc, 0x44,
        0x18, 0x5e, 0x17, 0x35, 0x24, 0x2f, 0x02, 0x9a, 0x21, 0x2d, 0xad, 0x29, 0xde, 0xe2, 0x7e, 0x50,
        0x12, 0x6c, 0xab, 0xa5, 0xa2, 0xb4, 0x80, 0x20, 0x9b, 0x56, 0xa2, 0xa7, 0x94, 0x8d, 0xa8, 0x10,
        0x3d, 0x44, 0xb3, 0xeb, 0xd1, 0xd6, 0x64, 0xed, 0x71, 0x3d, 0xb3, 0x40, 0x88, 0x7a, 0xe1, 0x02,
        0x17, 0x24, 0x04, 0x7f, 0xa0, 0x47, 0x04, 0x17, 0x0e, 0x85, 0x13, 0x3f, 0xa0, 0x37, 0xaa, 0x72,
        0x00, 0x71, 0x08, 0x28, 0x41, 0x82, 0x23, 0x3f, 0x01, 0x79, 0xfc, 0xfa, 0x63, 0xbd, 0xf6, 0xee,
        0x82, 0xf6, 0x92, 0xac, 0xdf, 0x79, 0x3f, 0x9e, 0xe7, 0x19, 0xef, 0xf3, 0x2e, 0xe8, 0x7d, 0xba,
        0xcd, 0x22, 0x27, 0x62, 0x21, 0x8f, 0x24, 0x8b, 0x9c, 0xdb, 0x03, 0x16, 0x6d, 0xdb, 0x61, 0xc4,
        0x25, 0x27, 0x4f, 0xa8, 0x33, 0x3b, 0x3d, 0xd3, 0x17, 0xa9, 0xef, 0x05, 0xdc, 0x51, 0x7f, 0x93,
        0x14, 0x7d, 0xb9, 0xcb, 0x85, 0xcf, 0x85, 0xd3, 0xa1, 0x82, 0x25, 0xb5, 0xce, 0x07, 0xe7, 0x3a,
        0x4c, 0xd2, 0x73, 0x4e, 0x48, 0x7b, 0x5e, 0x40, 0xa5, 0xc7, 0x03, 0xcc, 0x35, 0x8a, 0xb9, 0x69,
        0x56, 0x97, 0x7b, 0xe9, 0xf9, 0xb1, 0xe4, 0x7c, 0x53, 0x3d, 0x39, 0xc9, 0x03, 0x1e, 0x2d, 0xf5,
        0x78, 0x8f, 0x27, 0xf1, 0xf8, 0x13, 0x46, 0x8f, 0xf7, 0x38, 0xef, 0xf5, 0x99, 0x43, 0x43, 0xcf,
        0xa1, 0x41, 0xc0, 0xa5, 0x9a, 0x96, 0xd6, 0x3c, 0x57, 0x62, 0xe6, 0x7a, 0x42, 0x46, 0x5e, 0x67,
        0x50, 0x40, 0x74, 0xaa, 0x94, 0xc2, 0x23, 0xda, 0xed, 0xb3, 0xcd, 0xf4, 0x19, 0xb3, 0x9e, 0x29,
        0x65, 0x85, 0x34, 0xa2, 0x3e, 0x4e, 0x31, 0x97, 0x80, 0xbc, 0x1d, 0xd3, 0xbe, 0xae, 0x82, 0x6d,
        0x76, 0x7b, 0xc0, 0x84, 0x34, 0xaf, 0xc3, 0x53, 0x43, 0x51, 0x11, 0xf2, 0x40, 0x30, 0x72, 0x09,
        0xe6, 0x92, 0xe2, 0xa3, 0xda, 0x09, 0xed, 0xec, 0x63, 0xe7, 0x8f, 0xd8, 0xc3, 0x0a, 0xdb, 0x49,
        0x7e, 0x6b, 0xe1, 0xfe, 0x6e, 0xb3, 0xf1, 0xf5, 0x5f, 0xdf, 0x2d, 0x6b, 0x6d, 0x2c, 0x30, 0x6f,
        0xc2, 0x92, 0xea, 0xd8, 0xc6, 0x54, 0x9c, 0x44, 0xd6, 0xe0, 0x50, 0x5a, 0xbd, 0x49, 0x5d, 0x37,
        0x62, 0x22, 0x69, 0xbe, 0xd0, 0x3a, 0xfa, 0xf0, 0x9e, 0xb5, 0x84, 0x2a, 0xae, 0x26, 0x27, 0x1b,
        0x32, 0xf2, 0x82, 0x5e, 0xfb, 0xc9, 0xb4, 0x02, 0xc3, 0xe6, 0x06, 0x1c, 0x2e, 0x35, 0x47, 0xc0,
        0x97, 0x61, 0x3e, 0xcd, 0x45, 0xc8, 0x46, 0x19, 0xf2, 0xba, 0xd2, 0x2c, 0xab, 0xcc, 0xf2, 0xcd,
        0xa7, 0x4b, 0x4d, 0x33, 0x71, 0x6e, 0xc0, 0x91, 0xf2, 0x01, 0x8e, 0x7b, 0x0d, 0x16, 0xd2, 0xf2,
        0x98, 0xc5, 0x23, 0x53, 0xcc, 0xcb, 0x0b, 0xcc, 0x10, 0x9e, 0x55, 0x7d, 0xaf, 0xb0, 0x3e, 0xeb,
        0x51, 0xc9, 0xa3, 0xb2, 0x56, 0x57, 0x61, 0xd1, 0x4d, 0xcf, 0xa6, 0x16, 0xeb, 0x50, 0x56, 0x82,
        0xf1, 0xcb, 0xf3, 0x9f, 0xdd, 0x6d, 0x36, 0xfe, 0xbe, 0xdb, 0x6c, 0x98, 0x37, 0xc0, 0xa8, 0x9b,
        0x88, 0x8c, 0x2e, 0x94, 0x04, 0x1c, 0x37, 0x29, 0x97, 0xee, 0x7d, 0x38, 0x36, 0xa4, 0xd0, 0x86,
        0xa4, 0x5b, 0x6c, 0x96, 0x37, 0x5e, 0xe0, 0xb0, 0x09, 0x7a, 0xd5, 0x2c, 0xc4, 0xbf, 0x0a, 0x07,
        0x45, 0x1c, 0xc0, 0x09, 0x2b, 0xf1, 0x8b, 0xf9, 0xdb, 0x6e, 0xf3, 0x70, 0x32, 0x45, 0xb8, 0x5b,
        0xb6, 0xc7, 0x1d, 0x9f, 0xca, 0x5b, 0xf6, 0xb5, 0x40, 0x3e, 0xbc, 0x67, 0x01, 0x8e, 0xbf, 0x16,
        0xc8, 0x76, 0x52, 0x69, 0x7e, 0xaf, 0x0d, 0xdf, 0x8b, 0xc7, 0x83, 0x36, 0xfb, 0x90, 0x46, 0xae,
        0x98, 0xed, 0xbd, 0x54, 0x0a, 0x73, 0xe0, 0xff, 0x0b, 0xf3, 0xa5, 0x36, 0x7c, 0xbb, 0x45, 0xdc,
        0xa8, 0x4e, 0x08, 0x8f, 0x46, 0x49, 0x08, 0xdf, 0xd6, 0xe3, 0x36, 0x4e, 0x89, 0x3d, 0xce, 0x46,
        0x8f, 0xb3, 0xaf, 0xb0, 0xee, 0x1a, 0xf7, 0x82, 0xd6, 0x2b, 0xb1, 0x7a, 0xdf, 0xfc, 0xde, 0x5c,
        0xe9, 0x79, 0xf2, 0xd6, 0xa0, 0x63, 0x77, 0xb9, 0x8f, 0x36, 0x87, 0xff, 0x2c, 0xe1, 0x6e, 0x39,
        0x72, 0x3b, 0x64, 0x22, 0xad, 0x11, 0x89, 0x0b, 0xa4, 0x63, 0x4c, 0x1f, 0xce, 0x0c, 0xdd, 0xd6,
        0xfa, 0x40, 0x0a, 0x49, 0x03, 0x37, 0xe6, 0x32, 0x2c, 0xea, 0x4c, 0x8c, 0xe1, 0x63, 0x78, 0x7e,
        0xe2, 0x38, 0xd4, 0x62, 0xbd, 0xa8, 0x45, 0xec, 0x14, 0xcb, 0xe5, 0x6f, 0x6e, 0x7d, 0x93, 0xa2,
        0xe1, 0x65, 0x54, 0x19, 0xca, 0x9f, 0x96, 0xad, 0x71, 0xdf, 0xf7, 0x84, 0x50, 0xd7, 0x30, 0x43,
        0x8a, 0x3b, 0xd0, 0xac, 0x1d, 0x83, 0xd4, 0xde, 0x05, 0xe8, 0x66, 0x51, 0x64, 0x67, 0xd5, 0xb1,
        0x5b, 0xed, 0x76, 0x07, 0xfe, 0xa0, 0x4f, 0x25, 0x73, 0xf3, 0x56, 0x45, 0x82, 0x85, 0x5e, 0xe7,
        0xff, 0x01, 0x38, 0xa8, 0xa6, 0x93, 0x1d, 0x98, 0x4b, 0xcc, 0x9f, 0x98, 0xe5, 0xce, 0xa3, 0xfb,
        0x45, 0x3f, 0x39, 0x36, 0x27, 0x81, 0x6d, 0x9e, 0xfd, 0xe4, 0xe7, 0x3f, 0xbf, 0x3a, 0x60, 0x92,
        0x13, 0x8e, 0x64, 0xfd, 0x3e, 0x8f, 0x2c, 0x8f, 0x3b, 0x95, 0xab, 0x8c, 0x7c, 0xae, 0xc1, 0x7c,
        0x8a, 0x9f, 0x9c, 0xaa, 0xec, 0x5d, 0xf2, 0x52, 0xfd, 0xf4, 0x84, 0x2c, 0xc4, 0x70, 0x41, 0x61,
        0xb0, 0xc9, 0x8b, 0xf5, 0x18, 0x76, 0xca, 0x77, 0x78, 0x87, 0x7c, 0xaa, 0xc1, 0x42, 0xb6, 0x1d,
        0xc8, 0xf8, 0x51, 0x99, 0x26, 0x67, 0x26, 0xa5, 0x21, 0xa4, 0x15, 0x05, 0xe9, 0x34, 0x39, 0x59,
        0x0f, 0x29, 0xdb, 0x29, 0xe4, 0x47, 0x0d, 0x16, 0x47, 0xdc, 0x9d, 0x58, 0x95, 0xa3, 0xea, 0xf6,
        0x8e, 0x6e, 0x4f, 0x9b, 0x8e, 0x08, 0xdf, 0x52, 0x08, 0x5b, 0xe4, 0xcd, 0x7a, 0x84, 0x99, 0xf9,
        0x59, 0xb9, 0x8e, 0x23, 0x1e, 0x7a, 0x87, 0x7c, 0xab, 0xc1, 0xe3, 0x43, 0xc6, 0x4e, 0x5e, 0x18,
        0xab, 0x52, 0x71, 0xd1, 0xe8, 0xcb, 0xd3, 0xa4, 0x22, 0xe4, 0x35, 0x05, 0xf9, 0x75, 0xf2, 0xea,
        0x64, 0x51, 0x2d, 0xb5, 0x16, 0xaa, 0xae, 0xfd, 0xa7, 0x5c, 0xec, 0xdc, 0x6c, 0xc7, 0x8b, 0x3d,
        0xb2, 0x4c, 0xc6, 0x8b, 0x3d, 0xea, 0xe1, 0xe6, 0x4d, 0x85, 0xfc, 0x1d, 0xb2, 0x31, 0x51, 0x6c,
        0x8f, 0x07, 0x16, 0x9a, 0x53, 0x95, 0xd8, 0x55, 0x8c, 0x7e, 0xd1, 0x40, 0xaf, 0xb7, 0x3d, 0xf2,
        0xf2, 0x58, 0x85, 0x6b, 0xbd, 0x5d, 0xbf, 0xf8, 0x9f, 0xeb, 0xa6, 0x7f, 0xb3, 0x78, 0x5e, 0x9d,
        0xb3, 0x1d, 0x65, 0xf6, 0x83, 0x06, 0x64, 0xd4, 0x32, 0x89, 0x3d, 0x16, 0xd9, 0x88, 0x85, 0xeb,
        0xce, 0xd4, 0xf9, 0xc8, 0xe0, 0x0d, 0xc5, 0xe0, 0x12, 0xb9, 0x58, 0xcf, 0x20, 0xf7, 0xd7, 0x0a,
        0xe0, 0xad, 0xab, 0xf7, 0xf7, 0x0c, 0xed, 0xc1, 0x9e, 0xa1, 0xfd, 0xb1, 0x67, 0x68, 0x5f, 0xec,
        0x1b, 0x8d, 0x07, 0xfb, 0x46, 0xe3, 0xd7, 0x7d, 0xa3, 0xf1, 0x5e, 0x71, 0x2d, 0x97, 0x9b, 0x7f,
        0x94, 0xb7, 0x57, 0xfb, 0xb9, 0x33, 0xa7, 0x7e, 0xfe, 0xbf, 0xf4, 0x6f, 0x00, 0x00, 0x00, 0xff,
        0xff, 0x74, 0x9f, 0x96, 0x1b, 0x40, 0x0d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
        // Parameters queries the parameters of the module.
        Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error)
        // Reporter queries the reporter of a reporter address.
        Reporter(ctx context.Context, in *QueryReporterRequest, opts ...grpc.CallOption) (*QueryReporterResponse, error)
        // Reporters queries all the staked reporters.
        Reporters(ctx context.Context, in *QueryReportersRequest, opts ...grpc.CallOption) (*QueryReportersResponse, error)
        // DelegatorReporter queries the reporter of a delegator.
        DelegatorReporter(ctx context.Context, in *QueryDelegatorReporterRequest, opts ...grpc.CallOption) (*QueryDelegatorReporterResponse, error)
        // ReporterStake queries the total tokens of a reporter.
        ReporterStake(ctx context.Context, in *QueryReporterStakeRequest, opts ...grpc.CallOption) (*QueryReporterStakeResponse, error)
        // DelegationRewards queries the total rewards accrued by a delegation.
        DelegationRewards(ctx context.Context, in *QueryDelegationRewardsRequest, opts ...grpc.CallOption) (*QueryDelegationRewardsResponse, error)
        // ReporterOutstandingRewards queries rewards of a reporter address.
        ReporterOutstandingRewards(ctx context.Context, in *QueryReporterOutstandingRewardsRequest, opts ...grpc.CallOption) (*QueryReporterOutstandingRewardsResponse, error)
        // ReporterCommission queries accumulated commission for a reporter.
        ReporterCommission(ctx context.Context, in *QueryReporterCommissionRequest, opts ...grpc.CallOption) (*QueryReporterCommissionResponse, error)
}

type queryClient struct {
        cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient <span class="cov0" title="0">{
        return &amp;queryClient{cc}
}</span>

func (c *queryClient) Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error) <span class="cov0" title="0">{
        out := new(QueryParamsResponse)
        err := c.cc.Invoke(ctx, "/layer.reporter.Query/Params", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) Reporter(ctx context.Context, in *QueryReporterRequest, opts ...grpc.CallOption) (*QueryReporterResponse, error) <span class="cov0" title="0">{
        out := new(QueryReporterResponse)
        err := c.cc.Invoke(ctx, "/layer.reporter.Query/Reporter", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) Reporters(ctx context.Context, in *QueryReportersRequest, opts ...grpc.CallOption) (*QueryReportersResponse, error) <span class="cov0" title="0">{
        out := new(QueryReportersResponse)
        err := c.cc.Invoke(ctx, "/layer.reporter.Query/Reporters", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) DelegatorReporter(ctx context.Context, in *QueryDelegatorReporterRequest, opts ...grpc.CallOption) (*QueryDelegatorReporterResponse, error) <span class="cov0" title="0">{
        out := new(QueryDelegatorReporterResponse)
        err := c.cc.Invoke(ctx, "/layer.reporter.Query/DelegatorReporter", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) ReporterStake(ctx context.Context, in *QueryReporterStakeRequest, opts ...grpc.CallOption) (*QueryReporterStakeResponse, error) <span class="cov0" title="0">{
        out := new(QueryReporterStakeResponse)
        err := c.cc.Invoke(ctx, "/layer.reporter.Query/ReporterStake", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) DelegationRewards(ctx context.Context, in *QueryDelegationRewardsRequest, opts ...grpc.CallOption) (*QueryDelegationRewardsResponse, error) <span class="cov0" title="0">{
        out := new(QueryDelegationRewardsResponse)
        err := c.cc.Invoke(ctx, "/layer.reporter.Query/DelegationRewards", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) ReporterOutstandingRewards(ctx context.Context, in *QueryReporterOutstandingRewardsRequest, opts ...grpc.CallOption) (*QueryReporterOutstandingRewardsResponse, error) <span class="cov0" title="0">{
        out := new(QueryReporterOutstandingRewardsResponse)
        err := c.cc.Invoke(ctx, "/layer.reporter.Query/ReporterOutstandingRewards", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) ReporterCommission(ctx context.Context, in *QueryReporterCommissionRequest, opts ...grpc.CallOption) (*QueryReporterCommissionResponse, error) <span class="cov0" title="0">{
        out := new(QueryReporterCommissionResponse)
        err := c.cc.Invoke(ctx, "/layer.reporter.Query/ReporterCommission", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// QueryServer is the server API for Query service.
type QueryServer interface {
        // Parameters queries the parameters of the module.
        Params(context.Context, *QueryParamsRequest) (*QueryParamsResponse, error)
        // Reporter queries the reporter of a reporter address.
        Reporter(context.Context, *QueryReporterRequest) (*QueryReporterResponse, error)
        // Reporters queries all the staked reporters.
        Reporters(context.Context, *QueryReportersRequest) (*QueryReportersResponse, error)
        // DelegatorReporter queries the reporter of a delegator.
        DelegatorReporter(context.Context, *QueryDelegatorReporterRequest) (*QueryDelegatorReporterResponse, error)
        // ReporterStake queries the total tokens of a reporter.
        ReporterStake(context.Context, *QueryReporterStakeRequest) (*QueryReporterStakeResponse, error)
        // DelegationRewards queries the total rewards accrued by a delegation.
        DelegationRewards(context.Context, *QueryDelegationRewardsRequest) (*QueryDelegationRewardsResponse, error)
        // ReporterOutstandingRewards queries rewards of a reporter address.
        ReporterOutstandingRewards(context.Context, *QueryReporterOutstandingRewardsRequest) (*QueryReporterOutstandingRewardsResponse, error)
        // ReporterCommission queries accumulated commission for a reporter.
        ReporterCommission(context.Context, *QueryReporterCommissionRequest) (*QueryReporterCommissionResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) Params(ctx context.Context, req *QueryParamsRequest) (*QueryParamsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Params not implemented")
}</span>
func (*UnimplementedQueryServer) Reporter(ctx context.Context, req *QueryReporterRequest) (*QueryReporterResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Reporter not implemented")
}</span>
func (*UnimplementedQueryServer) Reporters(ctx context.Context, req *QueryReportersRequest) (*QueryReportersResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Reporters not implemented")
}</span>
func (*UnimplementedQueryServer) DelegatorReporter(ctx context.Context, req *QueryDelegatorReporterRequest) (*QueryDelegatorReporterResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DelegatorReporter not implemented")
}</span>
func (*UnimplementedQueryServer) ReporterStake(ctx context.Context, req *QueryReporterStakeRequest) (*QueryReporterStakeResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ReporterStake not implemented")
}</span>
func (*UnimplementedQueryServer) DelegationRewards(ctx context.Context, req *QueryDelegationRewardsRequest) (*QueryDelegationRewardsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DelegationRewards not implemented")
}</span>
func (*UnimplementedQueryServer) ReporterOutstandingRewards(ctx context.Context, req *QueryReporterOutstandingRewardsRequest) (*QueryReporterOutstandingRewardsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ReporterOutstandingRewards not implemented")
}</span>
func (*UnimplementedQueryServer) ReporterCommission(ctx context.Context, req *QueryReporterCommissionRequest) (*QueryReporterCommissionResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ReporterCommission not implemented")
}</span>

func RegisterQueryServer(s grpc1.Server, srv QueryServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;_Query_serviceDesc, srv)
}</span>

func _Query_Params_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryParamsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).Params(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.reporter.Query/Params",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).Params(ctx, req.(*QueryParamsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_Reporter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryReporterRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).Reporter(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.reporter.Query/Reporter",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).Reporter(ctx, req.(*QueryReporterRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_Reporters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryReportersRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).Reporters(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.reporter.Query/Reporters",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).Reporters(ctx, req.(*QueryReportersRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_DelegatorReporter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryDelegatorReporterRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).DelegatorReporter(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.reporter.Query/DelegatorReporter",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).DelegatorReporter(ctx, req.(*QueryDelegatorReporterRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_ReporterStake_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryReporterStakeRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).ReporterStake(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.reporter.Query/ReporterStake",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).ReporterStake(ctx, req.(*QueryReporterStakeRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_DelegationRewards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryDelegationRewardsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).DelegationRewards(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.reporter.Query/DelegationRewards",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).DelegationRewards(ctx, req.(*QueryDelegationRewardsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_ReporterOutstandingRewards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryReporterOutstandingRewardsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).ReporterOutstandingRewards(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.reporter.Query/ReporterOutstandingRewards",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).ReporterOutstandingRewards(ctx, req.(*QueryReporterOutstandingRewardsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_ReporterCommission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryReporterCommissionRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).ReporterCommission(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.reporter.Query/ReporterCommission",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).ReporterCommission(ctx, req.(*QueryReporterCommissionRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _Query_serviceDesc = grpc.ServiceDesc{
        ServiceName: "layer.reporter.Query",
        HandlerType: (*QueryServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Params",
                        Handler:    _Query_Params_Handler,
                },
                {
                        MethodName: "Reporter",
                        Handler:    _Query_Reporter_Handler,
                },
                {
                        MethodName: "Reporters",
                        Handler:    _Query_Reporters_Handler,
                },
                {
                        MethodName: "DelegatorReporter",
                        Handler:    _Query_DelegatorReporter_Handler,
                },
                {
                        MethodName: "ReporterStake",
                        Handler:    _Query_ReporterStake_Handler,
                },
                {
                        MethodName: "DelegationRewards",
                        Handler:    _Query_DelegationRewards_Handler,
                },
                {
                        MethodName: "ReporterOutstandingRewards",
                        Handler:    _Query_ReporterOutstandingRewards_Handler,
                },
                {
                        MethodName: "ReporterCommission",
                        Handler:    _Query_ReporterCommission_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "layer/reporter/query.proto",
}

func (m *QueryParamsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryParamsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryParamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *QueryParamsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryParamsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func (m *QueryReporterRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryReporterRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryReporterRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ReporterAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ReporterAddress)
                copy(dAtA[i:], m.ReporterAddress)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.ReporterAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryReporterResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryReporterResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryReporterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Reporter != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Reporter.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryReportersRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryReportersRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryReportersRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *QueryReportersResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryReportersResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryReportersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Reporters) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Reporters) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Reporters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryDelegatorReporterRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryDelegatorReporterRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryDelegatorReporterRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.DelegatorAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.DelegatorAddress)
                copy(dAtA[i:], m.DelegatorAddress)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.DelegatorAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryDelegatorReporterResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryDelegatorReporterResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryDelegatorReporterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Reporter) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Reporter)
                copy(dAtA[i:], m.Reporter)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.Reporter)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryReporterStakeRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryReporterStakeRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryReporterStakeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ReporterAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ReporterAddress)
                copy(dAtA[i:], m.ReporterAddress)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.ReporterAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryReporterStakeResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryReporterStakeResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryReporterStakeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size := m.Stake.Size()
                i -= size
                if _, err := m.Stake.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintQuery(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func (m *QueryDelegationRewardsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryDelegationRewardsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryDelegationRewardsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ReporterAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ReporterAddress)
                copy(dAtA[i:], m.ReporterAddress)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.ReporterAddress)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.DelegatorAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.DelegatorAddress)
                copy(dAtA[i:], m.DelegatorAddress)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.DelegatorAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryDelegationRewardsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryDelegationRewardsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryDelegationRewardsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Rewards) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Rewards) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Rewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryReporterOutstandingRewardsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryReporterOutstandingRewardsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryReporterOutstandingRewardsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ReporterAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ReporterAddress)
                copy(dAtA[i:], m.ReporterAddress)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.ReporterAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryReporterOutstandingRewardsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryReporterOutstandingRewardsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryReporterOutstandingRewardsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Rewards.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func (m *QueryReporterCommissionRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryReporterCommissionRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryReporterCommissionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ReporterAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ReporterAddress)
                copy(dAtA[i:], m.ReporterAddress)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.ReporterAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryReporterCommissionResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryReporterCommissionResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryReporterCommissionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Commission.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovQuery(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *QueryParamsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *QueryParamsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Params.Size()
        n += 1 + l + sovQuery(uint64(l))
        return n</span>
}

func (m *QueryReporterRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.ReporterAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryReporterResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Reporter != nil </span><span class="cov0" title="0">{
                l = m.Reporter.Size()
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryReportersRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *QueryReportersResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Reporters) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Reporters </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovQuery(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *QueryDelegatorReporterRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.DelegatorAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryDelegatorReporterResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Reporter)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryReporterStakeRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.ReporterAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryReporterStakeResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Stake.Size()
        n += 1 + l + sovQuery(uint64(l))
        return n</span>
}

func (m *QueryDelegationRewardsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.DelegatorAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.ReporterAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryDelegationRewardsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Rewards) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Rewards </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovQuery(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *QueryReporterOutstandingRewardsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.ReporterAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryReporterOutstandingRewardsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Rewards.Size()
        n += 1 + l + sovQuery(uint64(l))
        return n</span>
}

func (m *QueryReporterCommissionRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.ReporterAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryReporterCommissionResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Commission.Size()
        n += 1 + l + sovQuery(uint64(l))
        return n</span>
}

func sovQuery(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozQuery(x uint64) (n int) <span class="cov0" title="0">{
        return sovQuery(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *QueryParamsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryParamsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryReporterRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryReporterRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryReporterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ReporterAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ReporterAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryReporterResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryReporterResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryReporterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Reporter == nil </span><span class="cov0" title="0">{
                                m.Reporter = &amp;OracleReporter{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Reporter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryReportersRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryReportersRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryReportersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryReportersResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryReportersResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryReportersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Reporters", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Reporters = append(m.Reporters, &amp;OracleReporter{})
                        if err := m.Reporters[len(m.Reporters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryDelegatorReporterRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryDelegatorReporterRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryDelegatorReporterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.DelegatorAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryDelegatorReporterResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryDelegatorReporterResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryDelegatorReporterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Reporter = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryReporterStakeRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryReporterStakeRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryReporterStakeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ReporterAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ReporterAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryReporterStakeResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryReporterStakeResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryReporterStakeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Stake", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Stake.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryDelegationRewardsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryDelegationRewardsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryDelegationRewardsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.DelegatorAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ReporterAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ReporterAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryDelegationRewardsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryDelegationRewardsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryDelegationRewardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Rewards = append(m.Rewards, types.DecCoin{})
                        if err := m.Rewards[len(m.Rewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryReporterOutstandingRewardsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryReporterOutstandingRewardsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryReporterOutstandingRewardsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ReporterAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ReporterAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryReporterOutstandingRewardsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryReporterOutstandingRewardsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryReporterOutstandingRewardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryReporterCommissionRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryReporterCommissionRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryReporterCommissionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ReporterAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ReporterAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryReporterCommissionResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryReporterCommissionResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryReporterCommissionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Commission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipQuery(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupQuery
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthQuery
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file199" style="display: none">// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: layer/reporter/query.proto

/*
Package types is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package types

import (
        "context"
        "io"
        "net/http"

        "github.com/golang/protobuf/descriptor"
        "github.com/golang/protobuf/proto"
        "github.com/grpc-ecosystem/grpc-gateway/runtime"
        "github.com/grpc-ecosystem/grpc-gateway/utilities"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/grpclog"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// Suppress "imported and not used" errors
var _ codes.Code
var _ io.Reader
var _ status.Status
var _ = runtime.String
var _ = utilities.NewDoubleArray
var _ = descriptor.ForMessage
var _ = metadata.Join

func request_Query_Params_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryParamsRequest
        var metadata runtime.ServerMetadata

        msg, err := client.Params(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err

}</span>

func local_request_Query_Params_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryParamsRequest
        var metadata runtime.ServerMetadata

        msg, err := server.Params(ctx, &amp;protoReq)
        return msg, metadata, err

}</span>

func request_Query_Reporter_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryReporterRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["reporter_address"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "reporter_address")
        }</span>

        <span class="cov0" title="0">protoReq.ReporterAddress, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "reporter_address", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.Reporter(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_Reporter_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryReporterRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["reporter_address"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "reporter_address")
        }</span>

        <span class="cov0" title="0">protoReq.ReporterAddress, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "reporter_address", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.Reporter(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_Reporters_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryReportersRequest
        var metadata runtime.ServerMetadata

        msg, err := client.Reporters(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err

}</span>

func local_request_Query_Reporters_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryReportersRequest
        var metadata runtime.ServerMetadata

        msg, err := server.Reporters(ctx, &amp;protoReq)
        return msg, metadata, err

}</span>

func request_Query_DelegatorReporter_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryDelegatorReporterRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["delegator_address"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "delegator_address")
        }</span>

        <span class="cov0" title="0">protoReq.DelegatorAddress, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "delegator_address", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.DelegatorReporter(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_DelegatorReporter_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryDelegatorReporterRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["delegator_address"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "delegator_address")
        }</span>

        <span class="cov0" title="0">protoReq.DelegatorAddress, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "delegator_address", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.DelegatorReporter(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_ReporterStake_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryReporterStakeRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["reporter_address"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "reporter_address")
        }</span>

        <span class="cov0" title="0">protoReq.ReporterAddress, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "reporter_address", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.ReporterStake(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_ReporterStake_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryReporterStakeRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["reporter_address"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "reporter_address")
        }</span>

        <span class="cov0" title="0">protoReq.ReporterAddress, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "reporter_address", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.ReporterStake(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_DelegationRewards_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryDelegationRewardsRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["delegator_address"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "delegator_address")
        }</span>

        <span class="cov0" title="0">protoReq.DelegatorAddress, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "delegator_address", err)
        }</span>

        <span class="cov0" title="0">val, ok = pathParams["reporter_address"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "reporter_address")
        }</span>

        <span class="cov0" title="0">protoReq.ReporterAddress, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "reporter_address", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.DelegationRewards(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_DelegationRewards_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryDelegationRewardsRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["delegator_address"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "delegator_address")
        }</span>

        <span class="cov0" title="0">protoReq.DelegatorAddress, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "delegator_address", err)
        }</span>

        <span class="cov0" title="0">val, ok = pathParams["reporter_address"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "reporter_address")
        }</span>

        <span class="cov0" title="0">protoReq.ReporterAddress, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "reporter_address", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.DelegationRewards(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_ReporterOutstandingRewards_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryReporterOutstandingRewardsRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["reporter_address"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "reporter_address")
        }</span>

        <span class="cov0" title="0">protoReq.ReporterAddress, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "reporter_address", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.ReporterOutstandingRewards(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_ReporterOutstandingRewards_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryReporterOutstandingRewardsRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["reporter_address"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "reporter_address")
        }</span>

        <span class="cov0" title="0">protoReq.ReporterAddress, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "reporter_address", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.ReporterOutstandingRewards(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_ReporterCommission_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryReporterCommissionRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["reporter_address"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "reporter_address")
        }</span>

        <span class="cov0" title="0">protoReq.ReporterAddress, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "reporter_address", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.ReporterCommission(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_ReporterCommission_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryReporterCommissionRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["reporter_address"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "reporter_address")
        }</span>

        <span class="cov0" title="0">protoReq.ReporterAddress, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "reporter_address", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.ReporterCommission(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

// RegisterQueryHandlerServer registers the http handlers for service Query to "mux".
// UnaryRPC     :call QueryServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterQueryHandlerFromEndpoint instead.
func RegisterQueryHandlerServer(ctx context.Context, mux *runtime.ServeMux, server QueryServer) error <span class="cov0" title="0">{

        mux.Handle("GET", pattern_Query_Params_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_Params_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_Params_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_Reporter_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_Reporter_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_Reporter_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_Reporters_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_Reporters_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_Reporters_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_DelegatorReporter_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_DelegatorReporter_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_DelegatorReporter_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_ReporterStake_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_ReporterStake_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_ReporterStake_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_DelegationRewards_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_DelegationRewards_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_DelegationRewards_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_ReporterOutstandingRewards_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_ReporterOutstandingRewards_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_ReporterOutstandingRewards_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_ReporterCommission_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_ReporterCommission_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_ReporterCommission_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

// RegisterQueryHandlerFromEndpoint is same as RegisterQueryHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterQueryHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) <span class="cov0" title="0">{
        conn, err := grpc.Dial(endpoint, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                }()
        }()

        <span class="cov0" title="0">return RegisterQueryHandler(ctx, mux, conn)</span>
}

// RegisterQueryHandler registers the http handlers for service Query to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterQueryHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error <span class="cov0" title="0">{
        return RegisterQueryHandlerClient(ctx, mux, NewQueryClient(conn))
}</span>

// RegisterQueryHandlerClient registers the http handlers for service Query
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "QueryClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "QueryClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "QueryClient" to call the correct interceptors.
func RegisterQueryHandlerClient(ctx context.Context, mux *runtime.ServeMux, client QueryClient) error <span class="cov0" title="0">{

        mux.Handle("GET", pattern_Query_Params_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_Params_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_Params_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_Reporter_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_Reporter_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_Reporter_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_Reporters_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_Reporters_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_Reporters_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_DelegatorReporter_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_DelegatorReporter_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_DelegatorReporter_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_ReporterStake_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_ReporterStake_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_ReporterStake_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_DelegationRewards_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_DelegationRewards_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_DelegationRewards_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_ReporterOutstandingRewards_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_ReporterOutstandingRewards_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_ReporterOutstandingRewards_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_ReporterCommission_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_ReporterCommission_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_ReporterCommission_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

var (
        pattern_Query_Params_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"tellor-io", "layer", "reporter", "params"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_Reporter_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"tellor-io", "layer", "reporter", "reporter_address"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_Reporters_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"tellor-io", "layer", "reporter", "reporters"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_DelegatorReporter_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3, 1, 0, 4, 1, 5, 4}, []string{"tellor-io", "layer", "reporter", "delegator-reporter", "delegator_address"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_ReporterStake_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3, 1, 0, 4, 1, 5, 4}, []string{"tellor-io", "layer", "reporter", "reporter-stake", "reporter_address"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_DelegationRewards_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3, 1, 0, 4, 1, 5, 4, 1, 0, 4, 1, 5, 5}, []string{"tellor-io", "layer", "reporter", "delegation-rewards", "delegator_address", "reporter_address"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_ReporterOutstandingRewards_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3, 1, 0, 4, 1, 5, 4}, []string{"tellor-io", "layer", "reporter", "outstanding-rewards", "reporter_address"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_ReporterCommission_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3, 1, 0, 4, 1, 5, 4}, []string{"tellor-io", "layer", "reporter", "commission", "reporter_address"}, "", runtime.AssumeColonVerbOpt(false)))
)

var (
        forward_Query_Params_0 = runtime.ForwardResponseMessage

        forward_Query_Reporter_0 = runtime.ForwardResponseMessage

        forward_Query_Reporters_0 = runtime.ForwardResponseMessage

        forward_Query_DelegatorReporter_0 = runtime.ForwardResponseMessage

        forward_Query_ReporterStake_0 = runtime.ForwardResponseMessage

        forward_Query_DelegationRewards_0 = runtime.ForwardResponseMessage

        forward_Query_ReporterOutstandingRewards_0 = runtime.ForwardResponseMessage

        forward_Query_ReporterCommission_0 = runtime.ForwardResponseMessage
)
</pre>
		
		<pre class="file" id="file200" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/reporter/token_origin.proto

package types

import (
        cosmossdk_io_math "cosmossdk.io/math"
        fmt "fmt"
        _ "github.com/cosmos/cosmos-proto"
        _ "github.com/cosmos/cosmos-sdk/types/tx/amino"
        _ "github.com/cosmos/gogoproto/gogoproto"
        proto "github.com/cosmos/gogoproto/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TokenOrigin is a message to store the origin of a token
type TokenOrigin struct {
        // validator_address is the address of the validator that tokens in staking are delegated to
        ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
        // amount is the amount of tokens to be delegated to a reporter from a delegation in staking
        Amount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
}

func (m *TokenOrigin) Reset()         <span class="cov0" title="0">{ *m = TokenOrigin{} }</span>
func (m *TokenOrigin) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*TokenOrigin) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*TokenOrigin) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bf34edebb26f68f4, []int{0}
}</span>
func (m *TokenOrigin) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *TokenOrigin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_TokenOrigin.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *TokenOrigin) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_TokenOrigin.Merge(m, src)
}</span>
func (m *TokenOrigin) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *TokenOrigin) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_TokenOrigin.DiscardUnknown(m)
}</span>

var xxx_messageInfo_TokenOrigin proto.InternalMessageInfo

func (m *TokenOrigin) GetValidatorAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ValidatorAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type TokenOriginInfo struct {
        DelegatorAddress string                `protobuf:"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3" json:"delegator_address,omitempty"`
        ValidatorAddress string                `protobuf:"bytes,2,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
        Amount           cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
}

func (m *TokenOriginInfo) Reset()         <span class="cov0" title="0">{ *m = TokenOriginInfo{} }</span>
func (m *TokenOriginInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*TokenOriginInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*TokenOriginInfo) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bf34edebb26f68f4, []int{1}
}</span>
func (m *TokenOriginInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *TokenOriginInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_TokenOriginInfo.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *TokenOriginInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_TokenOriginInfo.Merge(m, src)
}</span>
func (m *TokenOriginInfo) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *TokenOriginInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_TokenOriginInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_TokenOriginInfo proto.InternalMessageInfo

func (m *TokenOriginInfo) GetDelegatorAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DelegatorAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *TokenOriginInfo) GetValidatorAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ValidatorAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// reporter's snapshot of delegators' sources pre unbonding
type DelegationsPreUpdate struct {
        // token_origin is the origin of the tokens that are about to be updated
        TokenOrigins []*TokenOriginInfo `protobuf:"bytes,1,rep,name=token_origins,json=tokenOrigins,proto3" json:"token_origins,omitempty"`
}

func (m *DelegationsPreUpdate) Reset()         <span class="cov0" title="0">{ *m = DelegationsPreUpdate{} }</span>
func (m *DelegationsPreUpdate) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DelegationsPreUpdate) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*DelegationsPreUpdate) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bf34edebb26f68f4, []int{2}
}</span>
func (m *DelegationsPreUpdate) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *DelegationsPreUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_DelegationsPreUpdate.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *DelegationsPreUpdate) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_DelegationsPreUpdate.Merge(m, src)
}</span>
func (m *DelegationsPreUpdate) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *DelegationsPreUpdate) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_DelegationsPreUpdate.DiscardUnknown(m)
}</span>

var xxx_messageInfo_DelegationsPreUpdate proto.InternalMessageInfo

func (m *DelegationsPreUpdate) GetTokenOrigins() []*TokenOriginInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TokenOrigins
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*TokenOrigin)(nil), "layer.reporter.TokenOrigin")
        proto.RegisterType((*TokenOriginInfo)(nil), "layer.reporter.TokenOriginInfo")
        proto.RegisterType((*DelegationsPreUpdate)(nil), "layer.reporter.DelegationsPreUpdate")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/reporter/token_origin.proto", fileDescriptor_bf34edebb26f68f4) }</span>

var fileDescriptor_bf34edebb26f68f4 = []byte{
        // 384 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x52, 0xcd, 0x6a, 0xea, 0x40,
        0x14, 0x4e, 0xae, 0x20, 0xdc, 0xf1, 0xfe, 0x68, 0xf0, 0x82, 0x57, 0xb8, 0xf1, 0xea, 0x4a, 0x90,
        0x24, 0xd0, 0x3e, 0x41, 0xad, 0x2e, 0xdc, 0xb4, 0x25, 0xfd, 0x59, 0x94, 0x82, 0x8c, 0x66, 0x1a,
        0x07, 0x93, 0x39, 0x61, 0x66, 0x2c, 0x75, 0xd5, 0x57, 0xe8, 0xc3, 0xf8, 0x10, 0x2e, 0xc5, 0x55,
        0xe9, 0x42, 0x8a, 0xae, 0xfb, 0x0e, 0x25, 0x99, 0x68, 0xad, 0x2d, 0x5d, 0x74, 0x13, 0x72, 0xbe,
        0xf3, 0x9d, 0x73, 0xbe, 0x6f, 0xce, 0x41, 0xd5, 0x00, 0x8f, 0x09, 0x77, 0x38, 0x89, 0x80, 0x4b,
        0xc2, 0x1d, 0x09, 0x43, 0xc2, 0xba, 0xc0, 0xa9, 0x4f, 0x99, 0x1d, 0x71, 0x90, 0x60, 0xfc, 0x4a,
        0x28, 0xf6, 0x9a, 0x52, 0x2e, 0xe0, 0x90, 0x32, 0x70, 0x92, 0xaf, 0xa2, 0x94, 0xff, 0xf6, 0x41,
        0x84, 0x20, 0xba, 0x49, 0xe4, 0xa8, 0x20, 0x4d, 0x15, 0x7d, 0xf0, 0x41, 0xe1, 0xf1, 0x9f, 0x42,
        0x6b, 0x77, 0x28, 0x77, 0x16, 0x4f, 0x3a, 0x4e, 0x06, 0x19, 0x0d, 0x54, 0xb8, 0xc1, 0x01, 0xf5,
        0xb0, 0x04, 0xde, 0xc5, 0x9e, 0xc7, 0x89, 0x10, 0x25, 0xfd, 0xbf, 0x5e, 0xff, 0xee, 0xe6, 0x37,
        0x89, 0x03, 0x85, 0x1b, 0x87, 0x28, 0x8b, 0x43, 0x18, 0x31, 0x59, 0xfa, 0x16, 0x33, 0x9a, 0x8d,
        0xe9, 0xa2, 0xa2, 0x3d, 0x2e, 0x2a, 0x7f, 0xd4, 0x5c, 0xe1, 0x0d, 0x6d, 0x0a, 0x4e, 0x88, 0xe5,
        0xc0, 0xee, 0x30, 0x39, 0x9f, 0x58, 0x28, 0x15, 0xd4, 0x61, 0xd2, 0x4d, 0x4b, 0x6b, 0xcf, 0x3a,
        0xfa, 0xbd, 0xa5, 0xa0, 0xc3, 0xae, 0xc1, 0x68, 0xa3, 0x82, 0x47, 0x02, 0xe2, 0xbf, 0x57, 0xd1,
        0x2c, 0xcd, 0x27, 0x56, 0x31, 0x6d, 0x93, 0xea, 0x38, 0x95, 0x9c, 0x32, 0xdf, 0xcd, 0x6f, 0x4a,
        0xd6, 0xfa, 0x8e, 0x3e, 0x32, 0xa3, 0xa4, 0x56, 0xe7, 0x13, 0xeb, 0x5f, 0xda, 0xe6, 0x62, 0xc7,
        0xd7, 0xba, 0xdf, 0x27, 0x7e, 0x33, 0x5f, 0xf7, 0x7b, 0x85, 0x8a, 0x2d, 0x25, 0x94, 0x02, 0x13,
        0x27, 0x9c, 0x9c, 0x47, 0x1e, 0x96, 0xc4, 0x68, 0xa1, 0x9f, 0xdb, 0x2b, 0x8f, 0xfd, 0x66, 0xea,
        0xb9, 0xbd, 0x8a, 0xfd, 0x76, 0xe9, 0xf6, 0xce, 0x5b, 0xb9, 0x3f, 0xe4, 0x2b, 0x20, 0x9a, 0xed,
        0xe9, 0xd2, 0xd4, 0x67, 0x4b, 0x53, 0x7f, 0x5a, 0x9a, 0xfa, 0xfd, 0xca, 0xd4, 0x66, 0x2b, 0x53,
        0x7b, 0x58, 0x99, 0xda, 0x65, 0xc3, 0xa7, 0x72, 0x30, 0xea, 0xd9, 0x7d, 0x08, 0x1d, 0x49, 0x82,
        0x00, 0xb8, 0x45, 0xc1, 0x51, 0x47, 0x77, 0xbb, 0x75, 0x76, 0xe3, 0x88, 0x88, 0x5e, 0x36, 0x39,
        0x8e, 0xfd, 0x97, 0x00, 0x00, 0x00, 0xff, 0xff, 0x2d, 0xda, 0x93, 0x48, 0x95, 0x02, 0x00, 0x00,
}

func (m *TokenOrigin) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *TokenOrigin) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *TokenOrigin) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size := m.Amount.Size()
                i -= size
                if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintTokenOrigin(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x12
        if len(m.ValidatorAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ValidatorAddress)
                copy(dAtA[i:], m.ValidatorAddress)
                i = encodeVarintTokenOrigin(dAtA, i, uint64(len(m.ValidatorAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *TokenOriginInfo) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *TokenOriginInfo) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *TokenOriginInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size := m.Amount.Size()
                i -= size
                if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintTokenOrigin(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x1a
        if len(m.ValidatorAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ValidatorAddress)
                copy(dAtA[i:], m.ValidatorAddress)
                i = encodeVarintTokenOrigin(dAtA, i, uint64(len(m.ValidatorAddress)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.DelegatorAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.DelegatorAddress)
                copy(dAtA[i:], m.DelegatorAddress)
                i = encodeVarintTokenOrigin(dAtA, i, uint64(len(m.DelegatorAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *DelegationsPreUpdate) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *DelegationsPreUpdate) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *DelegationsPreUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.TokenOrigins) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.TokenOrigins) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.TokenOrigins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintTokenOrigin(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintTokenOrigin(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovTokenOrigin(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *TokenOrigin) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.ValidatorAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTokenOrigin(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Amount.Size()
        n += 1 + l + sovTokenOrigin(uint64(l))
        return n</span>
}

func (m *TokenOriginInfo) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.DelegatorAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTokenOrigin(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.ValidatorAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTokenOrigin(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Amount.Size()
        n += 1 + l + sovTokenOrigin(uint64(l))
        return n</span>
}

func (m *DelegationsPreUpdate) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.TokenOrigins) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.TokenOrigins </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovTokenOrigin(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func sovTokenOrigin(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozTokenOrigin(x uint64) (n int) <span class="cov0" title="0">{
        return sovTokenOrigin(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *TokenOrigin) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTokenOrigin
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: TokenOrigin: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: TokenOrigin: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTokenOrigin
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTokenOrigin
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTokenOrigin
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTokenOrigin
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTokenOrigin
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTokenOrigin
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTokenOrigin(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTokenOrigin
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *TokenOriginInfo) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTokenOrigin
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: TokenOriginInfo: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: TokenOriginInfo: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTokenOrigin
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTokenOrigin
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTokenOrigin
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.DelegatorAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTokenOrigin
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTokenOrigin
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTokenOrigin
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTokenOrigin
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTokenOrigin
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTokenOrigin
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTokenOrigin(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTokenOrigin
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *DelegationsPreUpdate) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTokenOrigin
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: DelegationsPreUpdate: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: DelegationsPreUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field TokenOrigins", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTokenOrigin
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTokenOrigin
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTokenOrigin
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.TokenOrigins = append(m.TokenOrigins, &amp;TokenOriginInfo{})
                        if err := m.TokenOrigins[len(m.TokenOrigins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTokenOrigin(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTokenOrigin
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipTokenOrigin(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowTokenOrigin
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowTokenOrigin
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowTokenOrigin
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthTokenOrigin
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupTokenOrigin
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthTokenOrigin
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthTokenOrigin        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowTokenOrigin          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupTokenOrigin = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file201" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: layer/reporter/tx.proto

package types

import (
        context "context"
        cosmossdk_io_math "cosmossdk.io/math"
        fmt "fmt"
        _ "github.com/cosmos/cosmos-proto"
        github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
        types1 "github.com/cosmos/cosmos-sdk/types"
        _ "github.com/cosmos/cosmos-sdk/types/msgservice"
        _ "github.com/cosmos/cosmos-sdk/types/tx/amino"
        types "github.com/cosmos/cosmos-sdk/x/staking/types"
        _ "github.com/cosmos/gogoproto/gogoproto"
        grpc1 "github.com/cosmos/gogoproto/grpc"
        proto "github.com/cosmos/gogoproto/proto"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgUpdateParams is the Msg/UpdateParams request type.
type MsgUpdateParams struct {
        // authority is the address that controls the module (defaults to x/gov unless overwritten).
        Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
        // NOTE: All parameters must be supplied.
        Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateParams) Reset()         <span class="cov0" title="0">{ *m = MsgUpdateParams{} }</span>
func (m *MsgUpdateParams) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgUpdateParams) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgUpdateParams) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_67b904a7aa978eb1, []int{0}
}</span>
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}</span>
func (m *MsgUpdateParams) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdateParams) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

func (m *MsgUpdateParams) GetAuthority() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Authority
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgUpdateParams) GetParams() Params <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Params
        }</span>
        <span class="cov0" title="0">return Params{}</span>
}

// MsgUpdateParamsResponse defines the response structure for executing a
// MsgUpdateParams message.
type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse) Reset()         <span class="cov0" title="0">{ *m = MsgUpdateParamsResponse{} }</span>
func (m *MsgUpdateParamsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgUpdateParamsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_67b904a7aa978eb1, []int{1}
}</span>
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}</span>
func (m *MsgUpdateParamsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

type MsgCreateReporter struct {
        Reporter     string                `protobuf:"bytes,1,opt,name=reporter,proto3" json:"reporter,omitempty"`
        Amount       cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
        TokenOrigins []*TokenOrigin        `protobuf:"bytes,3,rep,name=token_origins,json=tokenOrigins,proto3" json:"token_origins,omitempty"`
        Commission   *types.Commission     `protobuf:"bytes,4,opt,name=commission,proto3" json:"commission,omitempty"`
}

func (m *MsgCreateReporter) Reset()         <span class="cov0" title="0">{ *m = MsgCreateReporter{} }</span>
func (m *MsgCreateReporter) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgCreateReporter) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgCreateReporter) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_67b904a7aa978eb1, []int{2}
}</span>
func (m *MsgCreateReporter) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgCreateReporter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgCreateReporter.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgCreateReporter) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgCreateReporter.Merge(m, src)
}</span>
func (m *MsgCreateReporter) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgCreateReporter) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgCreateReporter.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgCreateReporter proto.InternalMessageInfo

func (m *MsgCreateReporter) GetReporter() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Reporter
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgCreateReporter) GetTokenOrigins() []*TokenOrigin <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TokenOrigins
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *MsgCreateReporter) GetCommission() *types.Commission <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Commission
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type MsgCreateReporterResponse struct {
}

func (m *MsgCreateReporterResponse) Reset()         <span class="cov0" title="0">{ *m = MsgCreateReporterResponse{} }</span>
func (m *MsgCreateReporterResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgCreateReporterResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgCreateReporterResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_67b904a7aa978eb1, []int{3}
}</span>
func (m *MsgCreateReporterResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgCreateReporterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgCreateReporterResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgCreateReporterResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgCreateReporterResponse.Merge(m, src)
}</span>
func (m *MsgCreateReporterResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgCreateReporterResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgCreateReporterResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgCreateReporterResponse proto.InternalMessageInfo

type MsgDelegateReporter struct {
        Delegator    string                `protobuf:"bytes,1,opt,name=delegator,proto3" json:"delegator,omitempty"`
        Reporter     string                `protobuf:"bytes,2,opt,name=reporter,proto3" json:"reporter,omitempty"`
        Amount       cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
        TokenOrigins []*TokenOrigin        `protobuf:"bytes,4,rep,name=token_origins,json=tokenOrigins,proto3" json:"token_origins,omitempty"`
}

func (m *MsgDelegateReporter) Reset()         <span class="cov0" title="0">{ *m = MsgDelegateReporter{} }</span>
func (m *MsgDelegateReporter) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgDelegateReporter) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgDelegateReporter) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_67b904a7aa978eb1, []int{4}
}</span>
func (m *MsgDelegateReporter) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgDelegateReporter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgDelegateReporter.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgDelegateReporter) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgDelegateReporter.Merge(m, src)
}</span>
func (m *MsgDelegateReporter) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgDelegateReporter) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgDelegateReporter.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgDelegateReporter proto.InternalMessageInfo

func (m *MsgDelegateReporter) GetDelegator() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Delegator
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgDelegateReporter) GetReporter() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Reporter
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgDelegateReporter) GetTokenOrigins() []*TokenOrigin <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TokenOrigins
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// MsgDelegateReporterResponse defines the response structure for executing a MsgDelegateReporter message.
type MsgDelegateReporterResponse struct {
}

func (m *MsgDelegateReporterResponse) Reset()         <span class="cov0" title="0">{ *m = MsgDelegateReporterResponse{} }</span>
func (m *MsgDelegateReporterResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgDelegateReporterResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgDelegateReporterResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_67b904a7aa978eb1, []int{5}
}</span>
func (m *MsgDelegateReporterResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgDelegateReporterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgDelegateReporterResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgDelegateReporterResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgDelegateReporterResponse.Merge(m, src)
}</span>
func (m *MsgDelegateReporterResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgDelegateReporterResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgDelegateReporterResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgDelegateReporterResponse proto.InternalMessageInfo

// MsgUndelegateReporter defines the Msg/UndelegateReporter request type.
type MsgUndelegateReporter struct {
        DelegatorAddress string `protobuf:"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3" json:"delegator_address,omitempty"`
        // token_origin is the token origin to undelegate from. If empty, all token origins are undelegated,
        // else the amount field will be the amount to undelegate from the specified token origin.
        TokenOrigins []*TokenOrigin `protobuf:"bytes,2,rep,name=token_origins,json=tokenOrigins,proto3" json:"token_origins,omitempty"`
}

func (m *MsgUndelegateReporter) Reset()         <span class="cov0" title="0">{ *m = MsgUndelegateReporter{} }</span>
func (m *MsgUndelegateReporter) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgUndelegateReporter) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgUndelegateReporter) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_67b904a7aa978eb1, []int{6}
}</span>
func (m *MsgUndelegateReporter) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUndelegateReporter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUndelegateReporter.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUndelegateReporter) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUndelegateReporter.Merge(m, src)
}</span>
func (m *MsgUndelegateReporter) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUndelegateReporter) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUndelegateReporter.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUndelegateReporter proto.InternalMessageInfo

func (m *MsgUndelegateReporter) GetDelegatorAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DelegatorAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgUndelegateReporter) GetTokenOrigins() []*TokenOrigin <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TokenOrigins
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type MsgUndelegateReporterResponse struct {
}

func (m *MsgUndelegateReporterResponse) Reset()         <span class="cov0" title="0">{ *m = MsgUndelegateReporterResponse{} }</span>
func (m *MsgUndelegateReporterResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgUndelegateReporterResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgUndelegateReporterResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_67b904a7aa978eb1, []int{7}
}</span>
func (m *MsgUndelegateReporterResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUndelegateReporterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUndelegateReporterResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUndelegateReporterResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUndelegateReporterResponse.Merge(m, src)
}</span>
func (m *MsgUndelegateReporterResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUndelegateReporterResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUndelegateReporterResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUndelegateReporterResponse proto.InternalMessageInfo

// MsgWithdrawReporterCommission withdraws the full commission to the reporter
// address.
type MsgWithdrawReporterCommission struct {
        ReporterAddress string `protobuf:"bytes,1,opt,name=reporter_address,json=reporterAddress,proto3" json:"reporter_address,omitempty"`
}

func (m *MsgWithdrawReporterCommission) Reset()         <span class="cov0" title="0">{ *m = MsgWithdrawReporterCommission{} }</span>
func (m *MsgWithdrawReporterCommission) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgWithdrawReporterCommission) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgWithdrawReporterCommission) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_67b904a7aa978eb1, []int{8}
}</span>
func (m *MsgWithdrawReporterCommission) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgWithdrawReporterCommission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgWithdrawReporterCommission.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgWithdrawReporterCommission) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgWithdrawReporterCommission.Merge(m, src)
}</span>
func (m *MsgWithdrawReporterCommission) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgWithdrawReporterCommission) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgWithdrawReporterCommission.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgWithdrawReporterCommission proto.InternalMessageInfo

// MsgWithdrawReporterCommissionResponse defines the
// Msg/WithdrawReporterCommission response type.
type MsgWithdrawReporterCommissionResponse struct {
        Amount github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"amount"`
}

func (m *MsgWithdrawReporterCommissionResponse) Reset()         <span class="cov0" title="0">{ *m = MsgWithdrawReporterCommissionResponse{} }</span>
func (m *MsgWithdrawReporterCommissionResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgWithdrawReporterCommissionResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgWithdrawReporterCommissionResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_67b904a7aa978eb1, []int{9}
}</span>
func (m *MsgWithdrawReporterCommissionResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgWithdrawReporterCommissionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgWithdrawReporterCommissionResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgWithdrawReporterCommissionResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgWithdrawReporterCommissionResponse.Merge(m, src)
}</span>
func (m *MsgWithdrawReporterCommissionResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgWithdrawReporterCommissionResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgWithdrawReporterCommissionResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgWithdrawReporterCommissionResponse proto.InternalMessageInfo

func (m *MsgWithdrawReporterCommissionResponse) GetAmount() github_com_cosmos_cosmos_sdk_types.Coins <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Amount
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// MsgWithdrawDelegatorReward represents delegation withdrawal to a delegator
// from a reporter.
type MsgWithdrawDelegatorReward struct {
        DelegatorAddress string `protobuf:"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3" json:"delegator_address,omitempty"`
        ReporterAddress  string `protobuf:"bytes,2,opt,name=reporter_address,json=reporterAddress,proto3" json:"reporter_address,omitempty"`
}

func (m *MsgWithdrawDelegatorReward) Reset()         <span class="cov0" title="0">{ *m = MsgWithdrawDelegatorReward{} }</span>
func (m *MsgWithdrawDelegatorReward) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgWithdrawDelegatorReward) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgWithdrawDelegatorReward) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_67b904a7aa978eb1, []int{10}
}</span>
func (m *MsgWithdrawDelegatorReward) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgWithdrawDelegatorReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgWithdrawDelegatorReward.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgWithdrawDelegatorReward) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgWithdrawDelegatorReward.Merge(m, src)
}</span>
func (m *MsgWithdrawDelegatorReward) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgWithdrawDelegatorReward) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgWithdrawDelegatorReward.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgWithdrawDelegatorReward proto.InternalMessageInfo

// MsgWithdrawDelegatorRewardResponse defines the Msg/WithdrawDelegatorReward
// response type.
type MsgWithdrawDelegatorRewardResponse struct {
        Amount github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"amount"`
}

func (m *MsgWithdrawDelegatorRewardResponse) Reset()         <span class="cov0" title="0">{ *m = MsgWithdrawDelegatorRewardResponse{} }</span>
func (m *MsgWithdrawDelegatorRewardResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgWithdrawDelegatorRewardResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgWithdrawDelegatorRewardResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_67b904a7aa978eb1, []int{11}
}</span>
func (m *MsgWithdrawDelegatorRewardResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgWithdrawDelegatorRewardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgWithdrawDelegatorRewardResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgWithdrawDelegatorRewardResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgWithdrawDelegatorRewardResponse.Merge(m, src)
}</span>
func (m *MsgWithdrawDelegatorRewardResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgWithdrawDelegatorRewardResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgWithdrawDelegatorRewardResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgWithdrawDelegatorRewardResponse proto.InternalMessageInfo

func (m *MsgWithdrawDelegatorRewardResponse) GetAmount() github_com_cosmos_cosmos_sdk_types.Coins <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Amount
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// MsgUnjailReporter defines the Msg/UnjailReporter request type.
type MsgUnjailReporter struct {
        ReporterAddress string `protobuf:"bytes,1,opt,name=reporter_address,json=reporterAddress,proto3" json:"reporter_address,omitempty"`
}

func (m *MsgUnjailReporter) Reset()         <span class="cov0" title="0">{ *m = MsgUnjailReporter{} }</span>
func (m *MsgUnjailReporter) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgUnjailReporter) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgUnjailReporter) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_67b904a7aa978eb1, []int{12}
}</span>
func (m *MsgUnjailReporter) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUnjailReporter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUnjailReporter.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUnjailReporter) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUnjailReporter.Merge(m, src)
}</span>
func (m *MsgUnjailReporter) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUnjailReporter) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUnjailReporter.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUnjailReporter proto.InternalMessageInfo

// MsgUnjailReporterResponse defines the Msg/UnjailReporter response type.
type MsgUnjailReporterResponse struct {
}

func (m *MsgUnjailReporterResponse) Reset()         <span class="cov0" title="0">{ *m = MsgUnjailReporterResponse{} }</span>
func (m *MsgUnjailReporterResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgUnjailReporterResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgUnjailReporterResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_67b904a7aa978eb1, []int{13}
}</span>
func (m *MsgUnjailReporterResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUnjailReporterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUnjailReporterResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUnjailReporterResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUnjailReporterResponse.Merge(m, src)
}</span>
func (m *MsgUnjailReporterResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUnjailReporterResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUnjailReporterResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUnjailReporterResponse proto.InternalMessageInfo

// MsgWithdrawTip defines the Msg/WithdrawTip request type.
type MsgWithdrawTip struct {
        DelegatorAddress string `protobuf:"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3" json:"delegator_address,omitempty"`
        ValidatorAddress string `protobuf:"bytes,2,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
}

func (m *MsgWithdrawTip) Reset()         <span class="cov0" title="0">{ *m = MsgWithdrawTip{} }</span>
func (m *MsgWithdrawTip) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgWithdrawTip) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgWithdrawTip) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_67b904a7aa978eb1, []int{14}
}</span>
func (m *MsgWithdrawTip) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgWithdrawTip) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgWithdrawTip.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgWithdrawTip) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgWithdrawTip.Merge(m, src)
}</span>
func (m *MsgWithdrawTip) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgWithdrawTip) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgWithdrawTip.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgWithdrawTip proto.InternalMessageInfo

func (m *MsgWithdrawTip) GetDelegatorAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DelegatorAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgWithdrawTip) GetValidatorAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ValidatorAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// MsgWithdrawTipResponse defines the Msg/WithdrawTip response type.
type MsgWithdrawTipResponse struct {
}

func (m *MsgWithdrawTipResponse) Reset()         <span class="cov0" title="0">{ *m = MsgWithdrawTipResponse{} }</span>
func (m *MsgWithdrawTipResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgWithdrawTipResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgWithdrawTipResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_67b904a7aa978eb1, []int{15}
}</span>
func (m *MsgWithdrawTipResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgWithdrawTipResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgWithdrawTipResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgWithdrawTipResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgWithdrawTipResponse.Merge(m, src)
}</span>
func (m *MsgWithdrawTipResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgWithdrawTipResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgWithdrawTipResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgWithdrawTipResponse proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*MsgUpdateParams)(nil), "layer.reporter.MsgUpdateParams")
        proto.RegisterType((*MsgUpdateParamsResponse)(nil), "layer.reporter.MsgUpdateParamsResponse")
        proto.RegisterType((*MsgCreateReporter)(nil), "layer.reporter.MsgCreateReporter")
        proto.RegisterType((*MsgCreateReporterResponse)(nil), "layer.reporter.MsgCreateReporterResponse")
        proto.RegisterType((*MsgDelegateReporter)(nil), "layer.reporter.MsgDelegateReporter")
        proto.RegisterType((*MsgDelegateReporterResponse)(nil), "layer.reporter.MsgDelegateReporterResponse")
        proto.RegisterType((*MsgUndelegateReporter)(nil), "layer.reporter.MsgUndelegateReporter")
        proto.RegisterType((*MsgUndelegateReporterResponse)(nil), "layer.reporter.MsgUndelegateReporterResponse")
        proto.RegisterType((*MsgWithdrawReporterCommission)(nil), "layer.reporter.MsgWithdrawReporterCommission")
        proto.RegisterType((*MsgWithdrawReporterCommissionResponse)(nil), "layer.reporter.MsgWithdrawReporterCommissionResponse")
        proto.RegisterType((*MsgWithdrawDelegatorReward)(nil), "layer.reporter.MsgWithdrawDelegatorReward")
        proto.RegisterType((*MsgWithdrawDelegatorRewardResponse)(nil), "layer.reporter.MsgWithdrawDelegatorRewardResponse")
        proto.RegisterType((*MsgUnjailReporter)(nil), "layer.reporter.MsgUnjailReporter")
        proto.RegisterType((*MsgUnjailReporterResponse)(nil), "layer.reporter.MsgUnjailReporterResponse")
        proto.RegisterType((*MsgWithdrawTip)(nil), "layer.reporter.MsgWithdrawTip")
        proto.RegisterType((*MsgWithdrawTipResponse)(nil), "layer.reporter.MsgWithdrawTipResponse")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("layer/reporter/tx.proto", fileDescriptor_67b904a7aa978eb1) }</span>

var fileDescriptor_67b904a7aa978eb1 = []byte{
        // 973 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0x41, 0x4f, 0x24, 0x45,
        0x14, 0x9e, 0x1a, 0x56, 0xe2, 0x3c, 0x76, 0x59, 0x68, 0x77, 0x61, 0x68, 0xa4, 0x07, 0x5a, 0x57,
        0x11, 0x32, 0xdd, 0x81, 0xcd, 0x9a, 0xc8, 0x49, 0x87, 0xdd, 0xc3, 0x1e, 0x50, 0xd3, 0x82, 0x1a,
        0x0f, 0x92, 0x82, 0xae, 0xf4, 0xd4, 0x32, 0xdd, 0x35, 0xe9, 0x2a, 0x60, 0xb9, 0x99, 0xf5, 0xa2,
        0x1e, 0x8c, 0xfe, 0x01, 0xb3, 0x47, 0xe3, 0x89, 0x03, 0x17, 0x4f, 0x5e, 0xb9, 0xb9, 0xe1, 0x64,
        0x3c, 0xac, 0x06, 0x12, 0xf1, 0x67, 0x98, 0xee, 0xae, 0xae, 0xe9, 0xe9, 0xe9, 0x99, 0x85, 0x04,
        0xb3, 0x17, 0x86, 0xaa, 0xf7, 0xbd, 0x57, 0xdf, 0xfb, 0xfa, 0xab, 0xd7, 0x0d, 0x93, 0x2d, 0x7c,
        0x40, 0x42, 0x3b, 0x24, 0x6d, 0x16, 0x0a, 0x12, 0xda, 0xe2, 0xb1, 0xd5, 0x0e, 0x99, 0x60, 0xda,
        0x68, 0x1c, 0xb0, 0xd2, 0x80, 0x3e, 0x8e, 0x7d, 0x1a, 0x30, 0x3b, 0xfe, 0x9b, 0x40, 0x74, 0x63,
        0x9b, 0x71, 0x9f, 0x71, 0x7b, 0x0b, 0x73, 0x62, 0xef, 0x2d, 0x6d, 0x11, 0x81, 0x97, 0xec, 0x6d,
        0x46, 0x03, 0x19, 0x9f, 0x94, 0x71, 0x9f, 0x7b, 0xf6, 0xde, 0x52, 0xf4, 0x23, 0x03, 0x6f, 0xca,
        0x00, 0x17, 0x78, 0x87, 0x06, 0x9e, 0xca, 0x95, 0x6b, 0x89, 0x9a, 0x4a, 0x50, 0x9b, 0xf1, 0xca,
        0x4e, 0x16, 0x32, 0x74, 0xcb, 0x63, 0x1e, 0x4b, 0xf6, 0xa3, 0xff, 0xe4, 0xee, 0x74, 0xae, 0x97,
        0x36, 0x0e, 0xb1, 0x9f, 0xa6, 0xcc, 0xe5, 0x1b, 0x65, 0x3b, 0x24, 0xd8, 0x64, 0x21, 0xf5, 0x52,
        0xbe, 0xe6, 0xaf, 0x08, 0x6e, 0xae, 0x71, 0x6f, 0xa3, 0xed, 0x62, 0x41, 0x3e, 0x8e, 0x93, 0xb5,
        0x77, 0xa1, 0x82, 0x77, 0x45, 0x93, 0x85, 0x54, 0x1c, 0x54, 0xd1, 0x2c, 0x9a, 0xaf, 0x34, 0xaa,
        0x27, 0x47, 0xf5, 0x5b, 0x92, 0xce, 0x07, 0xae, 0x1b, 0x12, 0xce, 0x3f, 0x11, 0x21, 0x0d, 0x3c,
        0xa7, 0x03, 0xd5, 0xde, 0x83, 0xe1, 0xe4, 0xf8, 0x6a, 0x79, 0x16, 0xcd, 0x8f, 0x2c, 0x4f, 0x58,
        0xdd, 0x7a, 0x5a, 0x49, 0xfd, 0x46, 0xe5, 0xf8, 0x79, 0xad, 0xf4, 0xf3, 0xf9, 0xe1, 0x02, 0x72,
        0x64, 0xc2, 0xca, 0xdd, 0x27, 0xe7, 0x87, 0x0b, 0x9d, 0x52, 0xdf, 0x9d, 0x1f, 0x2e, 0xcc, 0x26,
        0xe4, 0x1f, 0x77, 0xe8, 0xe7, 0x78, 0x9a, 0x53, 0x30, 0x99, 0xdb, 0x72, 0x08, 0x6f, 0xb3, 0x80,
        0x13, 0xf3, 0xdb, 0x32, 0x8c, 0xaf, 0x71, 0x6f, 0x35, 0x24, 0x58, 0x10, 0x47, 0x16, 0xd0, 0x74,
        0x78, 0x35, 0x2d, 0x96, 0xf4, 0xe5, 0xa8, 0xb5, 0xb6, 0x0a, 0xc3, 0xd8, 0x67, 0xbb, 0x81, 0x88,
        0xc9, 0x57, 0x1a, 0x8b, 0x11, 0xc9, 0x3f, 0x9f, 0xd7, 0x6e, 0x27, 0x5d, 0x73, 0x77, 0xc7, 0xa2,
        0xcc, 0xf6, 0xb1, 0x68, 0x5a, 0x0f, 0x03, 0x71, 0x72, 0x54, 0x07, 0x29, 0xc7, 0xc3, 0x40, 0x38,
        0x32, 0x55, 0x7b, 0x1f, 0x6e, 0x64, 0x35, 0xe6, 0xd5, 0xa1, 0xd9, 0xa1, 0xf9, 0x91, 0xe5, 0xe9,
        0xbc, 0x10, 0xeb, 0x11, 0xe8, 0xa3, 0x18, 0xe3, 0x5c, 0x17, 0x9d, 0x05, 0xd7, 0x1a, 0x00, 0xdb,
        0xcc, 0xf7, 0x29, 0xe7, 0x94, 0x05, 0xd5, 0x6b, 0xb1, 0x8e, 0xa6, 0x25, 0x8f, 0x4a, 0xbd, 0x22,
        0xbd, 0x63, 0xad, 0x2a, 0xa4, 0x93, 0xc9, 0x5a, 0xb9, 0x11, 0x89, 0xa9, 0x3a, 0x33, 0xa7, 0x61,
        0xaa, 0x47, 0x0a, 0x25, 0xd4, 0x3f, 0x08, 0x5e, 0x5b, 0xe3, 0xde, 0x7d, 0xd2, 0x22, 0x5e, 0x56,
        0xaa, 0xd7, 0xa1, 0xe2, 0x26, 0x7b, 0x2c, 0xd5, 0xaa, 0xb3, 0xd1, 0x25, 0x64, 0xb9, 0xaf, 0x90,
        0x43, 0x57, 0x28, 0xe4, 0xb5, 0x4b, 0x0a, 0xb9, 0x32, 0x1a, 0x3b, 0x4a, 0x51, 0x36, 0x67, 0x60,
        0xba, 0xa0, 0x4f, 0xa5, 0xc3, 0x4f, 0x08, 0x6e, 0x47, 0x66, 0x0a, 0xdc, 0xbc, 0x12, 0x8b, 0x30,
        0xae, 0xaa, 0x6c, 0xe2, 0xc4, 0xfb, 0x52, 0x91, 0x31, 0x15, 0x90, 0x77, 0xa2, 0x97, 0x77, 0xf9,
        0xb2, 0xbc, 0x27, 0x22, 0xde, 0xbd, 0x27, 0x9a, 0x35, 0x98, 0x29, 0xe4, 0xa7, 0x3a, 0xf8, 0x1a,
        0xc5, 0x88, 0xcf, 0xa8, 0x68, 0xba, 0x21, 0xde, 0x4f, 0xe3, 0x1d, 0x8f, 0x68, 0xab, 0x30, 0x96,
        0x12, 0xe8, 0x6e, 0x64, 0xc0, 0xf5, 0xbe, 0x99, 0x66, 0xc8, 0xed, 0x95, 0x99, 0x6f, 0x9e, 0xd6,
        0x4a, 0xff, 0x3e, 0xad, 0x95, 0x22, 0x9e, 0x3d, 0xf5, 0xcc, 0x1f, 0x11, 0xdc, 0x19, 0xc8, 0x22,
        0xe5, 0xab, 0x35, 0x95, 0x4f, 0x50, 0xac, 0xd1, 0x54, 0xea, 0xf2, 0x68, 0xb4, 0x66, 0x2c, 0x4e,
        0x83, 0xc6, 0xbd, 0xc8, 0x42, 0xbf, 0xfc, 0x55, 0x9b, 0xf7, 0xa8, 0x68, 0xee, 0x6e, 0x59, 0xdb,
        0xcc, 0x97, 0xb3, 0x51, 0xfe, 0xd4, 0xb9, 0xbb, 0x63, 0x8b, 0x83, 0x36, 0xe1, 0x71, 0x02, 0x97,
        0xc3, 0x25, 0xa9, 0x6f, 0x1e, 0x23, 0xd0, 0x33, 0x9c, 0xee, 0xa7, 0xda, 0x3a, 0x64, 0x1f, 0x87,
        0xae, 0xf6, 0xa0, 0xef, 0x03, 0x1e, 0xa0, 0x4b, 0xef, 0xa3, 0x2f, 0x52, 0xb7, 0x7c, 0x59, 0x75,
        0x8d, 0xac, 0xba, 0x05, 0x2e, 0xf8, 0x1e, 0x81, 0xd9, 0xbf, 0x95, 0x97, 0xa0, 0xed, 0x7e, 0x3c,
        0x67, 0x37, 0x82, 0x47, 0x98, 0xb6, 0x9c, 0xce, 0x08, 0xf8, 0xff, 0x8d, 0x96, 0x4c, 0xb5, 0xee,
        0x83, 0xd5, 0x5d, 0xf8, 0x0d, 0xc1, 0x68, 0x46, 0xa6, 0x75, 0xda, 0xbe, 0xaa, 0xa7, 0xfc, 0x21,
        0x8c, 0xef, 0xe1, 0x16, 0x75, 0xbb, 0xca, 0x24, 0x8f, 0x79, 0xee, 0xe4, 0xa8, 0x3e, 0x23, 0xcb,
        0x7c, 0x9a, 0x62, 0x72, 0xf5, 0xf6, 0x72, 0xfb, 0x7d, 0xaf, 0x7b, 0x15, 0x26, 0xba, 0x1b, 0x48,
        0x7b, 0x5b, 0xfe, 0x7d, 0x18, 0x86, 0xd6, 0xb8, 0xa7, 0x7d, 0x0e, 0xd7, 0xbb, 0xde, 0xda, 0xb5,
        0xfc, 0x8c, 0xc9, 0xbd, 0x1b, 0xf5, 0xb7, 0x5f, 0x00, 0x50, 0xee, 0xf9, 0x12, 0x46, 0x73, 0x2f,
        0xce, 0xb9, 0x82, 0xd4, 0x6e, 0x88, 0xfe, 0xce, 0x0b, 0x21, 0xaa, 0xbe, 0x0b, 0x63, 0x3d, 0xef,
        0x9b, 0x37, 0x0a, 0xd2, 0xf3, 0x20, 0x7d, 0xf1, 0x02, 0x20, 0x75, 0xca, 0x23, 0xd0, 0x0a, 0xa6,
        0xf9, 0x9d, 0x22, 0x11, 0x7a, 0x60, 0x7a, 0xfd, 0x42, 0x30, 0x75, 0xd6, 0x13, 0x04, 0xfa, 0x80,
        0xc1, 0x5b, 0x54, 0xad, 0x3f, 0x5c, 0xbf, 0x77, 0x29, 0xb8, 0x22, 0x71, 0x00, 0x93, 0xfd, 0x46,
        0xdc, 0xc2, 0x80, 0x8a, 0x39, 0xac, 0xbe, 0x7c, 0x71, 0x6c, 0xd6, 0x31, 0xb9, 0x11, 0x30, 0x57,
        0x28, 0x60, 0x16, 0x52, 0xe8, 0x98, 0xe2, 0xfb, 0xac, 0x6d, 0xc0, 0x48, 0xf6, 0x2e, 0x1b, 0x03,
        0x28, 0xae, 0xd3, 0xb6, 0xfe, 0xd6, 0xe0, 0x78, 0x5a, 0x56, 0x7f, 0xe5, 0xab, 0x68, 0x96, 0x35,
        0x1e, 0x1c, 0x9f, 0x1a, 0xe8, 0xd9, 0xa9, 0x81, 0xfe, 0x3e, 0x35, 0xd0, 0x0f, 0x67, 0x46, 0xe9,
        0xd9, 0x99, 0x51, 0xfa, 0xe3, 0xcc, 0x28, 0x7d, 0xb1, 0x98, 0x19, 0x8a, 0x82, 0xb4, 0x5a, 0x2c,
        0xac, 0x53, 0x66, 0xf7, 0x7c, 0x98, 0xc6, 0xd3, 0x71, 0x6b, 0x38, 0xfe, 0xa2, 0xbe, 0xfb, 0x5f,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x5b, 0xde, 0x80, 0xea, 0x5f, 0x0c, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
        // UpdateParams defines a (governance) operation for updating the module
        // parameters. The authority defaults to the x/gov module account.
        UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
        // CreateReporter defines a (reporter) operation for creating a new reporter.
        CreateReporter(ctx context.Context, in *MsgCreateReporter, opts ...grpc.CallOption) (*MsgCreateReporterResponse, error)
        // DelegateReporter defines a (reporter) operation for delegating to a reporter.
        DelegateReporter(ctx context.Context, in *MsgDelegateReporter, opts ...grpc.CallOption) (*MsgDelegateReporterResponse, error)
        // UndelegateReporter defines a (reporter) operation for undelegating from a reporter.
        UndelegateReporter(ctx context.Context, in *MsgUndelegateReporter, opts ...grpc.CallOption) (*MsgUndelegateReporterResponse, error)
        // WithdrawReporterCommission defines a method to withdraw the
        // full commission to the reporter address.
        WithdrawReporterCommission(ctx context.Context, in *MsgWithdrawReporterCommission, opts ...grpc.CallOption) (*MsgWithdrawReporterCommissionResponse, error)
        // WithdrawDelegatorReward defines a method to withdraw rewards of delegator
        // from a reporter.
        WithdrawDelegatorReward(ctx context.Context, in *MsgWithdrawDelegatorReward, opts ...grpc.CallOption) (*MsgWithdrawDelegatorRewardResponse, error)
        // UnjailReporter defines a method to unjail a jailed reporter.
        UnjailReporter(ctx context.Context, in *MsgUnjailReporter, opts ...grpc.CallOption) (*MsgUnjailReporterResponse, error)
        // WithdrawTip defines a method to withdraw tip from a reporter module.
        WithdrawTip(ctx context.Context, in *MsgWithdrawTip, opts ...grpc.CallOption) (*MsgWithdrawTipResponse, error)
}

type msgClient struct {
        cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient <span class="cov0" title="0">{
        return &amp;msgClient{cc}
}</span>

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) <span class="cov0" title="0">{
        out := new(MsgUpdateParamsResponse)
        err := c.cc.Invoke(ctx, "/layer.reporter.Msg/UpdateParams", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgClient) CreateReporter(ctx context.Context, in *MsgCreateReporter, opts ...grpc.CallOption) (*MsgCreateReporterResponse, error) <span class="cov0" title="0">{
        out := new(MsgCreateReporterResponse)
        err := c.cc.Invoke(ctx, "/layer.reporter.Msg/CreateReporter", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgClient) DelegateReporter(ctx context.Context, in *MsgDelegateReporter, opts ...grpc.CallOption) (*MsgDelegateReporterResponse, error) <span class="cov0" title="0">{
        out := new(MsgDelegateReporterResponse)
        err := c.cc.Invoke(ctx, "/layer.reporter.Msg/DelegateReporter", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgClient) UndelegateReporter(ctx context.Context, in *MsgUndelegateReporter, opts ...grpc.CallOption) (*MsgUndelegateReporterResponse, error) <span class="cov0" title="0">{
        out := new(MsgUndelegateReporterResponse)
        err := c.cc.Invoke(ctx, "/layer.reporter.Msg/UndelegateReporter", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgClient) WithdrawReporterCommission(ctx context.Context, in *MsgWithdrawReporterCommission, opts ...grpc.CallOption) (*MsgWithdrawReporterCommissionResponse, error) <span class="cov0" title="0">{
        out := new(MsgWithdrawReporterCommissionResponse)
        err := c.cc.Invoke(ctx, "/layer.reporter.Msg/WithdrawReporterCommission", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgClient) WithdrawDelegatorReward(ctx context.Context, in *MsgWithdrawDelegatorReward, opts ...grpc.CallOption) (*MsgWithdrawDelegatorRewardResponse, error) <span class="cov0" title="0">{
        out := new(MsgWithdrawDelegatorRewardResponse)
        err := c.cc.Invoke(ctx, "/layer.reporter.Msg/WithdrawDelegatorReward", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgClient) UnjailReporter(ctx context.Context, in *MsgUnjailReporter, opts ...grpc.CallOption) (*MsgUnjailReporterResponse, error) <span class="cov0" title="0">{
        out := new(MsgUnjailReporterResponse)
        err := c.cc.Invoke(ctx, "/layer.reporter.Msg/UnjailReporter", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgClient) WithdrawTip(ctx context.Context, in *MsgWithdrawTip, opts ...grpc.CallOption) (*MsgWithdrawTipResponse, error) <span class="cov0" title="0">{
        out := new(MsgWithdrawTipResponse)
        err := c.cc.Invoke(ctx, "/layer.reporter.Msg/WithdrawTip", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
        // UpdateParams defines a (governance) operation for updating the module
        // parameters. The authority defaults to the x/gov module account.
        UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
        // CreateReporter defines a (reporter) operation for creating a new reporter.
        CreateReporter(context.Context, *MsgCreateReporter) (*MsgCreateReporterResponse, error)
        // DelegateReporter defines a (reporter) operation for delegating to a reporter.
        DelegateReporter(context.Context, *MsgDelegateReporter) (*MsgDelegateReporterResponse, error)
        // UndelegateReporter defines a (reporter) operation for undelegating from a reporter.
        UndelegateReporter(context.Context, *MsgUndelegateReporter) (*MsgUndelegateReporterResponse, error)
        // WithdrawReporterCommission defines a method to withdraw the
        // full commission to the reporter address.
        WithdrawReporterCommission(context.Context, *MsgWithdrawReporterCommission) (*MsgWithdrawReporterCommissionResponse, error)
        // WithdrawDelegatorReward defines a method to withdraw rewards of delegator
        // from a reporter.
        WithdrawDelegatorReward(context.Context, *MsgWithdrawDelegatorReward) (*MsgWithdrawDelegatorRewardResponse, error)
        // UnjailReporter defines a method to unjail a jailed reporter.
        UnjailReporter(context.Context, *MsgUnjailReporter) (*MsgUnjailReporterResponse, error)
        // WithdrawTip defines a method to withdraw tip from a reporter module.
        WithdrawTip(context.Context, *MsgWithdrawTip) (*MsgWithdrawTipResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}</span>
func (*UnimplementedMsgServer) CreateReporter(ctx context.Context, req *MsgCreateReporter) (*MsgCreateReporterResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateReporter not implemented")
}</span>
func (*UnimplementedMsgServer) DelegateReporter(ctx context.Context, req *MsgDelegateReporter) (*MsgDelegateReporterResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DelegateReporter not implemented")
}</span>
func (*UnimplementedMsgServer) UndelegateReporter(ctx context.Context, req *MsgUndelegateReporter) (*MsgUndelegateReporterResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UndelegateReporter not implemented")
}</span>
func (*UnimplementedMsgServer) WithdrawReporterCommission(ctx context.Context, req *MsgWithdrawReporterCommission) (*MsgWithdrawReporterCommissionResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method WithdrawReporterCommission not implemented")
}</span>
func (*UnimplementedMsgServer) WithdrawDelegatorReward(ctx context.Context, req *MsgWithdrawDelegatorReward) (*MsgWithdrawDelegatorRewardResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method WithdrawDelegatorReward not implemented")
}</span>
func (*UnimplementedMsgServer) UnjailReporter(ctx context.Context, req *MsgUnjailReporter) (*MsgUnjailReporterResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UnjailReporter not implemented")
}</span>
func (*UnimplementedMsgServer) WithdrawTip(ctx context.Context, req *MsgWithdrawTip) (*MsgWithdrawTipResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method WithdrawTip not implemented")
}</span>

func RegisterMsgServer(s grpc1.Server, srv MsgServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;_Msg_serviceDesc, srv)
}</span>

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgUpdateParams)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).UpdateParams(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.reporter.Msg/UpdateParams",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Msg_CreateReporter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgCreateReporter)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).CreateReporter(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.reporter.Msg/CreateReporter",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).CreateReporter(ctx, req.(*MsgCreateReporter))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Msg_DelegateReporter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgDelegateReporter)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).DelegateReporter(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.reporter.Msg/DelegateReporter",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).DelegateReporter(ctx, req.(*MsgDelegateReporter))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Msg_UndelegateReporter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgUndelegateReporter)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).UndelegateReporter(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.reporter.Msg/UndelegateReporter",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).UndelegateReporter(ctx, req.(*MsgUndelegateReporter))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Msg_WithdrawReporterCommission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgWithdrawReporterCommission)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).WithdrawReporterCommission(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.reporter.Msg/WithdrawReporterCommission",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).WithdrawReporterCommission(ctx, req.(*MsgWithdrawReporterCommission))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Msg_WithdrawDelegatorReward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgWithdrawDelegatorReward)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).WithdrawDelegatorReward(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.reporter.Msg/WithdrawDelegatorReward",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).WithdrawDelegatorReward(ctx, req.(*MsgWithdrawDelegatorReward))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Msg_UnjailReporter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgUnjailReporter)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).UnjailReporter(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.reporter.Msg/UnjailReporter",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).UnjailReporter(ctx, req.(*MsgUnjailReporter))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Msg_WithdrawTip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgWithdrawTip)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).WithdrawTip(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/layer.reporter.Msg/WithdrawTip",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).WithdrawTip(ctx, req.(*MsgWithdrawTip))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _Msg_serviceDesc = grpc.ServiceDesc{
        ServiceName: "layer.reporter.Msg",
        HandlerType: (*MsgServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "UpdateParams",
                        Handler:    _Msg_UpdateParams_Handler,
                },
                {
                        MethodName: "CreateReporter",
                        Handler:    _Msg_CreateReporter_Handler,
                },
                {
                        MethodName: "DelegateReporter",
                        Handler:    _Msg_DelegateReporter_Handler,
                },
                {
                        MethodName: "UndelegateReporter",
                        Handler:    _Msg_UndelegateReporter_Handler,
                },
                {
                        MethodName: "WithdrawReporterCommission",
                        Handler:    _Msg_WithdrawReporterCommission_Handler,
                },
                {
                        MethodName: "WithdrawDelegatorReward",
                        Handler:    _Msg_WithdrawDelegatorReward_Handler,
                },
                {
                        MethodName: "UnjailReporter",
                        Handler:    _Msg_UnjailReporter_Handler,
                },
                {
                        MethodName: "WithdrawTip",
                        Handler:    _Msg_WithdrawTip_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "layer/reporter/tx.proto",
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintTx(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x12
        if len(m.Authority) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Authority)
                copy(dAtA[i:], m.Authority)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgCreateReporter) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgCreateReporter) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgCreateReporter) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Commission != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Commission.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintTx(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0x22</span>
        }
        <span class="cov0" title="0">if len(m.TokenOrigins) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.TokenOrigins) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.TokenOrigins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintTx(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x1a</span>
                }
        }
        <span class="cov0" title="0">{
                size := m.Amount.Size()
                i -= size
                if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintTx(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x12
        if len(m.Reporter) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Reporter)
                copy(dAtA[i:], m.Reporter)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Reporter)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgCreateReporterResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgCreateReporterResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgCreateReporterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgDelegateReporter) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgDelegateReporter) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgDelegateReporter) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.TokenOrigins) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.TokenOrigins) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.TokenOrigins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintTx(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x22</span>
                }
        }
        <span class="cov0" title="0">{
                size := m.Amount.Size()
                i -= size
                if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintTx(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x1a
        if len(m.Reporter) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Reporter)
                copy(dAtA[i:], m.Reporter)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Reporter)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Delegator) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Delegator)
                copy(dAtA[i:], m.Delegator)
                i = encodeVarintTx(dAtA, i, uint64(len(m.Delegator)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgDelegateReporterResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgDelegateReporterResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgDelegateReporterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgUndelegateReporter) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUndelegateReporter) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUndelegateReporter) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.TokenOrigins) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.TokenOrigins) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.TokenOrigins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintTx(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x12</span>
                }
        }
        <span class="cov0" title="0">if len(m.DelegatorAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.DelegatorAddress)
                copy(dAtA[i:], m.DelegatorAddress)
                i = encodeVarintTx(dAtA, i, uint64(len(m.DelegatorAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgUndelegateReporterResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUndelegateReporterResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUndelegateReporterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgWithdrawReporterCommission) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgWithdrawReporterCommission) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgWithdrawReporterCommission) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ReporterAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ReporterAddress)
                copy(dAtA[i:], m.ReporterAddress)
                i = encodeVarintTx(dAtA, i, uint64(len(m.ReporterAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgWithdrawReporterCommissionResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgWithdrawReporterCommissionResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgWithdrawReporterCommissionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Amount) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Amount) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintTx(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgWithdrawDelegatorReward) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgWithdrawDelegatorReward) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgWithdrawDelegatorReward) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ReporterAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ReporterAddress)
                copy(dAtA[i:], m.ReporterAddress)
                i = encodeVarintTx(dAtA, i, uint64(len(m.ReporterAddress)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.DelegatorAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.DelegatorAddress)
                copy(dAtA[i:], m.DelegatorAddress)
                i = encodeVarintTx(dAtA, i, uint64(len(m.DelegatorAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgWithdrawDelegatorRewardResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgWithdrawDelegatorRewardResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgWithdrawDelegatorRewardResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Amount) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Amount) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintTx(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgUnjailReporter) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUnjailReporter) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUnjailReporter) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ReporterAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ReporterAddress)
                copy(dAtA[i:], m.ReporterAddress)
                i = encodeVarintTx(dAtA, i, uint64(len(m.ReporterAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgUnjailReporterResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUnjailReporterResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUnjailReporterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgWithdrawTip) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgWithdrawTip) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgWithdrawTip) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ValidatorAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ValidatorAddress)
                copy(dAtA[i:], m.ValidatorAddress)
                i = encodeVarintTx(dAtA, i, uint64(len(m.ValidatorAddress)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.DelegatorAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.DelegatorAddress)
                copy(dAtA[i:], m.DelegatorAddress)
                i = encodeVarintTx(dAtA, i, uint64(len(m.DelegatorAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgWithdrawTipResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgWithdrawTipResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgWithdrawTipResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func encodeVarintTx(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovTx(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *MsgUpdateParams) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Authority)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Params.Size()
        n += 1 + l + sovTx(uint64(l))
        return n</span>
}

func (m *MsgUpdateParamsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgCreateReporter) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Reporter)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Amount.Size()
        n += 1 + l + sovTx(uint64(l))
        if len(m.TokenOrigins) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.TokenOrigins </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovTx(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">if m.Commission != nil </span><span class="cov0" title="0">{
                l = m.Commission.Size()
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgCreateReporterResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgDelegateReporter) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Delegator)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Reporter)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Amount.Size()
        n += 1 + l + sovTx(uint64(l))
        if len(m.TokenOrigins) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.TokenOrigins </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovTx(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *MsgDelegateReporterResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgUndelegateReporter) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.DelegatorAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">if len(m.TokenOrigins) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.TokenOrigins </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovTx(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *MsgUndelegateReporterResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgWithdrawReporterCommission) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.ReporterAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgWithdrawReporterCommissionResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Amount) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Amount </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovTx(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *MsgWithdrawDelegatorReward) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.DelegatorAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.ReporterAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgWithdrawDelegatorRewardResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Amount) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Amount </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovTx(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *MsgUnjailReporter) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.ReporterAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgUnjailReporterResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgWithdrawTip) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.DelegatorAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.ValidatorAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgWithdrawTipResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func sovTx(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozTx(x uint64) (n int) <span class="cov0" title="0">{
        return sovTx(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Authority = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgCreateReporter) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCreateReporter: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCreateReporter: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Reporter = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field TokenOrigins", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.TokenOrigins = append(m.TokenOrigins, &amp;TokenOrigin{})
                        if err := m.TokenOrigins[len(m.TokenOrigins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Commission == nil </span><span class="cov0" title="0">{
                                m.Commission = &amp;types.Commission{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Commission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgCreateReporterResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCreateReporterResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCreateReporterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgDelegateReporter) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgDelegateReporter: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgDelegateReporter: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Delegator", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Delegator = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Reporter = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field TokenOrigins", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.TokenOrigins = append(m.TokenOrigins, &amp;TokenOrigin{})
                        if err := m.TokenOrigins[len(m.TokenOrigins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgDelegateReporterResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgDelegateReporterResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgDelegateReporterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUndelegateReporter) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUndelegateReporter: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUndelegateReporter: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.DelegatorAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field TokenOrigins", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.TokenOrigins = append(m.TokenOrigins, &amp;TokenOrigin{})
                        if err := m.TokenOrigins[len(m.TokenOrigins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUndelegateReporterResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUndelegateReporterResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUndelegateReporterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgWithdrawReporterCommission) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgWithdrawReporterCommission: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgWithdrawReporterCommission: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ReporterAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ReporterAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgWithdrawReporterCommissionResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgWithdrawReporterCommissionResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgWithdrawReporterCommissionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Amount = append(m.Amount, types1.Coin{})
                        if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgWithdrawDelegatorReward) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgWithdrawDelegatorReward: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgWithdrawDelegatorReward: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.DelegatorAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ReporterAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ReporterAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgWithdrawDelegatorRewardResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgWithdrawDelegatorRewardResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgWithdrawDelegatorRewardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Amount = append(m.Amount, types1.Coin{})
                        if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUnjailReporter) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUnjailReporter: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUnjailReporter: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ReporterAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ReporterAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUnjailReporterResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUnjailReporterResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUnjailReporterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgWithdrawTip) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgWithdrawTip: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgWithdrawTip: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.DelegatorAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgWithdrawTipResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgWithdrawTipResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgWithdrawTipResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipTx(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupTx
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthTx
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
