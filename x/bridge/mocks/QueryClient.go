// Code generated by mockery v2.51.1. DO NOT EDIT.

package mocks

import (
	context "context"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"

	types "github.com/tellor-io/layer/x/bridge/types"
)

// QueryClient is an autogenerated mock type for the QueryClient type
type QueryClient struct {
	mock.Mock
}

// GetAttestationDataBySnapshot provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) GetAttestationDataBySnapshot(ctx context.Context, in *types.QueryGetAttestationDataBySnapshotRequest, opts ...grpc.CallOption) (*types.QueryGetAttestationDataBySnapshotResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAttestationDataBySnapshot")
	}

	var r0 *types.QueryGetAttestationDataBySnapshotResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetAttestationDataBySnapshotRequest, ...grpc.CallOption) (*types.QueryGetAttestationDataBySnapshotResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetAttestationDataBySnapshotRequest, ...grpc.CallOption) *types.QueryGetAttestationDataBySnapshotResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryGetAttestationDataBySnapshotResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryGetAttestationDataBySnapshotRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAttestationsBySnapshot provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) GetAttestationsBySnapshot(ctx context.Context, in *types.QueryGetAttestationsBySnapshotRequest, opts ...grpc.CallOption) (*types.QueryGetAttestationsBySnapshotResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAttestationsBySnapshot")
	}

	var r0 *types.QueryGetAttestationsBySnapshotResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetAttestationsBySnapshotRequest, ...grpc.CallOption) (*types.QueryGetAttestationsBySnapshotResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetAttestationsBySnapshotRequest, ...grpc.CallOption) *types.QueryGetAttestationsBySnapshotResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryGetAttestationsBySnapshotResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryGetAttestationsBySnapshotRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCurrentValidatorSetTimestamp provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) GetCurrentValidatorSetTimestamp(ctx context.Context, in *types.QueryGetCurrentValidatorSetTimestampRequest, opts ...grpc.CallOption) (*types.QueryGetCurrentValidatorSetTimestampResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCurrentValidatorSetTimestamp")
	}

	var r0 *types.QueryGetCurrentValidatorSetTimestampResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetCurrentValidatorSetTimestampRequest, ...grpc.CallOption) (*types.QueryGetCurrentValidatorSetTimestampResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetCurrentValidatorSetTimestampRequest, ...grpc.CallOption) *types.QueryGetCurrentValidatorSetTimestampResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryGetCurrentValidatorSetTimestampResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryGetCurrentValidatorSetTimestampRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDepositClaimed provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) GetDepositClaimed(ctx context.Context, in *types.QueryGetDepositClaimedRequest, opts ...grpc.CallOption) (*types.QueryGetDepositClaimedResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDepositClaimed")
	}

	var r0 *types.QueryGetDepositClaimedResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetDepositClaimedRequest, ...grpc.CallOption) (*types.QueryGetDepositClaimedResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetDepositClaimedRequest, ...grpc.CallOption) *types.QueryGetDepositClaimedResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryGetDepositClaimedResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryGetDepositClaimedRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEvmAddressByValidatorAddress provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) GetEvmAddressByValidatorAddress(ctx context.Context, in *types.QueryGetEvmAddressByValidatorAddressRequest, opts ...grpc.CallOption) (*types.QueryGetEvmAddressByValidatorAddressResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEvmAddressByValidatorAddress")
	}

	var r0 *types.QueryGetEvmAddressByValidatorAddressResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetEvmAddressByValidatorAddressRequest, ...grpc.CallOption) (*types.QueryGetEvmAddressByValidatorAddressResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetEvmAddressByValidatorAddressRequest, ...grpc.CallOption) *types.QueryGetEvmAddressByValidatorAddressResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryGetEvmAddressByValidatorAddressResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryGetEvmAddressByValidatorAddressRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEvmValidators provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) GetEvmValidators(ctx context.Context, in *types.QueryGetEvmValidatorsRequest, opts ...grpc.CallOption) (*types.QueryGetEvmValidatorsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEvmValidators")
	}

	var r0 *types.QueryGetEvmValidatorsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetEvmValidatorsRequest, ...grpc.CallOption) (*types.QueryGetEvmValidatorsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetEvmValidatorsRequest, ...grpc.CallOption) *types.QueryGetEvmValidatorsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryGetEvmValidatorsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryGetEvmValidatorsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLastWithdrawalId provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) GetLastWithdrawalId(ctx context.Context, in *types.QueryGetLastWithdrawalIdRequest, opts ...grpc.CallOption) (*types.QueryGetLastWithdrawalIdResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLastWithdrawalId")
	}

	var r0 *types.QueryGetLastWithdrawalIdResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetLastWithdrawalIdRequest, ...grpc.CallOption) (*types.QueryGetLastWithdrawalIdResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetLastWithdrawalIdRequest, ...grpc.CallOption) *types.QueryGetLastWithdrawalIdResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryGetLastWithdrawalIdResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryGetLastWithdrawalIdRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSnapshotLimit provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) GetSnapshotLimit(ctx context.Context, in *types.QueryGetSnapshotLimitRequest, opts ...grpc.CallOption) (*types.QueryGetSnapshotLimitResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSnapshotLimit")
	}

	var r0 *types.QueryGetSnapshotLimitResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetSnapshotLimitRequest, ...grpc.CallOption) (*types.QueryGetSnapshotLimitResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetSnapshotLimitRequest, ...grpc.CallOption) *types.QueryGetSnapshotLimitResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryGetSnapshotLimitResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryGetSnapshotLimitRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSnapshotsByReport provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) GetSnapshotsByReport(ctx context.Context, in *types.QueryGetSnapshotsByReportRequest, opts ...grpc.CallOption) (*types.QueryGetSnapshotsByReportResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSnapshotsByReport")
	}

	var r0 *types.QueryGetSnapshotsByReportResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetSnapshotsByReportRequest, ...grpc.CallOption) (*types.QueryGetSnapshotsByReportResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetSnapshotsByReportRequest, ...grpc.CallOption) *types.QueryGetSnapshotsByReportResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryGetSnapshotsByReportResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryGetSnapshotsByReportRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetValidatorCheckpoint provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) GetValidatorCheckpoint(ctx context.Context, in *types.QueryGetValidatorCheckpointRequest, opts ...grpc.CallOption) (*types.QueryGetValidatorCheckpointResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetValidatorCheckpoint")
	}

	var r0 *types.QueryGetValidatorCheckpointResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetValidatorCheckpointRequest, ...grpc.CallOption) (*types.QueryGetValidatorCheckpointResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetValidatorCheckpointRequest, ...grpc.CallOption) *types.QueryGetValidatorCheckpointResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryGetValidatorCheckpointResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryGetValidatorCheckpointRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetValidatorCheckpointParams provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) GetValidatorCheckpointParams(ctx context.Context, in *types.QueryGetValidatorCheckpointParamsRequest, opts ...grpc.CallOption) (*types.QueryGetValidatorCheckpointParamsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetValidatorCheckpointParams")
	}

	var r0 *types.QueryGetValidatorCheckpointParamsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetValidatorCheckpointParamsRequest, ...grpc.CallOption) (*types.QueryGetValidatorCheckpointParamsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetValidatorCheckpointParamsRequest, ...grpc.CallOption) *types.QueryGetValidatorCheckpointParamsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryGetValidatorCheckpointParamsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryGetValidatorCheckpointParamsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetValidatorSetIndexByTimestamp provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) GetValidatorSetIndexByTimestamp(ctx context.Context, in *types.QueryGetValidatorSetIndexByTimestampRequest, opts ...grpc.CallOption) (*types.QueryGetValidatorSetIndexByTimestampResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetValidatorSetIndexByTimestamp")
	}

	var r0 *types.QueryGetValidatorSetIndexByTimestampResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetValidatorSetIndexByTimestampRequest, ...grpc.CallOption) (*types.QueryGetValidatorSetIndexByTimestampResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetValidatorSetIndexByTimestampRequest, ...grpc.CallOption) *types.QueryGetValidatorSetIndexByTimestampResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryGetValidatorSetIndexByTimestampResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryGetValidatorSetIndexByTimestampRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetValidatorTimestampByIndex provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) GetValidatorTimestampByIndex(ctx context.Context, in *types.QueryGetValidatorTimestampByIndexRequest, opts ...grpc.CallOption) (*types.QueryGetValidatorTimestampByIndexResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetValidatorTimestampByIndex")
	}

	var r0 *types.QueryGetValidatorTimestampByIndexResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetValidatorTimestampByIndexRequest, ...grpc.CallOption) (*types.QueryGetValidatorTimestampByIndexResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetValidatorTimestampByIndexRequest, ...grpc.CallOption) *types.QueryGetValidatorTimestampByIndexResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryGetValidatorTimestampByIndexResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryGetValidatorTimestampByIndexRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetValsetByTimestamp provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) GetValsetByTimestamp(ctx context.Context, in *types.QueryGetValsetByTimestampRequest, opts ...grpc.CallOption) (*types.QueryGetValsetByTimestampResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetValsetByTimestamp")
	}

	var r0 *types.QueryGetValsetByTimestampResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetValsetByTimestampRequest, ...grpc.CallOption) (*types.QueryGetValsetByTimestampResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetValsetByTimestampRequest, ...grpc.CallOption) *types.QueryGetValsetByTimestampResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryGetValsetByTimestampResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryGetValsetByTimestampRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetValsetSigs provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) GetValsetSigs(ctx context.Context, in *types.QueryGetValsetSigsRequest, opts ...grpc.CallOption) (*types.QueryGetValsetSigsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetValsetSigs")
	}

	var r0 *types.QueryGetValsetSigsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetValsetSigsRequest, ...grpc.CallOption) (*types.QueryGetValsetSigsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGetValsetSigsRequest, ...grpc.CallOption) *types.QueryGetValsetSigsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryGetValsetSigsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryGetValsetSigsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Params provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) Params(ctx context.Context, in *types.QueryParamsRequest, opts ...grpc.CallOption) (*types.QueryParamsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Params")
	}

	var r0 *types.QueryParamsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryParamsRequest, ...grpc.CallOption) (*types.QueryParamsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryParamsRequest, ...grpc.CallOption) *types.QueryParamsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryParamsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryParamsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewQueryClient creates a new instance of QueryClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewQueryClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *QueryClient {
	mock := &QueryClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
