package pricefeed

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"testing"

	"github.com/stretchr/testify/require"
	"golang.org/x/exp/maps"
)

// ErrorMapsEqual is a testing method that takes any two maps of keys to errors and asserts that they have the same
// sets of keys, and that each associated error value has the same rendered message.
func ErrorMapsEqual[K comparable](t *testing.T, expected, actual map[K]error) {
	t.Helper()
	require.Equal(t, len(expected), len(actual))
	for key, expectedError := range expected {
		error, ok := actual[key]
		require.True(t, ok)
		require.EqualError(t, error, expectedError.Error())
	}
}

// ErrorsEqual is a testing method that takes any two slices of errors and asserts that each actual error has
// the same rendered message as the expected error.
func ErrorsEqual(t *testing.T, expected, actual []error) {
	t.Helper()
	require.Equal(t, len(expected), len(actual))
	for i, expectedError := range expected {
		require.EqualError(t, expectedError, actual[i].Error())
	}
}

// ReadJsonTestFile takes a test file with human-readable, formatted JSON, load it, and compacts it.
// The purpose is to remove the formatting (e.g. newlines, tabs, etc) and return a string that would match an
// unmarshaled object string generated by a Go program natively.
func ReadJsonTestFile(t *testing.T, fileName string) string {
	t.Helper()
	fileBytes, err := os.ReadFile(fmt.Sprintf("testdata/%v", fileName))
	require.NoError(t, err, "Error reading test file")
	return CompactJsonString(t, string(fileBytes))
}

func CompactJsonString(t *testing.T, jsonString string) string {
	t.Helper()
	buffer := &bytes.Buffer{}
	err := json.Compact(buffer, []byte(jsonString))
	require.NoError(t, err, "Error compacting JSON string")
	return buffer.String()
}

// MarketParamErrorsEqual is a testing method that takes any two maps of market ids to errors and asserts that they
// have the same sets of keys, and that each associated error value has the same rendered message
func MarketParamErrorsEqual(
	t *testing.T,
	expectedMarketParamErrors map[uint32]error,
	actualMarketParamErrors map[uint32]error,
) {
	t.Helper()
	require.Equal(t, maps.Keys(expectedMarketParamErrors), maps.Keys(actualMarketParamErrors))
	for marketId, expectedErr := range expectedMarketParamErrors {
		actualErr := actualMarketParamErrors[marketId]
		require.ErrorContains(
			t,
			actualErr,
			expectedErr.Error(),
			"Errors for market id %v do not match",
			marketId,
		)
	}
}
