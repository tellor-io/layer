// Code generated by mockery v2.23.1. DO NOT EDIT.

package mocks

import (
	keyring "github.com/cosmos/cosmos-sdk/crypto/keyring"
	cryptotypes "github.com/cosmos/cosmos-sdk/crypto/types"

	mock "github.com/stretchr/testify/mock"

	signing "github.com/cosmos/cosmos-sdk/types/tx/signing"

	types "github.com/cosmos/cosmos-sdk/types"
)

// Keyring is an autogenerated mock type for the Keyring type
type Keyring struct {
	mock.Mock
}

// Backend provides a mock function with given fields:
func (_m *Keyring) Backend() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Delete provides a mock function with given fields: uid
func (_m *Keyring) Delete(uid string) error {
	ret := _m.Called(uid)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(uid)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteByAddress provides a mock function with given fields: address
func (_m *Keyring) DeleteByAddress(address types.Address) error {
	ret := _m.Called(address)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Address) error); ok {
		r0 = rf(address)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ExportPrivKeyArmor provides a mock function with given fields: uid, encryptPassphrase
func (_m *Keyring) ExportPrivKeyArmor(uid string, encryptPassphrase string) (string, error) {
	ret := _m.Called(uid, encryptPassphrase)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (string, error)); ok {
		return rf(uid, encryptPassphrase)
	}
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(uid, encryptPassphrase)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(uid, encryptPassphrase)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportPrivKeyArmorByAddress provides a mock function with given fields: address, encryptPassphrase
func (_m *Keyring) ExportPrivKeyArmorByAddress(address types.Address, encryptPassphrase string) (string, error) {
	ret := _m.Called(address, encryptPassphrase)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Address, string) (string, error)); ok {
		return rf(address, encryptPassphrase)
	}
	if rf, ok := ret.Get(0).(func(types.Address, string) string); ok {
		r0 = rf(address, encryptPassphrase)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(types.Address, string) error); ok {
		r1 = rf(address, encryptPassphrase)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportPubKeyArmor provides a mock function with given fields: uid
func (_m *Keyring) ExportPubKeyArmor(uid string) (string, error) {
	ret := _m.Called(uid)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (string, error)); ok {
		return rf(uid)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(uid)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(uid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportPubKeyArmorByAddress provides a mock function with given fields: address
func (_m *Keyring) ExportPubKeyArmorByAddress(address types.Address) (string, error) {
	ret := _m.Called(address)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Address) (string, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(types.Address) string); ok {
		r0 = rf(address)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(types.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportPrivKey provides a mock function with given fields: uid, armor, passphrase
func (_m *Keyring) ImportPrivKey(uid string, armor string, passphrase string) error {
	ret := _m.Called(uid, armor, passphrase)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(uid, armor, passphrase)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ImportPrivKeyHex provides a mock function with given fields: uid, privKey, algoStr
func (_m *Keyring) ImportPrivKeyHex(uid string, privKey string, algoStr string) error {
	ret := _m.Called(uid, privKey, algoStr)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(uid, privKey, algoStr)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ImportPubKey provides a mock function with given fields: uid, armor
func (_m *Keyring) ImportPubKey(uid string, armor string) error {
	ret := _m.Called(uid, armor)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(uid, armor)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Key provides a mock function with given fields: uid
func (_m *Keyring) Key(uid string) (*keyring.Record, error) {
	ret := _m.Called(uid)

	var r0 *keyring.Record
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*keyring.Record, error)); ok {
		return rf(uid)
	}
	if rf, ok := ret.Get(0).(func(string) *keyring.Record); ok {
		r0 = rf(uid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*keyring.Record)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(uid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KeyByAddress provides a mock function with given fields: address
func (_m *Keyring) KeyByAddress(address types.Address) (*keyring.Record, error) {
	ret := _m.Called(address)

	var r0 *keyring.Record
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Address) (*keyring.Record, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(types.Address) *keyring.Record); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*keyring.Record)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// List provides a mock function with given fields:
func (_m *Keyring) List() ([]*keyring.Record, error) {
	ret := _m.Called()

	var r0 []*keyring.Record
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]*keyring.Record, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []*keyring.Record); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*keyring.Record)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MigrateAll provides a mock function with given fields:
func (_m *Keyring) MigrateAll() ([]*keyring.Record, error) {
	ret := _m.Called()

	var r0 []*keyring.Record
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]*keyring.Record, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []*keyring.Record); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*keyring.Record)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewAccount provides a mock function with given fields: uid, mnemonic, bip39Passphrase, hdPath, algo
func (_m *Keyring) NewAccount(uid string, mnemonic string, bip39Passphrase string, hdPath string, algo keyring.SignatureAlgo) (*keyring.Record, error) {
	ret := _m.Called(uid, mnemonic, bip39Passphrase, hdPath, algo)

	var r0 *keyring.Record
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, keyring.SignatureAlgo) (*keyring.Record, error)); ok {
		return rf(uid, mnemonic, bip39Passphrase, hdPath, algo)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, string, keyring.SignatureAlgo) *keyring.Record); ok {
		r0 = rf(uid, mnemonic, bip39Passphrase, hdPath, algo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*keyring.Record)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, string, keyring.SignatureAlgo) error); ok {
		r1 = rf(uid, mnemonic, bip39Passphrase, hdPath, algo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewMnemonic provides a mock function with given fields: uid, language, hdPath, bip39Passphrase, algo
func (_m *Keyring) NewMnemonic(uid string, language keyring.Language, hdPath string, bip39Passphrase string, algo keyring.SignatureAlgo) (*keyring.Record, string, error) {
	ret := _m.Called(uid, language, hdPath, bip39Passphrase, algo)

	var r0 *keyring.Record
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(string, keyring.Language, string, string, keyring.SignatureAlgo) (*keyring.Record, string, error)); ok {
		return rf(uid, language, hdPath, bip39Passphrase, algo)
	}
	if rf, ok := ret.Get(0).(func(string, keyring.Language, string, string, keyring.SignatureAlgo) *keyring.Record); ok {
		r0 = rf(uid, language, hdPath, bip39Passphrase, algo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*keyring.Record)
		}
	}

	if rf, ok := ret.Get(1).(func(string, keyring.Language, string, string, keyring.SignatureAlgo) string); ok {
		r1 = rf(uid, language, hdPath, bip39Passphrase, algo)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(string, keyring.Language, string, string, keyring.SignatureAlgo) error); ok {
		r2 = rf(uid, language, hdPath, bip39Passphrase, algo)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Rename provides a mock function with given fields: from, to
func (_m *Keyring) Rename(from string, to string) error {
	ret := _m.Called(from, to)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(from, to)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveLedgerKey provides a mock function with given fields: uid, algo, hrp, coinType, account, index
func (_m *Keyring) SaveLedgerKey(uid string, algo keyring.SignatureAlgo, hrp string, coinType uint32, account uint32, index uint32) (*keyring.Record, error) {
	ret := _m.Called(uid, algo, hrp, coinType, account, index)

	var r0 *keyring.Record
	var r1 error
	if rf, ok := ret.Get(0).(func(string, keyring.SignatureAlgo, string, uint32, uint32, uint32) (*keyring.Record, error)); ok {
		return rf(uid, algo, hrp, coinType, account, index)
	}
	if rf, ok := ret.Get(0).(func(string, keyring.SignatureAlgo, string, uint32, uint32, uint32) *keyring.Record); ok {
		r0 = rf(uid, algo, hrp, coinType, account, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*keyring.Record)
		}
	}

	if rf, ok := ret.Get(1).(func(string, keyring.SignatureAlgo, string, uint32, uint32, uint32) error); ok {
		r1 = rf(uid, algo, hrp, coinType, account, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SaveMultisig provides a mock function with given fields: uid, pubkey
func (_m *Keyring) SaveMultisig(uid string, pubkey cryptotypes.PubKey) (*keyring.Record, error) {
	ret := _m.Called(uid, pubkey)

	var r0 *keyring.Record
	var r1 error
	if rf, ok := ret.Get(0).(func(string, cryptotypes.PubKey) (*keyring.Record, error)); ok {
		return rf(uid, pubkey)
	}
	if rf, ok := ret.Get(0).(func(string, cryptotypes.PubKey) *keyring.Record); ok {
		r0 = rf(uid, pubkey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*keyring.Record)
		}
	}

	if rf, ok := ret.Get(1).(func(string, cryptotypes.PubKey) error); ok {
		r1 = rf(uid, pubkey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SaveOfflineKey provides a mock function with given fields: uid, pubkey
func (_m *Keyring) SaveOfflineKey(uid string, pubkey cryptotypes.PubKey) (*keyring.Record, error) {
	ret := _m.Called(uid, pubkey)

	var r0 *keyring.Record
	var r1 error
	if rf, ok := ret.Get(0).(func(string, cryptotypes.PubKey) (*keyring.Record, error)); ok {
		return rf(uid, pubkey)
	}
	if rf, ok := ret.Get(0).(func(string, cryptotypes.PubKey) *keyring.Record); ok {
		r0 = rf(uid, pubkey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*keyring.Record)
		}
	}

	if rf, ok := ret.Get(1).(func(string, cryptotypes.PubKey) error); ok {
		r1 = rf(uid, pubkey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Sign provides a mock function with given fields: uid, msg, signMode
func (_m *Keyring) Sign(uid string, msg []byte, signMode signing.SignMode) ([]byte, cryptotypes.PubKey, error) {
	ret := _m.Called(uid, msg, signMode)

	var r0 []byte
	var r1 cryptotypes.PubKey
	var r2 error
	if rf, ok := ret.Get(0).(func(string, []byte, signing.SignMode) ([]byte, cryptotypes.PubKey, error)); ok {
		return rf(uid, msg, signMode)
	}
	if rf, ok := ret.Get(0).(func(string, []byte, signing.SignMode) []byte); ok {
		r0 = rf(uid, msg, signMode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(string, []byte, signing.SignMode) cryptotypes.PubKey); ok {
		r1 = rf(uid, msg, signMode)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(cryptotypes.PubKey)
		}
	}

	if rf, ok := ret.Get(2).(func(string, []byte, signing.SignMode) error); ok {
		r2 = rf(uid, msg, signMode)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SignByAddress provides a mock function with given fields: address, msg, signMode
func (_m *Keyring) SignByAddress(address types.Address, msg []byte, signMode signing.SignMode) ([]byte, cryptotypes.PubKey, error) {
	ret := _m.Called(address, msg, signMode)

	var r0 []byte
	var r1 cryptotypes.PubKey
	var r2 error
	if rf, ok := ret.Get(0).(func(types.Address, []byte, signing.SignMode) ([]byte, cryptotypes.PubKey, error)); ok {
		return rf(address, msg, signMode)
	}
	if rf, ok := ret.Get(0).(func(types.Address, []byte, signing.SignMode) []byte); ok {
		r0 = rf(address, msg, signMode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Address, []byte, signing.SignMode) cryptotypes.PubKey); ok {
		r1 = rf(address, msg, signMode)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(cryptotypes.PubKey)
		}
	}

	if rf, ok := ret.Get(2).(func(types.Address, []byte, signing.SignMode) error); ok {
		r2 = rf(address, msg, signMode)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SupportedAlgorithms provides a mock function with given fields:
func (_m *Keyring) SupportedAlgorithms() (keyring.SigningAlgoList, keyring.SigningAlgoList) {
	ret := _m.Called()

	var r0 keyring.SigningAlgoList
	var r1 keyring.SigningAlgoList
	if rf, ok := ret.Get(0).(func() (keyring.SigningAlgoList, keyring.SigningAlgoList)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() keyring.SigningAlgoList); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(keyring.SigningAlgoList)
		}
	}

	if rf, ok := ret.Get(1).(func() keyring.SigningAlgoList); ok {
		r1 = rf()
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(keyring.SigningAlgoList)
		}
	}

	return r0, r1
}

type mockConstructorTestingTNewKeyring interface {
	mock.TestingT
	Cleanup(func())
}

// NewKeyring creates a new instance of Keyring. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewKeyring(t mockConstructorTestingTNewKeyring) *Keyring {
	mock := &Keyring{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
